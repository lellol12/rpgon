<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path of the Ascendant Dragon - Wuxia RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }

        /* Combined and updated body style */
        body {
            font-family: 'Inter', sans-serif;
            color: #e2e8f0; /* Default text color */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            background-color: #1a202c; /* Fallback color */
            background-image: url('main.png');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            background-attachment: fixed; /* Keeps background fixed */
        }
        .game-container { display: flex; flex-direction: column; flex-grow: 1; max-width: 1000px; margin: auto; width: 100%; }
        
        /* Game Output Styling */
        .game-output p { margin-bottom: 0.75rem; line-height: 1.6; }
        .game-output .narration { color: #a0aec0; font-style: italic; }
        .game-output .dialogue { color: #63b3ed; }
        .game-output .important { color: #f6e05e; font-weight: bold; }
        .game-output .error { color: #fc8181; }
        .game-output .success { color: #68d391; }
        .game-output .system { color: #9f7aea; }
        .game-output .spiritual-root { color: #f472b6; font-weight: bold; } 
        .game-output .class-info { color: #a78bfa; } 
        .game-output .qi-recovery { color: #60a5fa; } 
        .game-output .demonic { color: #7f1d1d; } 
        .game-output .loot { color: #facc15; } 
        .game-output .item-use { color: #34d399; } 
        .game-output .market { color: #fbbf24; } 
        .game-output .crafting { color: #a3e635; } 
        
        /* Combat & Action Text Styling */
        .combat-text-player-turn { color: #f6e05e; font-weight: bold; } 
        .combat-text-opponent-turn { color: #fca5a5; font-weight: bold; } 
        .combat-text-player-action { color: #68d391; } 
        .combat-text-opponent-action { color: #fc8181; } 
        .combat-text-narration { color: #a0aec0; font-style: italic;} 

        /* Updated Action Button Styling */
        .action-button {
            background-image: url('assets/UI/button.png');
            background-size: 100% 100%; /* Stretch to fit */
            background-color: transparent; /* Ensure no solid color interferes */
            border: none; /* Remove default or Tailwind borders */
            color: #E8D8B0; /* Light yellowish beige text */
            font-family: 'Noto Serif SC', serif; /* Thematic serif font */
            font-size: 1.1em; /* Adjusted font size */
            font-weight: 600; /* Slightly less bold for better readability with shadow */
            text-align: center;
            cursor: pointer;
            text-shadow: 0 0 4px #f0e68c, 1px 1px 1px rgba(0, 0, 0, 0.7); /* Khaki glow + subtle dark shadow for depth */
            transition: all 0.2s ease-in-out; /* Updated transition for all properties */
            
            height: 52px; /* Slightly increased height for better padding feel */
            min-width: 150px; /* Ensure buttons have a decent minimum width */
            padding-left: 25px;  /* Horizontal padding for text inside the button image */
            padding-right: 25px; /* Adjust these based on the button.png's internal clear space */

            white-space: nowrap; /* Prevent text wrapping */
            display: inline-flex; /* For better content centering */
            align-items: center;    /* Vertically center text/content */
            justify-content: center; /* Horizontally center text/content */
            box-sizing: border-box;  /* Consistent box model */
        }
        .action-button:hover:not(:disabled) {
            /* filter: brightness(1.15); */ /* Replaced by box-shadow and scale */
            transform: scale(1.05); 
            box-shadow: 0 0 12px rgba(255, 255, 200, 0.5); /* Light yellow glow */
        }
        .action-button:active:not(:disabled) {
            filter: brightness(0.9); /* Slightly darker when pressed */
            transform: scale(0.98); /* Pressed down effect */
        }
        .action-button:disabled {
            filter: grayscale(70%) brightness(0.6); /* Muted, darker, and desaturated */
            cursor: not-allowed;
            /* opacity: 0.7; */ /* Filter is usually enough */
        }
        .stat-value { min-width: 60px; display: inline-block; text-align: right; }

        /* Combat Interface Styling */
        #combat-interface { display: none; border: 1px solid #4a5568; border-radius: 0.5rem; padding: 1rem; margin-bottom:1rem; background-color: #2d3748; }
        .combatant-info { margin-bottom: 0.75rem; text-align: center; }
        .combatant-name { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.25rem; margin-top: 0.5rem; }
        .health-bar-container { width: 100%; background-color: #4a5568; border-radius: 0.25rem; height: 24px; position: relative; border: 1px solid #718096; overflow: hidden; margin-top: 0.25rem; }
        .health-bar-fill { height: 100%; border-radius: 0.25rem; transition: width 0.3s ease-out; }
        .health-bar-player .health-bar-fill { background-color: #48bb78; }
        .health-bar-opponent .health-bar-fill { background-color: #f56565; }
        .health-bar-text { position: absolute; width: 100%; text-align: center; line-height: 24px; font-weight: bold; color: #e2e8f0; text-shadow: 1px 1px #1a202c; }
        #combat-action-text { min-height: 50px; text-align: center; }
        #combat-action-text p { margin-bottom: 0.25rem; line-height: 1.5; }
        #combat-specific-actions { }

        /* Pixel Art Sprite Styling */
        .pixel-art-sprite {
            width: 64px; height: 64px; border: 2px solid #a0aec0; margin: 0 auto 0.5rem auto; 
            image-rendering: pixelated; display: grid; grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr); box-shadow: 2px 2px 0px #1a202c; 
        }
        .player-sprite { background-color: #4299e1; }
        .player-sprite div { background-color: #63b3ed; } 
        .monster-sprite { background-color: #c53030; }
        .monster-sprite div { background-color: #e53e3e; } 

        /* Class Selection Styling */
        #class-selection-info { margin-top: 0.5rem; padding: 0.5rem; background-color: #2d3748; border-radius: 0.25rem; min-height: 80px;}
        #class-selection-info h3 { font-size: 1.1em; color: #f6e05e; margin-bottom: 0.25rem;}
        #class-selection-info p { font-size: 0.9em; color: #cbd5e0; margin-bottom: 0.25rem;}

        /* Generic Menu/Panel Styling */
        #market-menu, #market-listings-view, #concoction-menu, #attribute-allocation-menu, #sect-creation-panel { 
            margin-top: 1rem; padding: 1rem; background-color: #2d3748; border-radius: 0.5rem; border: 1px solid #4a5568;
        }
        #market-menu h3, #market-listings-view h3, #concoction-menu h3, #attribute-allocation-menu h3, #sect-creation-panel h3 { font-size: 1.25em; color: #f6e05e; margin-bottom: 0.75rem; text-align: center;}
        .market-item-button, .concoction-recipe-button { display: block; width: 100%; text-align: left; }
        .market-listing-item { border-bottom: 1px solid #4a5568; padding: 0.75rem 0.5rem; margin-bottom: 0.5rem; }
        /* Player Search Specific Styling */
        #player-search-view { margin-top: 1rem; padding: 1rem; background-color: #2d3748; border-radius: 0.5rem; border: 1px solid #4a5568;}
        #player-search-view h3 { font-size: 1.25em; color: #f6e05e; margin-bottom: 0.75rem; text-align: center;}
        .player-search-result-item { border-bottom: 1px solid #4a5568; padding: 0.75rem 0.5rem; margin-bottom: 0.5rem; }
        .player-search-result-item:last-child { border-bottom: none; }
        .market-listing-item:last-child { border-bottom: none; }
        .concoction-recipe-item { border: 1px solid #4a5568; padding: 0.75rem; margin-bottom: 0.75rem; border-radius: 0.25rem; background-color: #374151; }
        .concoction-recipe-item h4 { font-size: 1.1em; color: #fde047; margin-bottom: 0.25rem; }
        .concoction-recipe-item p { font-size: 0.9em; color: #d1d5db; margin-bottom: 0.1rem; }
        .concoction-ingredient-list { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 0.25rem; }

        /* Chat Styling */
        #chat-log-container { /* Styles mostly applied via Tailwind classes */ }
        .chat-message {
            padding: 0.25rem 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 0.25rem;
            line-height: 1.4;
            word-wrap: break-word;
        }
        .chat-message .sender-name {
            font-weight: bold;
            color: #63b3ed; /* Example color for sender */
            margin-right: 0.25rem;
        }
        .chat-message .timestamp {
            font-size: 0.75rem;
            color: #a0aec0;
            margin-left: 0.5rem;
        }
        .chat-message .message-text {
            color: #e2e8f0;
        }
        .my-message { background-color: #374151; /* User's own messages */ }
        .other-message { background-color: #4b5563; /* Other users' messages */ }


        @media (max-width: 768px) {
            .main-content-area { flex-direction: column; }
            .stats-panel { order: -1; width: 100%; margin-bottom: 1rem; border-right: none; border-bottom: 1px solid #4a5568; padding-bottom: 1rem; }
            .game-output-container { width: 100%; padding-left: 0; }
            .action-buttons-container { justify-content: center; flex-wrap: wrap; }
            #combat-specific-actions { justify-content: center; flex-wrap: wrap; } 
            .action-button { margin: 0.25rem; }
        }
        /* Modal styles (generic and input modal) */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
        .modal-content { background-color: #2d3748; margin: 5% auto; padding: 20px; border: 1px solid #4a5568; width: 80%; max-width: 500px; border-radius: 8px; text-align: center; }
        .modal-input { background-color: #4a5568; color: #e2e8f0; border: 1px solid #718096; padding: 10px; margin-top: 10px; margin-bottom: 15px; width: calc(100% - 22px); border-radius: 4px; }
   
        /* Inventory Grid Styling (reused for modal) */
        /* Container for the grid of slots in the modal */
        #modal-inventory-grid-container {
            display: grid; /* Using grid for defined columns */
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); /* Responsive columns */
            gap: 12px; /* Increased spacing for name below */
            padding: 8px; /* Padding inside the container */
            max-height: 400px; /* Limit height and enable scroll */
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #2d3748; /* Dark background for the grid area */
            border: 1px solid #4a5568; /* Subtle border */
            border-radius: 0.25rem; /* Rounded corners */
        }

        .inventory-slot {
            width: 60px; 
            height: 60px;
            /* background-image removed from here, will be on .inventory-slot-frame */
            height: auto; /* Allow height to adjust for name below frame */
            display: flex;
            flex-direction: column; /* Stack frame and name vertically */
            align-items: center;
            /* justify-content: center; Removed to allow name to sit naturally below */
            position: relative;
            cursor: default;
            /* border-radius & overflow removed */
            image-rendering: pixelated; 
        }

        /* New div for the visual slot frame */
        .inventory-slot-frame {
            width: 60px; 
            height: 60px;
            background-image: url('emptyinventoryslot.png'); /* Your new slot image */
            background-size: 100% 100%; 
            background-repeat: no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* For positioning quantity inside */
        }

        .inventory-slot.has-item {
            cursor: pointer;
        }
        .inventory-slot.has-item .inventory-slot-frame:hover { /* Apply hover to the frame */
            outline: 2px solid #f6e05e; 
            z-index: 10; 
        }

        .inventory-slot-icon {
            width: 40px; /* Increased icon size */
            height: 40px;
            /* margin-bottom removed */
            background-size: contain; 
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em; /* Adjusted for new icon size */
            color: #a0aec0; /* Lighter fallback text for dark slot interior */
            text-shadow: 1px 1px #1a202c;
        }

        .inventory-slot-name {
            font-size: 0.65em; 
            color: #cbd5e0;   /* Light text for dark background */
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 90%; 
            line-height: 1;
            padding: 0 1px;
            font-weight: 500;
            margin-top: 4px; /* Space between frame and name */
        }

        .inventory-slot-quantity {
            position: absolute;
            bottom: 3px; /* Adjusted for new frame */
            right: 3px;  /* Adjusted for new frame */
            background-color: rgba(26, 32, 44, 0.85); 
            color: #f6e05e; 
            padding: 1px 4px; 
            border-radius: 3px;
            font-size: 0.6em; 
            font-weight: bold;
            line-height: 1.2; 
        }

        /* Inventory Modal Specific Styles */
        #grid-inventory-modal {
            z-index: 200; /* Ensure it's above other modals like inputModal */
        }
        #grid-inventory-modal-content {
            background-color: #2d3748; /* Dark background, matches Tailwind bg-gray-800 */
       }

        /* New RPG Panel Styling */
        .rpg-ui-panel {
            background-color: rgba(30, 41, 59, 0.85); /* Slightly transparent bg-gray-800/900 equivalent */
            border: 2px solid #4a5568; /* Prominent border */
            border-radius: 10px;
            padding: 1rem;
            box-shadow: 0 0 0 1px rgba(150, 160, 180, 0.15), /* Subtle outer highlight */
                        inset 0 0 10px rgba(0,0,0,0.45), /* Inner shadow for depth */
                        0 5px 18px rgba(0,0,0,0.35); /* Outer drop shadow */
            backdrop-filter: blur(3px); /* Optional: if body has a more complex image background */
        }

        /* Dedicated Exploration View Styling */
        .dedicated-exploration-background {
            /* Styles for background image will be applied dynamically via JS */ /* This comment is fine */
        }
        
        /* Cultivator Profile Card Styling */
        #stats-panel-aside.rpg-ui-panel {
            background-image: url('assets/UI/profile.png'); /* Apply the new background image */
            background-size: cover; /* This will crop sides of the 800x600 image on a tall panel */
            background-position: center; 
            background-repeat: no-repeat;
            padding: 3.75rem 2.25rem; /* Increased padding: 3.75rem (60px) top/bottom, 2.25rem (36px) left/right */
        }
        #stats-panel-aside.rpg-ui-panel h2 {
            font-family: 'Noto Serif SC', serif;
            color: #facc15; /* Brighter yellow for titles */
            border-bottom: 1px solid #525c6f; 
            padding-bottom: 0.6rem;
            margin-bottom: 1.25rem; /* Increased margin slightly */
            font-size: 1.6em; /* Increased font size to match attribute panel title */
            text-align: center; /* Center the title */
            margin-top: 0; /* Ensure no extra margin pushes it down from the panel's padding */
        }

        /* Styling for individual stat rows within the Cultivator Profile */
        #player-stats > div {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.4rem; /* Vertical and horizontal padding */
            margin-bottom: 0.6rem; /* Space between stat rows */
            background-color: transparent; /* Remove individual row background */
            border: none; /* Remove individual row border */
            border-bottom: 1px dashed rgba(150, 160, 180, 0.2); /* Subtle separator */
            min-height: 30px; /* Ensure consistent height, slightly less prominent */
        }
        #player-stats > div strong { /* Stat label, e.g., "Name:" */
            color: #d1d5db; /* Tailwind gray-300 */
            margin-right: 0.75rem; /* Space between label and value */
        }
        /* Value spans (e.g., #stat-name) already have Tailwind colors and .stat-value for alignment */
        
        .game-output-container.rpg-ui-panel #game-output {
            background-color: rgba(26, 32, 44, 0.75); /* Darker, slightly transparent log area */
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 1rem; /* Space before action buttons */
        }
        
        /* Main Menu Action Buttons Container */
        #action-buttons-container {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: center; /* Center buttons horizontally */
            gap: 0.75rem; /* Space between vertical buttons */
            margin-top: 1rem; /* Space between game-output and this button container */
        }

        /* Exploration Area Cards Styling */
        #action-buttons-container.exploration-mode {
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Wider cards */
            gap: 1.5rem; /* Increased gap */
            padding-top: 1rem; /* Add some padding at the top */
        }

        .exploration-card {
            position: relative;
            min-height: 380px; /* Adjusted height */
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            color: #fff; 
        }

        .exploration-card:hover:not(.locked-true) { /* Only apply hover effect to unlocked cards */
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }

        .exploration-card-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 35%, rgba(0,0,0,0.15) 100%);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        .exploration-card-header {
            margin-bottom: auto; /* Pushes header to top */
        }

        .exploration-card-name {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.6em; 
            font-weight: 700;
            color: #fde047; /* Brighter yellow for title */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            margin: 0 0 0.25rem 0;
        }

        .exploration-card-status {
            font-size: 0.8em;
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            text-transform: uppercase;
            display: inline-block; /* To sit nicely below the name */
        }
        .exploration-card-status.unlocked { background-color: rgba(104, 211, 145, 0.85); color: #1a202c; }
        .exploration-card-status.locked { background-color: rgba(252, 129, 129, 0.85); color: #1a202c; }

        .exploration-card-details { margin-bottom: 0.75rem; }
        .exploration-card-req { font-size: 0.95em; color: #e2e8f0; margin-bottom: 0.35rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.6); }
        .exploration-card-desc { font-size: 0.8em; color: #cbd5e0; font-style: italic; line-height: 1.3; max-height: 3.9em; overflow: hidden; text-overflow: ellipsis; }

        .exploration-card-button.action-button {
            width: 100%; padding: 0.75rem 1rem; font-size: 1.1em; font-family: 'Noto Serif SC', serif;
            font-weight: 600; border-radius: 6px; min-height: auto; margin-top: 0.75rem;
        }
        .exploration-card.locked-true { filter: grayscale(85%) brightness(0.6); }
        .exploration-card.locked-true .exploration-card-button { background-color: #4a5568 !important; border-color: #718096 !important; color: #a0aec0 !important; cursor: not-allowed; }
        .exploration-card-lock-icon { position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); font-size: 4.5em; color: rgba(255,255,255,0.25); pointer-events: none; display: none; }
        .exploration-card.locked-true .exploration-card-lock-icon { display: block; }
        .exploration-card-lock-icon svg { width: 1em; height: 1em; fill: currentColor; }

        /* Card-like styling for action buttons in the main menu */
        #action-buttons-container .action-button {
            /* These buttons have their own distinct card-like style, not using the button.png */
            background-color: rgba(55, 65, 81, 0.92); 
            border: 2px solid #6b7280; 
            color: #f0e2c6; /* Parchment-like text, from index.html */
            font-family: 'Noto Serif SC', serif; /* Thematic font */
            font-size: 1.05em; /* Adjusted font size */
            font-weight: 600;
            padding: 1rem 0.75rem; /* Vertical and horizontal padding */
            min-height: 90px; /* Minimum height for the cards */
            border-radius: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.08);
            transition: all 0.2s ease-out;
            width: auto; /* Allow button to size to its content + padding */
            min-width: 220px; /* Ensure a decent minimum width for vertical buttons */
            max-width: 350px; /* Prevent buttons from becoming too wide */
        }

        #action-buttons-container .action-button:hover:not(:disabled) {
            background-color: rgba(75, 85, 99, 0.95); /* Darker on hover */
            border-color: #9ca3af; /* Lighter border on hover */
            transform: translateY(-3px) scale(1.03); /* Lift and slightly enlarge */
            box-shadow: 0 7px 15px rgba(0,0,0,0.35), inset 0 1px 1px rgba(255,255,255,0.1);
            color: #fff; /* Brighter text on hover */
        }

        /* Attribute Allocation Panel Styling */
        #attribute-allocation-menu.rpg-ui-panel {
            padding: 1.5rem;
        }
        #attribute-allocation-menu h3 {
            font-family: 'Noto Serif SC', serif;
            color: #facc15; /* Brighter yellow for titles */
            text-align: center;
            font-size: 1.6em;
            margin-bottom: 1rem;
            border-bottom: 1px solid #525c6f;
            padding-bottom: 0.8rem;
        }
        #attribute-allocation-menu #available-points-display {
            font-size: 1.1em;
            color: #fde047; /* Tailwind yellow-400 */
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .attribute-allocation-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0.5rem;
            background-color: rgba(55, 65, 81, 0.7); /* bg-gray-700 with transparency */
            border-radius: 6px;
            margin-bottom: 0.75rem;
            border: 1px solid #4b5563; /* border-gray-600 */
        }
        .attribute-allocation-row .attr-name {
            font-weight: 500;
            color: #e5e7eb; /* Tailwind gray-200 */
        }
        .attribute-allocation-row .attr-controls button {
            background-color: #4a5568; /* bg-gray-600 */
            color: #e2e8f0;
            border: 1px solid #6b7280; /* border-gray-500 */
            width: 30px; height: 30px; line-height: 28px; text-align: center;
            border-radius: 50%; font-size: 1.2em; margin: 0 0.3rem;
        }
        .attribute-allocation-row .attr-controls button:hover:not(:disabled) { background-color: #6b7280; }
        .attribute-allocation-row .attr-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
        .attribute-allocation-row .attr-value { font-weight: bold; color: #facc15; min-width: 25px; text-align: center; }
        #attribute-allocation-actions { margin-top: 1.5rem; display: flex; justify-content: center; gap: 1rem; }

        /* Sect Creation Panel Styling */
        #sect-creation-panel .form-input, #sect-creation-panel .form-select {
            background-color: #4a5568; color: #e2e8f0; border: 1px solid #718096; 
            padding: 0.5rem; margin-bottom: 0.75rem; width: 100%; border-radius: 4px;
        }
        /* Sect Dashboard Styling */
        #sect-dashboard-panel { /* Uses .rpg-ui-panel, flex added inline */ }
        #sect-dashboard-sidebar { /* Tailwind classes used: w-1/4 border-r border-gray-600 p-3 */ }
        #sect-dashboard-header h3 { /* Tailwind classes used */ }
        #sect-dashboard-header p { /* Tailwind classes used */ }

        .sect-tab-button {
            display: block; width: 100%; padding: 0.75rem 1rem; text-align: left;
            font-family: 'Noto Serif SC', serif; font-size: 1em; color: #cbd5e0; /* gray-300 */
            background-color: rgba(55, 65, 81, 0.5); border: 1px solid #4b5563; /* border-gray-600 */
            border-radius: 6px; transition: all 0.2s ease-in-out;
        }
        .sect-tab-button:hover:not(.active) { background-color: rgba(75, 85, 99, 0.7); color: #fff; }
        .sect-tab-button.active {
            background-color: #facc15; /* yellow-400 */ color: #1a202c; /* gray-900 */
            font-weight: bold; border-color: #facc15;
        }

        #sect-dashboard-main-content h4 { /* For tab content titles */
            font-family: 'Noto Serif SC', serif; color: #fde047; /* yellow-300 */
            font-size: 1.3em; margin-bottom: 1rem; padding-bottom: 0.5rem;
            border-bottom: 1px solid #4a5568; /* border-gray-600 */
        }
        #sect-creation-panel label { display: block; margin-bottom: 0.25rem; color: #cbd5e0; font-size: 0.9em;}
        #sect-creation-panel-actions { margin-top: 1.5rem; display: flex; justify-content: center; gap: 1rem; }

        /* Hamburger Menu & Side Navigation */
        #hamburger-icon {
            position: fixed;
            top: 1rem; right: 1rem;
            z-index: 1050; /* Above most things, below modals */
            background-color: rgba(30, 41, 59, 0.8);
            border: 1px solid #4a5568;
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
        }
        #hamburger-icon span { display: block; width: 20px; height: 2px; background-color: #e2e8f0; margin: 4px 0; transition: all 0.3s ease; }
        #hamburger-icon.active span:nth-child(1) { transform: translateY(6px) rotate(45deg); }
        #hamburger-icon.active span:nth-child(2) { opacity: 0; }
        #hamburger-icon.active span:nth-child(3) { transform: translateY(-6px) rotate(-45deg); }

        #side-menu {
            position: fixed;
            top: 0; right: 0;
            width: 280px; height: 100%;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1040; /* Below hamburger icon, above general content */
            padding-top: 4rem; /* Space for header/icon */
        }
        #side-menu.active { transform: translateX(0); }
        #side-menu ul { list-style: none; padding: 0; margin: 0; }
        #side-menu ul li a {
            display: block;
            padding: 1rem 1.5rem;
            color: #e2e8f0;
            text-decoration: none;
            font-size: 1.1em;
            border-bottom: 1px solid #374151; /* Separator */
            transition: background-color 0.2s ease;
        }
        #side-menu ul li a:hover { background-color: #374151; }
        #side-menu ul li:last-child a { border-bottom: none; }

        /* View Mode Styling */
        body.view-mode-gameplay #stats-panel-aside { display: none !important; }
        body.view-mode-gameplay .game-output-container { display: flex !important; width: 100% !important; } /* Ensure it's flex for its children */

        /* Auth Form Styling */
        .auth-form-panel {
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px; 
            padding: 2rem;
            text-align: center;
            z-index: 1000; 
        }
        .auth-form-panel h3 {
            font-family: 'Noto Serif SC', serif;
            color: #facc15; 
            font-size: 1.8em;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #525c6f;
            padding-bottom: 0.8rem;
        }
        .auth-form-panel div:not(.auth-form-actions):not(.auth-error-message) { 
            margin-bottom: 1rem;
            text-align: left; 
        }
        .auth-label {
            display: block;
            color: #cbd5e0; 
            margin-bottom: 0.3rem;
            font-size: 0.9em;
        }
        .auth-input {
            background-color: #4a5568; 
            color: #e2e8f0;
            border: 1px solid #718096; 
            padding: 0.6rem 0.8rem;
            width: 100%;
            border-radius: 6px;
            box-sizing: border-box; 
            font-size: 1em;
        }
        .auth-input:focus {
            outline: none;
            border-color: #facc15; 
            box-shadow: 0 0 0 2px rgba(250, 204, 21, 0.3);
        }
        .auth-form-actions {
            margin-top: 1.5rem;
            display: flex;
            flex-direction: column; 
            gap: 0.75rem;
        }
        .auth-form-actions .action-button {
            width: 100%; 
        }
        .auth-error-message {
            color: #fc8181; 
            background-color: rgba(252, 129, 129, 0.1);
            border: 1px solid rgba(252, 129, 129, 0.3);
            padding: 0.75rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            font-size: 0.9em;
            text-align: left;
            display: none; 
        }

        body.view-mode-gameplay .main-content-area { column-gap: 0 !important; }

        body.view-mode-profile #stats-panel-aside { display: block !important; width: 100% !important; } /* Make stats panel full width */
        body.view-mode-profile .game-output-container { display: none !important; } /* Hide game output container */
        body.view-mode-profile .main-content-area { column-gap: 0 !important; } /* No gap needed if only one item is shown */

        /* Unequip Button Styling */
        .unequip-button {
            margin-left: 8px;
            padding: 2px 6px;
            font-size: 0.8em;
            color: #fca5a5; /* Tailwind red-300 */
            background-color: #4b5563; /* Tailwind gray-600 */
            border: 1px solid #718096; /* Tailwind gray-500 */
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .unequip-button:hover {
            background-color: #718096; /* Tailwind gray-500 */
            color: #ffffff;
        }
        .chat-and-input-area { display: none; } /* Hidden by default */
        body.chat-visible .chat-and-input-area { display: flex !important; }

    </style>
</head>
<body class="bg-gray-900 text-gray-300">
    <button id="hamburger-icon"><span></span><span></span><span></span></button>
    <div id="side-menu" class="rpg-ui-panel">
        <ul>
            <li><a href="#" id="menu-nav-home">Home (Gameplay)</a></li>
            <li><a href="#" id="menu-nav-profile">Player Profile</a></li>
            <li><a href="#" id="menu-nav-players">Players</a></li>
            <li><a href="#" id="menu-nav-chat">Toggle Chat</a></li>
            <li><a href="#" id="menu-nav-logout">Logout</a></li>
        </ul>
    </div>

    <!-- Create Account Form -->
    <div id="create-account-form-container" class="auth-form-panel rpg-ui-panel" style="display: none;">
        <h3>Create Cultivator</h3>
        <div id="create-form-error-message" class="auth-error-message"></div>
        <div>
            <label for="create-username" class="auth-label">Username:</label>
            <input type="text" id="create-username" class="auth-input">
        </div>
        <div>
            <label for="create-password" class="auth-label">Password:</label>
            <input type="password" id="create-password" class="auth-input">
        </div>
        <div>
            <label for="create-email" class="auth-label">Email (Optional):</label>
            <input type="email" id="create-email" class="auth-input" placeholder="your.email@example.com">
        </div>
        <div class="auth-form-actions">
            <button id="submit-create-account" class="action-button">Create Account</button>
            <button id="cancel-create-account" class="action-button">Back to Gate</button>
        </div>
    </div>

    <!-- Login Form -->
    <div id="login-form-container" class="auth-form-panel rpg-ui-panel" style="display: none;">
        <h3>Login</h3>
        <div id="login-form-error-message" class="auth-error-message"></div>
        <div>
            <label for="login-username" class="auth-label">Username:</label>
            <input type="text" id="login-username" class="auth-input">
        </div>
        <div>
            <label for="login-password" class="auth-label">Password:</label>
            <input type="password" id="login-password" class="auth-input">
        </div>
        <div class="auth-form-actions">
            <button id="submit-login" class="action-button">Login</button>
            <button id="cancel-login" class="action-button">Back to Gate</button>
        </div>
    </div>
    <div class="game-container p-4 md:p-6">
        <header class="mb-4 md:mb-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-yellow-400" style="font-family: 'Noto Serif SC', serif;">Path of the Ascendant Dragon</h1>
            <p class="text-sm text-gray-500">A Wuxia Cultivation RPG</p>
        </header>

        <main class="main-content-area flex flex-grow min-h-0 md:space-x-4">
            <aside id="stats-panel-aside" class="stats-panel w-full md:w-1/4 bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700 h-full overflow-y-auto rpg-ui-panel" style="display: none;">
                <h2 class="text-xl font-semibold mb-3 text-yellow-300 border-b border-gray-700 pb-2">Cultivator Profile</h2>
                <div id="player-stats">
                    <div><strong>Name:</strong> <span id="stat-name" class="text-blue-300">Nameless One</span></div>
                    <div><strong>Class:</strong> <span id="stat-class" class="text-teal-300">Undetermined</span></div>
                    <div><strong>Realm:</strong> <span id="stat-realm" class="text-purple-300">Mortal</span></div>
                    <div><strong>Level:</strong> <span id="stat-level" class="text-green-300 stat-value">0</span></div>
                    <div><strong>Spiritual Root:</strong> <span id="stat-spiritual-root" class="text-pink-400">Undetermined</span></div>
                    <div><strong>Progress:</strong> <span id="stat-progress" class="text-green-400 stat-value">0/100</span> XP</div>
                    <div><strong>Health:</strong> <span id="stat-health" class="text-red-400 stat-value">100/100</span></div>
                    <div><strong>Qi:</strong> <span id="stat-qi" class="text-blue-400 stat-value">50/50</span></div>
                    <div><strong>Strength (STR):</strong> <span id="stat-strength" class="text-orange-300 stat-value">0</span></div>
                    <div><strong>Agility (AGI):</strong> <span id="stat-agility" class="text-cyan-300 stat-value">0</span></div>
                    <div><strong>Constitution (CON):</strong> <span id="stat-constitution" class="text-lime-300 stat-value">0</span></div>
                    <div><strong>Spirit (SPR):</strong> <span id="stat-spirit" class="text-fuchsia-300 stat-value">0</span></div>
                    <div><strong>Intellect (INT):</strong> <span id="stat-intellect" class="text-amber-300 stat-value">0</span></div>
                    <div><strong>Willpower (WIL):</strong> <span id="stat-willpower" class="text-violet-300 stat-value">0</span></div>
                    <div><strong>Spirit Stones:</strong> <span id="stat-spirit-stones" class="text-yellow-400 stat-value">0</span></div>
                    <div class="mt-3 pt-2 border-t border-gray-700"><strong>Phys. Attack:</strong> <span id="stat-phys-attack" class="text-orange-400 stat-value">0</span></div>
                    <div><strong>Phys. Defense:</strong> <span id="stat-phys-defense" class="text-teal-400 stat-value">0</span></div>
                    <div id="stat-demonic-corruption-container" style="display: none;">
                        <strong>Demonic Corruption:</strong> <span id="stat-demonic-corruption" class="text-red-700 stat-value">0</span>
                    </div>
                    <div><strong>Sect:</strong> <span id="stat-sect" class="text-indigo-300">None</span></div>
                    <div><strong>Weapon:</strong> <span id="stat-weapon" class="text-gray-400">Unarmed</span></div>

                    <!-- Equipment Slots -->
                    <h3 class="text-lg font-semibold text-yellow-400 mt-4 mb-2 border-b border-gray-700 pb-1">Equipment</h3>
                    <div id="equipment-slots" class="space-y-1 text-sm">
                        <div><strong>Weapon Slot:</strong> <span id="equipped-weapon" class="stat-value text-gray-400">Empty</span></div>
                        <div><strong>Armor:</strong> <span id="equipped-armor" class="stat-value text-gray-400">Empty</span></div>
                        <div><strong>Helmet:</strong> <span id="equipped-helmet" class="stat-value text-gray-400">Empty</span></div>
                        <div><strong>Boots:</strong> <span id="equipped-boots" class="stat-value text-gray-400">Empty</span></div>
                        <div><strong>Ring:</strong> <span id="equipped-ring" class="stat-value text-gray-400">Empty</span></div>
                    </div>
                </div>
                <!-- Old inventory section removed from here -->
            </aside>

            <section class="game-output-container w-full md:w-3/4 flex flex-col bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700 rpg-ui-panel">
                <div id="combat-interface">
                    <div class="combatant-info" id="combat-player-ui">
                        <div id="combat-player-sprite" class="pixel-art-sprite player-sprite">
                            <div style="grid-column: 4 / span 2; grid-row: 2;"></div> <div style="grid-column: 3 / span 4; grid-row: 3;"></div>
                            <div style="grid-column: 4 / span 2; grid-row: 4;"></div> <div style="grid-column: 3 / span 1; grid-row: 5;"></div>
                            <div style="grid-column: 6 / span 1; grid-row: 5;"></div> <div style="grid-column: 2 / span 1; grid-row: 6;"></div>
                            <div style="grid-column: 7 / span 1; grid-row: 6;"></div>
                        </div>
                        <div id="combat-player-name" class="combatant-name text-blue-300">Player</div>
                        <div class="health-bar-container health-bar-player">
                            <div id="combat-player-hb-fill" class="health-bar-fill"></div>
                            <span id="combat-player-hp-text" class="health-bar-text">100/100 HP</span>
                        </div>
                    </div>
                    <div class="combatant-info" id="combat-opponent-ui">
                        <div id="combat-opponent-sprite" class="pixel-art-sprite monster-sprite">
                             <div style="grid-column: 3 / span 4; grid-row: 2;"></div> <div style="grid-column: 2 / span 1; grid-row: 3;"></div>
                             <div style="grid-column: 7 / span 1; grid-row: 3;"></div> <div style="grid-column: 3 / span 1; grid-row: 4; background-color: #fbd38d;"></div> 
                             <div style="grid-column: 6 / span 1; grid-row: 4; background-color: #fbd38d;"></div> <div style="grid-column: 4 / span 2; grid-row: 6;"></div>
                        </div>
                        <div id="combat-opponent-name" class="combatant-name text-red-300">Opponent</div>
                        <div class="health-bar-container health-bar-opponent">
                            <div id="combat-opponent-hb-fill" class="health-bar-fill"></div>
                            <span id="combat-opponent-hp-text" class="health-bar-text">100/100 HP</span>
                        </div>
                    </div>
                    <div id="combat-action-text" class="mt-4 text-sm"></div>
                    <div id="combat-specific-actions" class="flex flex-wrap gap-2 justify-center mt-4"></div>
                </div>
                
                <div id="class-selection-info" class="mb-4" style="display: none;"></div>
                <!-- inventory-menu div below is for old text-based inventory, can be removed or repurposed if not needed -->
                <div id="inventory-menu" class="mb-4" style="display:none;"><h3>Old Inventory Menu (if used)</h3></div> 
                <div id="market-menu" class="mb-4" style="display:none;"></div>
                <div id="market-listings-view" class="mb-4" style="display:none;"></div>
                <div id="concoction-menu" class="mb-4" style="display:none;"></div>
                <div id="attribute-allocation-menu" class="mb-4" style="display:none;"></div>
                <div id="player-search-view" class="mb-4" style="display:none;"></div>
                <div id="sect-creation-panel" class="mb-4" style="display:none;"></div>

                <div id="sect-dashboard-panel" class="rpg-ui-panel flex" style="display:none; min-height: 450px;">
                    <div id="sect-dashboard-sidebar" class="w-1/4 border-r border-gray-600 p-3 flex flex-col">
                        <div id="sect-dashboard-header" class="text-center mb-4">
                            <h3 id="sect-dashboard-name" class="text-xl font-bold text-yellow-400" style="font-family: 'Noto Serif SC', serif;">Sect Name</h3>
                            <p id="sect-dashboard-motto" class="text-xs text-gray-400 italic">Sect Motto</p>
                        </div>
                        <div id="sect-dashboard-tabs" class="flex flex-col space-y-2 flex-grow">
                            <!-- Tab buttons will be generated here by JS -->
                        </div>
                        <button id="sect-dashboard-back-button" class="action-button bg-gray-600 hover:bg-gray-700 w-full mt-6">Back to Menu</button>
                    </div>
                    <div id="sect-dashboard-main-content" class="w-3/4 p-4 overflow-y-auto">
                        <!-- Content for the active tab will be loaded here -->
                    </div>
                </div>


                <h2 class="text-xl font-semibold mb-3 text-yellow-300 sr-only">Game Log</h2>
                <div id="game-output" class="game-output flex-grow overflow-y-auto mb-4 pr-2"></div>
                <div id="action-buttons-container" class="action-buttons-container"></div>

                <!-- Chat and Input Area MOVED HERE -->
                <div class="chat-and-input-area mt-4 rpg-ui-panel" style="display: none;"> <!-- Added mt-4 for spacing, removed original footer Tailwind margins -->
                    <div id="chat-log-container" class="w-full h-40 bg-transparent p-2 overflow-y-auto mb-0">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div class="input-area p-2 bg-transparent border-t border-gray-600 flex items-center gap-2" style="min-height: 58px;">
                        <input type="text" id="chat-input" class="flex-grow bg-gray-700 text-gray-300 border border-gray-600 rounded-md p-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Login to chat..." disabled>
                        <button id="chat-send-button" class="action-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md" disabled>Send</button>
                    </div>
                </div>
            </section>
        </main>

    </div>

    <!-- Input Modal (for generic input) -->
    <div id="inputModal" class="modal">
        <div class="modal-content">
            <p id="modalPrompt" class="text-lg mb-3"></p>
            <input type="text" id="modalInputField" class="modal-input">
            <input type="password" id="modalPasswordInputField" class="modal-input" style="display:none;">
            <button id="modalSubmitButton" class="action-button bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md">Submit</button>
            <button id="modalCancelButton" class="action-button bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md ml-2">Cancel</button>
        </div>
    </div>

    <!-- Grid Inventory Modal -->
    <div id="grid-inventory-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4" style="display: none;">
        <div id="grid-inventory-modal-content" class="bg-gray-800 p-4 md:p-6 rounded-lg shadow-xl border border-gray-700 w-full max-w-lg md:max-w-2xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-yellow-300" style="font-family: 'Noto Serif SC', serif;">Inventory</h2>
                <button id="close-inventory-modal-button" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <div id="modal-inventory-grid-container">
                <!-- Slots will be dynamically generated here -->
            </div>
        </div>
    </div>

    <!-- Equipment Success Toast Notification -->
    <div id="equipment-toast" class="fixed top-5 left-1/2 transform -translate-x-1/2 bg-green-600 text-white p-4 rounded-lg shadow-xl text-center z-[1100]" style="display: none; min-width: 280px;">
        <p id="equipment-toast-message" class="font-semibold"></p>
    </div>


    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
    <script>
        // --- START: FRONTEND UI JAVASCRIPT ---
        const gameOutput = document.getElementById('game-output');
        const actionButtonsContainer = document.getElementById('action-buttons-container'); 
        const combatInterface = document.getElementById('combat-interface');
        const combatPlayerSprite = document.getElementById('combat-player-sprite');
        const combatPlayerName = document.getElementById('combat-player-name');
        const combatPlayerHbFill = document.getElementById('combat-player-hb-fill');
        const combatPlayerHpText = document.getElementById('combat-player-hp-text');
        const combatOpponentSprite = document.getElementById('combat-opponent-sprite');
        const combatOpponentName = document.getElementById('combat-opponent-name');
        const combatOpponentHbFill = document.getElementById('combat-opponent-hb-fill');
        const combatOpponentHpText = document.getElementById('combat-opponent-hp-text');
        const combatActionText = document.getElementById('combat-action-text');
        const defaultOpponentSpriteHTML = combatOpponentSprite.innerHTML; // Store initial HTML for fallback
        const combatSpecificActions = document.getElementById('combat-specific-actions'); 
        const classSelectionInfoDiv = document.getElementById('class-selection-info');
        const inventoryMenuDiv = document.getElementById('inventory-menu'); // Old menu, can be removed if not repurposed
        const marketMenuDiv = document.getElementById('market-menu');
        const marketListingsViewDiv = document.getElementById('market-listings-view');
        const concoctionMenuDiv = document.getElementById('concoction-menu');
        const playerSearchViewDiv = document.getElementById('player-search-view');
        const sectDashboardPanelDiv = document.getElementById('sect-dashboard-panel');
        const sectCreationPanelDiv = document.getElementById('sect-creation-panel');
        const statsPanelAside = document.getElementById('stats-panel-aside');
        const mainContentArea = document.querySelector('.main-content-area'); // For adjusting space-x
        const gameOutputContainer = document.querySelector('.game-output-container');

        // Hamburger Menu Elements
        const gameContainer = document.querySelector('.game-container'); // For background image
        const hamburgerIcon = document.getElementById('hamburger-icon');
        const sideMenu = document.getElementById('side-menu');
        const chatFooter = document.querySelector('.chat-and-input-area');

        // New Inventory Modal Elements
        const gridInventoryModal = document.getElementById('grid-inventory-modal');
        const modalInventoryGridContainer = document.getElementById('modal-inventory-grid-container');
        const closeInventoryModalButton = document.getElementById('close-inventory-modal-button');

        // Auth Form Elements
        const createAccountFormContainer = document.getElementById('create-account-form-container');
        const loginFormContainer = document.getElementById('login-form-container');
        const createUsernameInput = document.getElementById('create-username');
        const createPasswordInput = document.getElementById('create-password');
        const createEmailInput = document.getElementById('create-email'); // Changed from createCultivatorNameInput
        const loginUsernameInput = document.getElementById('login-username');
        const loginPasswordInput = document.getElementById('login-password');
        const createFormErrorMessage = document.getElementById('create-form-error-message');
        const loginFormErrorMessage = document.getElementById('login-form-error-message');

        const statName = document.getElementById('stat-name');
        const statClass = document.getElementById('stat-class'); 
        const statRealm = document.getElementById('stat-realm');
        const statLevel = document.getElementById('stat-level');
        const statSpiritualRoot = document.getElementById('stat-spiritual-root'); 
        const statProgress = document.getElementById('stat-progress');
        const statHealth = document.getElementById('stat-health');
        const statQi = document.getElementById('stat-qi'); 
        const statStrength = document.getElementById('stat-strength');
        const statAgility = document.getElementById('stat-agility');
        const statConstitution = document.getElementById('stat-constitution');
        const statSpirit = document.getElementById('stat-spirit');
        const statIntellect = document.getElementById('stat-intellect');
        const statWillpower = document.getElementById('stat-willpower');
        const statPhysAttack = document.getElementById('stat-phys-attack');
        const statPhysDefense = document.getElementById('stat-phys-defense');
        const statSpiritStones = document.getElementById('stat-spirit-stones');
        const statDemonicCorruptionContainer = document.getElementById('stat-demonic-corruption-container');
        const statDemonicCorruption = document.getElementById('stat-demonic-corruption');
        const statSect = document.getElementById('stat-sect');
        const statWeapon = document.getElementById('stat-weapon');

        const inputModal = document.getElementById('inputModal');
        const modalPrompt = document.getElementById('modalPrompt');
        const modalInputField = document.getElementById('modalInputField');
        const modalPasswordInputField = document.getElementById('modalPasswordInputField');
        const modalSubmitButton = document.getElementById('modalSubmitButton');
        const modalCancelButton = document.getElementById('modalCancelButton');
        const equipmentToast = document.getElementById('equipment-toast');
        const equipmentToastMessage = document.getElementById('equipment-toast-message');
        let equipmentToastTimeout = null;
        let modalResolve = null;

        // Chat UI Elements
        const chatLogContainer = document.getElementById('chat-log-container');
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');

        function safeSetTextContent(element, text) {
            if (element) {
                element.textContent = text !== null && text !== undefined ? String(text) : '';
            } else {
                // console.warn("safeSetTextContent: Element is null for text:", text); // Optional: for debugging
            }
        }

        const MAX_MESSAGES_IN_LOG = 15; 
        const MAX_CHAT_MESSAGES_DISPLAYED = 50;

        function showEquipmentToast(message) {
            if (!equipmentToast || !equipmentToastMessage) return;

            equipmentToastMessage.textContent = message;
            equipmentToast.style.display = 'block';
            equipmentToast.style.opacity = '1'; // Ensure it's visible

            // Clear any existing timeout to prevent multiple fades
            if (equipmentToastTimeout) {
                clearTimeout(equipmentToastTimeout);
            }

            equipmentToastTimeout = setTimeout(() => {
                equipmentToast.style.display = 'none';
            }, 3000); // Display for 3 seconds
        }

        function displayFormError(formType, message) {
            const errorDiv = formType === 'create' ? createFormErrorMessage : loginFormErrorMessage;
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }
        function clearFormError(formType) {
            const errorDiv = formType === 'create' ? createFormErrorMessage : loginFormErrorMessage;
            if (errorDiv) {
                errorDiv.textContent = '';
                errorDiv.style.display = 'none';
            }
        }

        function displayMessage(text, type = '') {
            try {
                const p = document.createElement('p');
                p.innerHTML = String(text).replace(/\n/g, "<br>"); 
                if (type) p.classList.add(type);
                if (gameOutput) {
                    gameOutput.appendChild(p);
                    while (gameOutput.children.length > MAX_MESSAGES_IN_LOG) {
                        gameOutput.removeChild(gameOutput.firstChild);
                    }
                    gameOutput.scrollTop = gameOutput.scrollHeight; 
                } else { console.error("gameOutput element not found for displayMessage:", text); }
            } catch (error) { console.error("Error in displayMessage:", error, "Original text:", text); }
        }

        function displayCombatAction(message, styleClass = '') {
            combatActionText.innerHTML = ''; 
            appendCombatAction(message, styleClass); 
        }

        function appendCombatAction(message, styleClass = '') {
            const p = document.createElement('p');
            p.innerHTML = String(message).replace(/\n/g, "<br>");
            if (styleClass) p.classList.add(styleClass);
            combatActionText.appendChild(p);
            combatActionText.scrollTop = combatActionText.scrollHeight;
        }

        function updateCombatUI(player, opponent) {
            if (!combatInterface || !player || !opponent) return;
            combatPlayerName.textContent = player.name;
            const playerHpPercent = Math.max(0, (player.health / player.maxHealth) * 100);
            combatPlayerHbFill.style.width = `${playerHpPercent}%`;
            combatPlayerHpText.textContent = `${player.health}/${player.maxHealth} HP`;
            combatPlayerSprite.className = 'pixel-art-sprite player-sprite'; 
            // TODO: Add player image logic here if player images are introduced

            combatOpponentName.textContent = opponent.name;
            const opponentHpPercent = Math.max(0, (opponent.health / opponent.maxHealth) * 100);
            combatOpponentHbFill.style.width = `${opponentHpPercent}%`;
            combatOpponentHpText.textContent = `${opponent.health}/${opponent.maxHealth} HP`;

            // Opponent Sprite Logic
            combatOpponentSprite.innerHTML = ''; // Clear previous content (grid or old image)
            if (opponent.image && opponent.image !== "null" && opponent.image !== "") {
                combatOpponentSprite.style.backgroundImage = `url('${opponent.image}')`;
                combatOpponentSprite.style.backgroundSize = 'contain'; // Use 'contain' to see the whole image
                combatOpponentSprite.style.backgroundRepeat = 'no-repeat';
                combatOpponentSprite.style.backgroundPosition = 'center';
                combatOpponentSprite.style.backgroundColor = 'transparent'; // Ensure no CSS bg color interferes
                combatOpponentSprite.classList.remove('monster-sprite'); 
            } else {
                // Fallback to default grid sprite
                combatOpponentSprite.style.backgroundImage = 'none'; // Explicitly remove image
                combatOpponentSprite.innerHTML = defaultOpponentSpriteHTML; // Restore grid
                combatOpponentSprite.classList.add('monster-sprite'); // Ensure default styling (bg color)
            }
        }

        function updateStatsDisplay(player) {
            if (!player) return;
            try {
                statName.textContent = player.name;
                statClass.textContent = player.chosenClassName || "Undetermined";
                statRealm.textContent = player.getCultivationRealmName(); 
                statLevel.textContent = player.cultivationLevel;
                statSpiritualRoot.textContent = player.spiritualRootName || "Undetermined"; 
                statProgress.textContent = `${player.cultivationProgress}/${player.getXPForNextLevel()} XP`; 
                statHealth.textContent = `${player.health}/${player.maxHealth}`;
                statQi.textContent = `${player.currentQi}/${player.maxQi}`; 
                statStrength.textContent = player.strength;
                statAgility.textContent = player.agility;
                statConstitution.textContent = player.constitution;
                statSpirit.textContent = player.spirit;
                statIntellect.textContent = player.intellect;
                statWillpower.textContent = player.willpower;
                statPhysAttack.textContent = player.getTotalAttack(); 
                statPhysDefense.textContent = player.getPhysicalDefense(); 
                statSpiritStones.textContent = player.resources.spiritStones !== undefined ? player.resources.spiritStones : 0;
                statSect.textContent = player.sectId && Game.sects[player.sectId] ? Game.sects[player.sectId].name : "None";
                // statWeapon.textContent = player.equippedWeapon ? Game.ITEM_DATA[player.equippedWeapon].name : "Unarmed"; // Old weapon display

                if (typeof Game.updateEquippedItemsUI === 'function') {
                    Game.updateEquippedItemsUI(player); // Call the new function to update all equipment slots
                }

                if (player.chosenClassKey === 'demon_cultivator' && player.demonicCorruption > 0) {
                    statDemonicCorruption.textContent = player.demonicCorruption;
                    statDemonicCorruptionContainer.style.display = 'block';
                } else {
                    statDemonicCorruptionContainer.style.display = 'none';
                }
                // Inventory grid is now in modal, not updated directly with stats
            } catch (error) { console.error("Error updating stats display:", error); displayMessage("Error updating player stats.", "error");}
        }

        function populateModalInventoryGrid(player) {
            if (!modalInventoryGridContainer) {
                console.error("Modal inventory grid container not found!");
                return;
            }
            modalInventoryGridContainer.innerHTML = ''; // Clear previous slots

            if (!player || !player.resources) {
                const emptySlot = document.createElement('div');
                emptySlot.classList.add('inventory-slot');
                const nameDiv = document.createElement('div');
                nameDiv.classList.add('inventory-slot-name');
                nameDiv.textContent = 'N/A';
                emptySlot.appendChild(nameDiv);
                modalInventoryGridContainer.appendChild(emptySlot);
                return;
            }

            const itemsToDisplay = [];
            const sortedItemKeys = Object.keys(player.resources).sort((a, b) => {
                const itemA = Game.ITEM_DATA[a];
                const itemB = Game.ITEM_DATA[b];
                if (!itemA || !itemB) return 0;
                return (itemA.name || a).localeCompare(itemB.name || b);
            });

            for (const itemKey of sortedItemKeys) {
                if (player.resources[itemKey] > 0 && Game.ITEM_DATA[itemKey] && Game.ITEM_DATA[itemKey].type !== 'currency') {
                    itemsToDisplay.push({ key: itemKey, quantity: player.resources[itemKey], data: Game.ITEM_DATA[itemKey] });
                }
            }

            const totalSlots = player.maxInventorySlots || 50; 

            for (let i = 0; i < totalSlots; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('inventory-slot');

                // Create the frame div that will have the background image
                const frameDiv = document.createElement('div');
                frameDiv.classList.add('inventory-slot-frame');

                if (i < itemsToDisplay.length) {
                    const item = itemsToDisplay[i];
                    slotDiv.classList.add('has-item');
                    frameDiv.title = `${item.data.name} (x${item.quantity})\n${item.data.description || ''}`; // Tooltip on frame

                    const iconDiv = document.createElement('div');
                    iconDiv.classList.add('inventory-slot-icon');
                    
                    if (item.data.gameAsset) {
                        iconDiv.style.backgroundImage = `url('${item.data.gameAsset}')`;
                        iconDiv.textContent = ''; 
                        iconDiv.style.backgroundSize = 'contain'; 
                        iconDiv.style.backgroundRepeat = 'no-repeat';
                        iconDiv.style.backgroundPosition = 'center';
                    } else if (item.data.iconChar) { 
                        iconDiv.style.backgroundImage = 'none'; 
                        iconDiv.textContent = item.data.iconChar;
                    } else { 
                        iconDiv.style.backgroundImage = 'none'; 
                        iconDiv.textContent = item.data.name ? item.data.name.substring(0, 1).toUpperCase() : '?';
                    }
                    frameDiv.appendChild(iconDiv); // Icon goes inside the frame

                    const nameDiv = document.createElement('div');
                    nameDiv.classList.add('inventory-slot-name');
                    nameDiv.textContent = item.data.name || 'Unknown Item';

                    if (item.quantity > 0) { 
                        const quantityDiv = document.createElement('div');
                        quantityDiv.classList.add('inventory-slot-quantity');
                        quantityDiv.textContent = `x${item.quantity}`;
                        frameDiv.appendChild(quantityDiv); // Quantity also inside the frame
                    }

                    slotDiv.appendChild(frameDiv); // Add the frame to the slot
                    slotDiv.appendChild(nameDiv); // Name is a sibling of frame, under it

                    frameDiv.onclick = () => Game.promptUseItem(item.key, item.data.name);
                } else {
                    // For empty slots, just add the frame and an empty name div for spacing
                    slotDiv.appendChild(frameDiv);
                    const emptyNameDiv = document.createElement('div');
                    emptyNameDiv.classList.add('inventory-slot-name');
                    emptyNameDiv.innerHTML = '&nbsp;'; // Non-breaking space to maintain layout
                    slotDiv.appendChild(emptyNameDiv);
                }
                modalInventoryGridContainer.appendChild(slotDiv);
            }

            if (itemsToDisplay.length === 0 && totalSlots > 0) {
                // Logic for displaying "Empty" in the first slot is removed.
                // Empty slots will show the 'emptyinventoryslot.png' frame and a blank name area.
                // A general "Inventory Empty" message could be placed outside the grid if desired.
            }
        }
        
        function populateActionButtons(choices, containerElement) {
            containerElement.innerHTML = ''; 
            try {
                if (choices && choices.length > 0) {
                    choices.forEach(choice => {
                        const button = document.createElement('button');
                        button.textContent = choice.text;
                        // Removed Tailwind classes for color, padding, shadow, rounded, as .action-button CSS handles this.
                        // Kept 'm-1' for margin.
                        button.classList.add('action-button', 'm-1');
                        
                        // The specific background color styles (danger, confirm, etc.) will be overridden by the background-image.
                        // If different button appearances are needed for these states,
                        // it would require different button images or CSS filters on new specific classes.
                        // For now, all buttons will use the primary button.png style.
                        // let styleClass = 'bg-blue-600 hover:bg-blue-700'; 
                        if (choice.style === 'danger') styleClass = 'bg-red-600 hover:bg-red-700';
                        // Add tooltip if provided
                        if (choice.tooltip) {
                            button.title = choice.tooltip;
                        }
                        else if (choice.style === 'confirm') styleClass = 'bg-green-600 hover:bg-green-700';
                        else if (choice.style === 'neutral') styleClass = 'bg-gray-600 hover:bg-gray-700';
                        else if (choice.style === 'special') styleClass = 'bg-purple-600 hover:bg-purple-700';
                        else if (choice.style === 'divine') styleClass = 'bg-pink-600 hover:bg-pink-700'; 
                        else if (choice.style === 'class_select') styleClass = 'bg-teal-600 hover:bg-teal-700'; 
                        else if (choice.style === 'inventory_item_original') styleClass = 'bg-indigo-600 hover:bg-indigo-700 inventory-item-button';
                        else if (choice.style === 'market_action') styleClass = 'bg-yellow-500 hover:bg-yellow-600 text-gray-900'; 
                        else if (choice.style === 'crafting_action') styleClass = 'bg-lime-600 hover:bg-lime-700 text-gray-900 concoction-recipe-button'; 
                        // button.classList.add(...styleClass.split(' ')); // Not adding these color classes for now
                        
                        if (choice.action === 'show_class_info') {
                            button.onclick = () => Game.showClassInfo(choice.value);
                        } else if (choice.action === 'use_item') { // This path might be less used if items are used from grid
                            const itemDataForButton = Game.ITEM_DATA[choice.value];
                            const itemNameForButton = itemDataForButton ? itemDataForButton.name : "Item";
                            button.onclick = () => Game.promptUseItem(choice.value, itemNameForButton);
                        } else if (choice.action === 'list_item_for_sale_prompt') {
                            button.onclick = () => Game.promptListItemForSale(choice.value);
                        } else if (choice.action === 'prompt_concoct_quantity') { 
                            button.onclick = () => Game.promptConcoctQuantity(choice.value);
                        }
                        else {
                            button.onclick = () => Game.handlePlayerChoice(choice.action, choice.value);
                        }
                        containerElement.appendChild(button);
                    });
                }
            } catch (error) { console.error("Error populating action buttons:", error); displayMessage("Error displaying choices.", "error");}
        }

        function getModalInput(promptText, type = 'text') {
            return new Promise((resolve) => {
                try {
                    if (!inputModal || !modalPrompt || !modalInputField || !modalPasswordInputField) {
                        console.error("Modal DOM elements not found!"); displayMessage("Error: UI input missing.", "error"); resolve(null); return;
                    }
                    modalPrompt.textContent = promptText;
                    modalInputField.value = ''; modalPasswordInputField.value = ''; 
                    if (type === 'password') {
                        modalInputField.style.display = 'none'; modalPasswordInputField.style.display = 'block'; modalPasswordInputField.focus();
                    } else { 
                        modalInputField.style.display = 'block'; modalPasswordInputField.style.display = 'none'; modalInputField.type = type; modalInputField.focus();
                    }
                    inputModal.style.display = 'flex'; // Changed to flex for consistency with other modals
                    modalResolve = resolve; 
                } catch (error) { console.error("Error in getModalInput:", error); displayMessage("Error preparing input.", "error"); resolve(null); }
            });
        }

        modalSubmitButton.onclick = () => {
            try {
                if (modalResolve) {
                    const value = modalPasswordInputField.style.display === 'none' ? modalInputField.value : modalPasswordInputField.value;
                    modalResolve(value.trim()); 
                }
            } catch (error) { console.error("Error in modalSubmitButton:", error); if (modalResolve) modalResolve(null); } 
            finally { if (inputModal) inputModal.style.display = 'none'; modalResolve = null; }
        };

        modalCancelButton.onclick = () => {
            try { if (modalResolve) { modalResolve(null); } } 
            catch (error) { console.error("Error in modalCancelButton:", error); } 
            finally { if (inputModal) inputModal.style.display = 'none'; modalResolve = null; }
        };
        
        function getYesNoModalInput(promptText) {
            return new Promise((resolve) => {
                if (!inputModal || !modalPrompt || !modalInputField || !modalPasswordInputField || !modalSubmitButton || !modalCancelButton) {
                    console.error("Modal DOM elements not found for Yes/No prompt!");
                    resolve(null); // Or false, depending on desired default for error
                    return;
                }
                // Store original states
                const originalSubmitText = modalSubmitButton.textContent;
                const originalCancelText = modalCancelButton.textContent;
                const originalSubmitOnClick = modalSubmitButton.onclick;
                const originalCancelOnClick = modalCancelButton.onclick;
                const originalZIndex = inputModal.style.zIndex;

                modalPrompt.textContent = promptText;
                modalInputField.style.display = 'none';
                modalPasswordInputField.style.display = 'none';

                modalSubmitButton.textContent = "Yes";
                modalCancelButton.textContent = "No";

                const cleanupAndResolve = (value) => {
                    if (inputModal) inputModal.style.display = 'none';
                    // Restore original states
                    modalSubmitButton.textContent = originalSubmitText;
                    modalCancelButton.textContent = originalCancelText;
                    modalSubmitButton.onclick = originalSubmitOnClick;
                    modalCancelButton.onclick = originalCancelOnClick;
                    inputModal.style.zIndex = originalZIndex;
                    resolve(value);
                };

                inputModal.style.zIndex = '210'; // Higher than inventory modal (200)
                modalSubmitButton.onclick = () => cleanupAndResolve(true);
                modalCancelButton.onclick = () => cleanupAndResolve(false);

                inputModal.style.display = 'flex';
            });
        }

        // Inventory Modal Close Button
        if (closeInventoryModalButton) {
            closeInventoryModalButton.onclick = () => Game.toggleGridInventoryModal();
        }
        
        // Hamburger Menu Logic
        if (hamburgerIcon && sideMenu) {
            hamburgerIcon.addEventListener('click', () => {
                hamburgerIcon.classList.toggle('active');
                sideMenu.classList.toggle('active');
            });
        }

        function closeSideMenu() {
            if (hamburgerIcon && sideMenu) {
                hamburgerIcon.classList.remove('active');
                sideMenu.classList.remove('active');
            }
        }

        document.getElementById('menu-nav-home')?.addEventListener('click', (e) => {
            e.preventDefault();
            closeSideMenu(); // Close menu regardless of combat state

            if (Game.currentCombat) {
                displayMessage("Cannot return home during combat!", "error");
                return; 
            }

            // If player was in a dedicated exploration, reset that state.
            if (Game.currentExploringAreaKey) {
                Game.currentExploringAreaKey = null;
                if (gameContainer) gameContainer.classList.remove('dedicated-exploration-background'); 
            }
            
            // showLoggedInMenu handles hiding most specific UI elements (inventory modal, market, etc.)
            // and sets up the main menu.
            Game.showLoggedInMenu(); 
            // setMainView ensures the overall body class and panel visibility are correct for 'gameplay'.
            Game.setMainView('gameplay'); 
        });
        document.getElementById('menu-nav-profile')?.addEventListener('click', (e) => {
            e.preventDefault();
            Game.setMainView('profile');
            closeSideMenu();
        });
        document.getElementById('menu-nav-players')?.addEventListener('click', (e) => {
            e.preventDefault();
            Game.showPlayerSearch();
            closeSideMenu();
        });
        document.getElementById('menu-nav-chat')?.addEventListener('click', (e) => {
            e.preventDefault();
            document.body.classList.toggle('chat-visible');
            closeSideMenu();
        });
        document.getElementById('menu-nav-logout')?.addEventListener('click', (e) => {
            e.preventDefault(); Game.logout(); closeSideMenu();
        });

        // Auth Form Button Event Listeners
        document.getElementById('submit-create-account')?.addEventListener('click', () => Game.handleCreateAccountFormSubmit());
        document.getElementById('cancel-create-account')?.addEventListener('click', () => Game.showMainGate());
        document.getElementById('submit-login')?.addEventListener('click', () => Game.handleLoginFormSubmit());
        document.getElementById('cancel-login')?.addEventListener('click', () => Game.showMainGate());

        // Auth Form Input Keypress Listeners for Enter key
        createUsernameInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') createPasswordInput.focus(); });
        createPasswordInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') createEmailInput.focus(); }); // Focus email next
        createEmailInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') Game.handleCreateAccountFormSubmit(); }); // Submit on enter from email
        loginUsernameInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') loginPasswordInput.focus(); });
        loginPasswordInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') Game.handleLoginFormSubmit(); });



        // --- CHAT UI FUNCTIONS ---
        function displayChatMessage(messageData) {
            if (!chatLogContainer || !Game.currentPlayerId) return;

            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message');

            const senderNameSpan = document.createElement('span');
            senderNameSpan.classList.add('sender-name');
            senderNameSpan.textContent = `${messageData.senderName}:`; 

            const messageTextSpan = document.createElement('span');
            messageTextSpan.classList.add('message-text');
            messageTextSpan.textContent = ` ${messageData.text}`; 

            messageDiv.appendChild(senderNameSpan);
            messageDiv.appendChild(messageTextSpan);

            if (messageData.timestamp && messageData.timestamp.toDate) { 
                const timestampSpan = document.createElement('span');
                timestampSpan.classList.add('timestamp');
                timestampSpan.textContent = `(${new Date(messageData.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;
                messageDiv.appendChild(timestampSpan);
            }

            if (messageData.senderId === Game.currentPlayerId) {
                messageDiv.classList.add('my-message');
            } else {
                messageDiv.classList.add('other-message');
            }

            chatLogContainer.appendChild(messageDiv);
            chatLogContainer.scrollTop = chatLogContainer.scrollHeight;
        }

        if (chatSendButton) {
            chatSendButton.onclick = () => {
                const messageText = chatInput.value.trim();
                if (messageText && Game.currentPlayerId && !chatSendButton.disabled) {
                    Game.sendChatMessage(messageText);
                    chatInput.value = '';
                }
            };
        }

        if (chatInput) {
            chatInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' && !chatInput.disabled) {
                    event.preventDefault(); 
                    chatSendButton.click();
                }
            });
        }
        // --- END: FRONTEND UI JAVASCRIPT ---
    </script>

    <script>
        // --- START: JAVASCRIPT GAME ENGINE (BACKEND LOGIC) ---

        const firebaseConfig = {
            apiKey: "AIzaSyBHSlX7zLuA37k9SyJqYXmV3IjUK3D-ZLg", 
            authDomain: "cultivation-480d8.firebaseapp.com",
            projectId: "cultivation-480d8",
            storageBucket: "cultivation-480d8.appspot.com",
            messagingSenderId: "901657097350",
            appId: "1:901657097350:web:98c13aee51f9c7d1fc0d07",
            measurementId: "G-66ZMDER5X4"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore(); 

        function toCamelCase(str) {
            if (!str) return '';
            let cleanedStr = str.replace(/[^a-zA-Z0-9\s]/g, '');
            return cleanedStr.toLowerCase()
                .replace(/\s+(.)/g, (match, chr) => chr.toUpperCase())
                .replace(/\s/g, '') 
                .replace(/^(.)/, (match, chr) => chr.toLowerCase());
        }

        class Character {
            constructor(name, str, agi, con, spr, intl, wil, cultivationLevel = 0) {
                this.name = name;
                this.strength = str;
                this.agility = agi;
                this.constitution = con;
                this.spirit = spr;
                this.intellect = intl;
                this.willpower = wil;
                
                this.cultivationLevel = cultivationLevel;
                this.cultivationProgress = 0;

                // Derived stats, calculated in constructor or by methods
                this.maxHealth = this.calculateMaxHealth();
                this.health = this.maxHealth; // Initialize health to maxHealth
                this.maxQi = this.calculateMaxQi();
                this.currentQi = this.maxQi;
            }

            calculateMaxHealth() { return 50 + (this.constitution || 0) * 10; }
            calculateMaxQi() { return 30 + (this.spirit || 0) * 10; }

            // To be implemented by Player/Monster
            getTotalAttack() { return (this.strength || 0) * 2; } 
            getPhysicalDefense() { return (this.constitution || 0) * 1; }
            getSpellPower() { return (this.spirit || 0) * 2; }

            isAlive() { return this.health > 0; }

            takeDamage(damage) { 
                const actualDamage = Math.max(0, damage - this.getPhysicalDefense()); 
                this.health -= actualDamage;
                let message = `${this.name} takes <strong class="text-yellow-300">${actualDamage}</strong> damage. (HP: ${this.health}/${this.maxHealth})`;
                if (!this.isAlive()) { message += ` ${this.name} has been defeated!`; }
                const messageStyle = (this instanceof Player) ? 'combat-text-opponent-action' : 'combat-text-player-action';
                if (Game.currentCombat) { 
                   updateCombatUI(Game.players[Game.currentPlayerId], Game.currentCombat.opponent); 
                }
                return { actualDamage: actualDamage, message: message, style: messageStyle }; 
            }

            attackTarget(target) { 
                if (!this.isAlive()) return;
                
                const attackMessageStyle = (this instanceof Player) ? 'combat-text-player-action' : 'combat-text-opponent-action';
                const damageSourceAttack = this.getTotalAttack(); 

                displayCombatAction(`${this.name} attacks ${target.name}!`, attackMessageStyle); 
                
                const baseDamage = damageSourceAttack;
                const damageVariance = Math.floor(damageSourceAttack / 5);
                const damage = baseDamage + (Math.floor(Math.random() * (damageVariance * 2 + 1)) - damageVariance);
                
                const damageResult = target.takeDamage(damage); 
                appendCombatAction(damageResult.message, damageResult.style); 
            }

            getCultivationRealmName() {
                const realms = ["Mortal", "Qi Condensation", "Foundation Establishment", "Core Formation", "Nascent Soul", "Soul Formation", "Transcendent"]; 
                if (this.cultivationLevel === 0) return realms[0]; 
                if (this.cultivationLevel >= 46) return realms[6]; // Transcendent (Level 46+)
                if (this.cultivationLevel >= 37) return realms[5]; // Soul Formation (Level 37-45)
                if (this.cultivationLevel >= 28) return realms[4]; // Nascent Soul (Level 28-36)
                if (this.cultivationLevel >= 19) return realms[3]; // Core Formation (Level 19-27)
                if (this.cultivationLevel >= 10) return realms[2]; // Foundation Establishment (Level 10-18)
                
                const qiCondensationStage = (this.cultivationLevel - 1) % 9 + 1;
                return `${realms[1]} Stage ${qiCondensationStage}`;
            }

            getXPForNextLevel() { return (this.cultivationLevel + 1) * 100; }
            
            gainCultivationXP(xp) {
                if (!this.isAlive()) return;
            
                if (this instanceof Player && this.isAtMajorBreakthrough()) {
                    const requiredPillName = this.getRequiredBreakthroughPillName();
                    displayMessage(`You are at the peak of ${this.getCultivationRealmName()} and require a <span class="important">${requiredPillName}</span>. You are not gaining further experience.`, 'system');
                    if (this instanceof Player) { 
                        updateStatsDisplay(this); 
                        Game.saveCurrentPlayerState(); 
                    }
                    return; 
                }
            
                const finalXp = Math.floor(xp * (this.spiritualRootMultiplier || 1));
                let gainedEffectiveXP = finalXp;
            
                if (this instanceof Player) {
                    const player = this;
                    const levelBeforePotentialGain = player.cultivationLevel;
                    const progressBeforePotentialGain = player.cultivationProgress;
                    const xpToNextLevelBeforeGain = player.getXPForNextLevel();
            
                    const isCurrentlyAtBreakthroughLevelButNotFull = (
                        (levelBeforePotentialGain === 9 || levelBeforePotentialGain === 18 || levelBeforePotentialGain === 27 || levelBeforePotentialGain === 36 || levelBeforePotentialGain === 45) &&
                        progressBeforePotentialGain < xpToNextLevelBeforeGain 
                    );
            
                    if (isCurrentlyAtBreakthroughLevelButNotFull) {
                        const xpCanStillGain = xpToNextLevelBeforeGain - progressBeforePotentialGain;
                        if (finalXp > xpCanStillGain) {
                            gainedEffectiveXP = xpCanStillGain; 
                            player.cultivationProgress += gainedEffectiveXP; 
                            displayMessage(`${player.name} gained ${gainedEffectiveXP} cultivation experience.`, 'success');
                            
                            const requiredPillName = player.getRequiredBreakthroughPillName(); 
                            displayMessage(`You have reached the peak of ${player.getCultivationRealmName()}. You require a <span class="important">${requiredPillName}</span> to break through!`, 'system');
                            displayMessage(`You are no longer gaining cultivation experience until you break through.`, 'system');
                            
                            updateStatsDisplay(player); 
                            Game.saveCurrentPlayerState();
                            return; 
                        }
                    }
                }
                
                this.cultivationProgress += gainedEffectiveXP; 
                if (gainedEffectiveXP > 0) {
                    displayMessage(`${this.name} gained ${gainedEffectiveXP} cultivation experience.`, 'success'); 
                }
            
                while (this.cultivationProgress >= this.getXPForNextLevel() && this.isAlive()) {
                    this.cultivationProgress -= this.getXPForNextLevel();
                    this.cultivationLevel += 1; 

                    // Award Free Attribute Points (Player only)
                    if (this instanceof Player) {
                        let pointsAwarded = 0;
                        const cl = this.cultivationLevel;
                        if (cl >= 1 && cl <= 9) pointsAwarded = 2;
                        else if (cl >= 10 && cl <= 18) pointsAwarded = 3;
                        else if (cl >= 19 && cl <= 27) pointsAwarded = 4;
                        else if (cl >= 28 && cl <= 36) pointsAwarded = 5;
                        else if (cl >= 37 && cl <= 45) pointsAwarded = 6;
                        else if (cl >= 46) pointsAwarded = 8;
                        this.freeAttributePoints = (this.freeAttributePoints || 0) + pointsAwarded;
                        displayMessage(`You gained <span class="important">${pointsAwarded}</span> free attribute points! You have ${this.freeAttributePoints} unspent.`, "success");
                    }

                    // Stat increases on level up - Class specific
                    if (this instanceof Player && this.chosenClassKey && Game.CLASS_STAT_GROWTH[this.chosenClassKey]) {
                        const growth = Game.CLASS_STAT_GROWTH[this.chosenClassKey];
                        this.strength = (this.strength || 0) + (growth.str || 0);
                        this.agility = (this.agility || 0) + (growth.agi || 0);
                        this.constitution = (this.constitution || 0) + (growth.con || 0);
                        this.spirit = (this.spirit || 0) + (growth.spr || 0);
                        this.intellect = (this.intellect || 0) + (growth.intl || 0);
                        this.willpower = (this.willpower || 0) + (growth.wil || 0);
                        displayMessage("Class-specific stat growth applied.", "system");
                    } else {
                        // Fallback generic stat increase for monsters or players without a class/defined growth
                        this.constitution = (this.constitution || 0) + 1;
                        this.spirit = (this.spirit || 0) + 1;
                        const otherAttrs = ['strength', 'agility', 'intellect', 'willpower'];
                        const randomAttrToIncrease = otherAttrs[Math.floor(Math.random() * otherAttrs.length)];
                        this[randomAttrToIncrease] = (this[randomAttrToIncrease] || 0) + 1;
                        if (this instanceof Player) {
                             displayMessage("Generic stat growth applied (no specific class plan found or class not chosen).", "system");
                        }
                    }
                    
                    
                    // Recalculate derived stats
                    this.maxHealth = this.calculateMaxHealth();
                    this.health = this.maxHealth; // Full heal on level up
                    this.maxQi = this.calculateMaxQi();
                    this.currentQi = this.maxQi; // Full Qi on level up

                    if (this instanceof Player) {
                        // Player specific level up bonuses if any, already handled by Qi recalculation
                    }

                    displayMessage(`Congratulations! ${this.name} has reached ${this.getCultivationRealmName()}!`, 'important');
            
                    if (this instanceof Player) {
                        const player = this;
                        const currentLevel = player.cultivationLevel;
                        const isMajorBreakthroughLevel = (currentLevel === 9 || currentLevel === 18 || currentLevel === 27 || currentLevel === 36 || currentLevel === 45);
                        
                        if (isMajorBreakthroughLevel) {
                            player.cultivationProgress = player.getXPForNextLevel(); 
                            const requiredPillName = player.getRequiredBreakthroughPillName(); 
                            displayMessage(`You have reached the peak of ${player.getCultivationRealmName()}. You require a <span class="important">${requiredPillName}</span> to break through!`, 'system');
                            displayMessage(`You are no longer gaining cultivation experience until you break through.`, 'system');
                            
                            updateStatsDisplay(player); 
                            Game.saveCurrentPlayerState();
                            return; 
                        }
                    }
                }
            
                if (this instanceof Player) {
                    updateStatsDisplay(this); 
                    Game.saveCurrentPlayerState(); 
                }
            }
        }

        class Player extends Character {
            constructor(username, password, email = null) { // name parameter removed, email added
                super(username, 5, 5, 5, 5, 5, 5, 1); // Pass username as name to Character, STR, AGI, CON, SPR, INT, WIL, Level
                // ... (rest of constructor)
                this.username = username; this.password = password;
                this.email = email; // Store email
                this.playerId = Game.generateId();
                this.sectId = null;
                this.maxInventorySlots = 50;
                this.resources = {
                    commonHerbs: 0, roughIronOre: 0, blankTalismanPaper: 0,
                    monsterCoreWeak: 0, beastBoneFragment: 0, spiritDust: 0,
                    spiritStoneFragment: 0, spiritStones: 0,
                    minorHealingPill: 0, minorQiPill: 0,
                    roughSword: 0, minorFireTalisman: 0,
                    jadeleafGrass: 0, crimsonSpiritBerry: 0, soothingRainPetal: 0,
                    moondewFlower: 0, earthrootGinseng: 0, skyLotusBud: 0,
                    whisperingLeaf: 0, radiantSunfruit: 0, cloudmossVine: 0,
                    spiritglowMushroom: 0,
                    breakthroughVine: 0, dragonboneFern: 0, phoenixbloodHerb: 0,
                    ascensionOrchid: 0, heavenpierceRoot: 0, divineFlameGrass: 0,
                    lunarBloom: 0, immortalDustleaf: 0, voidberryThorn: 0,
                    thunderclapFruit: 0,
                    starforgePetal: 0, stoneheartRoot: 0, spiritEyeFlower: 0, heartblossomBud: 0,
                    silverstormLeaf: 0, goldenDantianFruit: 0, blackflameGinseng: 0, frostmarrowMoss: 0,
                    harmonizingBellvine: 0, eyeOfTheAncients: 0,
                    // Artifact Refining Materials
                    spiritOreFragment: 0, enchantedStoneDust: 0, minorQiConductor: 0, demonCore: 0
                };
                this.spiritualRootName = "Undetermined";
                this.spiritualRootMultiplier = 1;
                this.hasRolledSpiritualRoot = false;
                this.chosenClassName = "Undetermined";
                this.chosenClassKey = null;
                this.hasClassChosen = false;
                this.demonicCorruption = 0;
                this.sectRole = null;
                // this.equippedWeapon = null; // Removed, weapon is part of equippedItems
                this.equippedItems = { // Use canonical slot names
                    weapon: null,
                    body: null,   // Changed from armor
                    head: null,   // Changed from helmet
                    feet: null,   // Changed from boots
                    ring1: null   // Changed from ring, assuming ring1 for the first ring
                };
                this.weaponPhysicalAttackBonus = 0;
                this.knownRecipes = [];
                this.freeAttributePoints = 0;

                // Initialize health and Qi based on initial attributes
                this.maxHealth = this.calculateMaxHealth();
                this.health = this.maxHealth;
                this.maxQi = this.calculateMaxQi();
                this.currentQi = this.maxQi;
            }

            getTotalAttack() {
                return (this.strength || 0) * 2 + (this.weaponPhysicalAttackBonus || 0);
            }

            isAtMajorBreakthrough() {
                const xpNeededForNext = this.getXPForNextLevel();
                if (this.cultivationProgress < xpNeededForNext) return false; 

                const level = this.cultivationLevel;
                return (level === 9 || level === 18 || level === 27 || level === 36 || level === 45);
            }

            getRequiredBreakthroughPillName() {
                if (this.cultivationLevel === 9) return "Foundation Establishment Pill";
                if (this.cultivationLevel === 18) return "Golden Core Nine Revolutions Pill";
                if (this.cultivationLevel === 27) return "Nascent Soul Unification Pill";
                if (this.cultivationLevel === 36) return "Soul Formation Heaven Pill";
                if (this.cultivationLevel === 45) return "Transcendence Void Elixir";
                return null; 
            }
            
            _performMajorBreakthrough(newCultivationLevel, newRealmShortName) {
                this.cultivationProgress = 0; 
                this.cultivationLevel = newCultivationLevel; 

                // Major breakthrough stat increases
                this.strength = (this.strength || 0) + 3;
                this.agility = (this.agility || 0) + 3;
                this.constitution = (this.constitution || 0) + 3;
                this.spirit = (this.spirit || 0) + 3;
                this.intellect = (this.intellect || 0) + 3;
                this.willpower = (this.willpower || 0) + 3;

                // Recalculate derived stats
                this.maxHealth = this.calculateMaxHealth();
                this.maxQi = this.calculateMaxQi();

                // Full restore on breakthrough
                this.health = this.maxHealth; 
                this.currentQi = this.maxQi; 

                this.maxInventorySlots = (this.maxInventorySlots || 50) + 50;
                displayMessage(`Your inventory capacity has expanded to <span class="important">${this.maxInventorySlots}</span> slots!`, 'success');

                displayMessage(`The pill surges through you! You have broken through to the <span class="important">${newRealmShortName}</span> realm!`, 'important');
                displayMessage(`Congratulations! ${this.name} has reached ${this.getCultivationRealmName()}!`, 'important'); 
            }

            meditate() {
                if (!this.isAlive()) { displayMessage("Cannot meditate while defeated.", 'error'); Game.showLoggedInMenu(); return; }
                displayMessage(`\n${this.name} enters a meditative state...`, 'narration');
                
                let healthRecoveryPercent = 0.25; 
                let qiRecoveryPercent = 0.25; 

                if (this.chosenClassKey === 'qi_cultivator') {
                    qiRecoveryPercent = 0.35; 
                    healthRecoveryPercent = 0.30; 
                    displayMessage("Your affinity for Qi enhances your meditation.", 'class-info');
                }
                
                const healthRecovered = Math.floor(this.maxHealth * healthRecoveryPercent);
                const qiRecovered = Math.floor(this.maxQi * qiRecoveryPercent);

                this.health = Math.min(this.maxHealth, this.health + healthRecovered);
                this.currentQi = Math.min(this.maxQi, this.currentQi + qiRecovered);

                displayMessage(`Health recovered by ${healthRecovered}. Current Health: ${this.health}/${this.maxHealth}`, 'success');
                displayMessage(`Spiritual Energy (QI) recovered by ${qiRecovered}. Current QI: ${this.currentQi}/${this.maxQi}`, 'qi-recovery');
                
                updateStatsDisplay(this);
                Game.saveCurrentPlayerState(); 
                Game.showLoggedInMenu();
            }
            toFirestoreObject() {
                const defaultResources = {
                    commonHerbs: 0, roughIronOre: 0, blankTalismanPaper: 0,
                    monsterCoreWeak: 0, beastBoneFragment: 0, spiritDust: 0,
                    spiritStoneFragment: 0, spiritStones: 0,
                    minorHealingPill: 0, minorQiPill: 0,
                    roughSword: 0, minorFireTalisman: 0,
                    jadeleafGrass: 0, crimsonSpiritBerry: 0, soothingRainPetal: 0,
                    moondewFlower: 0, earthrootGinseng: 0, skyLotusBud: 0,
                    whisperingLeaf: 0, radiantSunfruit: 0, cloudmossVine: 0,
                    spiritglowMushroom: 0,
                    breakthroughVine: 0, dragonboneFern: 0, phoenixbloodHerb: 0,
                    ascensionOrchid: 0, heavenpierceRoot: 0, divineFlameGrass: 0,
                    lunarBloom: 0, immortalDustleaf: 0, voidberryThorn: 0,
                    thunderclapFruit: 0,
                    starforgePetal: 0, stoneheartRoot: 0, spiritEyeFlower: 0, heartblossomBud: 0,
                    silverstormLeaf: 0, goldenDantianFruit: 0, blackflameGinseng: 0, frostmarrowMoss: 0,
                    harmonizingBellvine: 0, eyeOfTheAncients: 0,
                    // Artifact Refining Materials
                    spiritOreFragment: 0, enchantedStoneDust: 0, minorQiConductor: 0, demonCore: 0
                };
                for (const recipeKey in Game.PILL_RECIPES) {
                    const pillItemKey = Game.PILL_RECIPES[recipeKey].producesItemKey;
                    if (!defaultResources.hasOwnProperty(pillItemKey)) {
                        defaultResources[pillItemKey] = 0;
                    }
                    const recipeItemKeyForPill = toCamelCase(Game.PILL_RECIPES[recipeKey].name) + "Recipe";
                     if (!Game.PILL_RECIPES[recipeKey].isBasic && !defaultResources.hasOwnProperty(recipeItemKeyForPill)) {
                        defaultResources[recipeItemKeyForPill] = 0;
                    }
                }
                const resourcesToSave = { ...defaultResources, ...this.resources };
                return {
                    username: this.username, password: this.password, name: this.name, playerId: this.playerId,
                    email: this.email, strength: this.strength, agility: this.agility, constitution: this.constitution, 
                    spirit: this.spirit, intellect: this.intellect, willpower: this.willpower,
                    maxHealth: this.maxHealth, health: this.health, // maxQi and currentQi are derived or set
                    cultivationLevel: this.cultivationLevel, cultivationProgress: this.cultivationProgress,
                    sectId: this.sectId, 
                    maxInventorySlots: this.maxInventorySlots, 
                    resources: resourcesToSave, 
                    spiritualRootName: this.spiritualRootName,
                    spiritualRootMultiplier: this.spiritualRootMultiplier, hasRolledSpiritualRoot: this.hasRolledSpiritualRoot,
                    chosenClassName: this.chosenClassName, 
                    chosenClassKey: this.chosenClassKey,
                    hasClassChosen: this.hasClassChosen, 
                    maxQi: this.maxQi, // Save calculated maxQi
                    currentQi: this.currentQi,
                    demonicCorruption: this.demonicCorruption,
                    // equippedWeapon: this.equippedWeapon, // This is now part of equippedItems
                    equippedItems: this.equippedItems, // This will save the new structure {weapon, armor, ...}
                    weaponPhysicalAttackBonus: this.weaponPhysicalAttackBonus,
                    knownRecipes: this.knownRecipes || [],
                    freeAttributePoints: this.freeAttributePoints || 0,
                    sectRole: this.sectRole
                };
            }
            static fromFirestoreObject(docData) {
                // Pass docData.name as the name to the constructor (which is the username)
                const player = new Player(docData.username, docData.password, docData.email || null);
                const defaultResources = {
                    commonHerbs: 0, roughIronOre: 0, blankTalismanPaper: 0,
                    monsterCoreWeak: 0, beastBoneFragment: 0, spiritDust: 0,
                    spiritStoneFragment: 0, spiritStones: 0,
                    minorHealingPill: 0, minorQiPill: 0,
                    roughSword: 0, minorFireTalisman: 0,
                    jadeleafGrass: 0, crimsonSpiritBerry: 0, soothingRainPetal: 0,
                    moondewFlower: 0, earthrootGinseng: 0, skyLotusBud: 0,
                    whisperingLeaf: 0, radiantSunfruit: 0, cloudmossVine: 0,
                    spiritglowMushroom: 0,
                    breakthroughVine: 0, dragonboneFern: 0, phoenixbloodHerb: 0,
                    ascensionOrchid: 0, heavenpierceRoot: 0, divineFlameGrass: 0,
                    lunarBloom: 0, immortalDustleaf: 0, voidberryThorn: 0,
                    thunderclapFruit: 0,
                    starforgePetal: 0, stoneheartRoot: 0, spiritEyeFlower: 0, heartblossomBud: 0,
                    silverstormLeaf: 0, goldenDantianFruit: 0, blackflameGinseng: 0, frostmarrowMoss: 0,
                    harmonizingBellvine: 0, eyeOfTheAncients: 0,
                    // Artifact Refining Materials
                    spiritOreFragment: 0, enchantedStoneDust: 0, minorQiConductor: 0, demonCore: 0
                };
                for (const recipeKey in Game.PILL_RECIPES) {
                    const pillItemKey = Game.PILL_RECIPES[recipeKey].producesItemKey;
                    if (!defaultResources.hasOwnProperty(pillItemKey)) {
                        defaultResources[pillItemKey] = 0;
                    }
                     const recipeItemKeyForPill = toCamelCase(Game.PILL_RECIPES[recipeKey].name) + "Recipe";
                     if (!Game.PILL_RECIPES[recipeKey].isBasic && !defaultResources.hasOwnProperty(recipeItemKeyForPill)) {
                        defaultResources[recipeItemKeyForPill] = 0;
                    }
                }
                const resourcesFromDb = docData.resources || {};
                Object.assign(player, {
                    ...docData,
                    maxInventorySlots: docData.maxInventorySlots || 50,
                    name: docData.name, // Ensure name (which is username) is correctly assigned
                    resources: { ...defaultResources, ...resourcesFromDb } ,
                    strength: docData.strength || 5, // Default if missing
                    agility: docData.agility || 5,
                    constitution: docData.constitution || 5,
                    spirit: docData.spirit || 5,
                    intellect: docData.intellect || 5,
                    willpower: docData.willpower || 5,
                    knownRecipes: docData.knownRecipes || [], // Ensure this is loaded
                    sectRole: docData.sectRole || null,
                    freeAttributePoints: docData.freeAttributePoints || 0
                    // equippedItems will be handled after Object.assign
                });

                // Initialize and load equipped items with new structure, handling old format
                const loadedEqData = docData.equippedItems || {};
                player.equippedItems = {
                    weapon: loadedEqData.weapon || docData.equippedWeapon || null, // Stays 'weapon'
                    body:   loadedEqData.body   || loadedEqData.armor  || null, // Use 'body', can load from 'armor'
                    head:   loadedEqData.head   || loadedEqData.helmet || null, // Use 'head', can load from 'helmet'
                    feet:   loadedEqData.feet   || loadedEqData.boots  || null, // Use 'feet', can load from 'boots'
                    ring1:  loadedEqData.ring1  || loadedEqData.ring   || null  // Use 'ring1', can load from 'ring'
                };
                
                for (const key in player.resources) {
                    player.resources[key] = Number(player.resources[key]) || 0;
                }
                player.demonicCorruption = Number(player.demonicCorruption) || 0;
                player.weaponPhysicalAttackBonus = Number(docData.weaponPhysicalAttackBonus) || 0;
                player.maxHealth = player.calculateMaxHealth(); // Recalculate based on loaded CON
                player.health = Math.min(docData.health || player.maxHealth, player.maxHealth); // Ensure health doesn't exceed new maxHealth
                player.maxQi = player.calculateMaxQi(); // Recalculate based on loaded SPR
                player.currentQi = Math.min(docData.currentQi || player.maxQi, player.maxQi);
                return player;
            }
            joinSect(sectId) {
                if (Game.sects[sectId]) {
                    if (this.sectId) { displayMessage(`Already in ${Game.sects[this.sectId].name}.`, 'error'); return; }
                    Game.sects[sectId].addMember(this.playerId); this.sectId = sectId;
                    // Set the player's role based on what's assigned in the sect's member list
                    if (Game.sects[sectId].members && Game.sects[sectId].members[this.playerId]) {
                        this.sectRole = Game.sects[sectId].members[this.playerId].role;
                        displayMessage(`Joined ${Game.sects[sectId].name} as a ${this.sectRole}!`, 'success');
                    } else {
                        displayMessage(`Joined ${Game.sects[sectId].name}! (Role not immediately set, check sect data)`, 'narration'); // Fallback
                    }
                } else { displayMessage("Sect not found.", 'error'); }
                updateStatsDisplay(this);
                Game.saveCurrentPlayerState();
            }
            leaveSect() {
                if (this.sectId && Game.sects[this.sectId]) {
                    const sectName = Game.sects[this.sectId].name;
                    Game.sects[this.sectId].removeMember(this.playerId); this.sectId = null;
                    this.sectRole = null; // Clear the role when leaving sect
                    displayMessage(`Left ${sectName}.`, 'narration');
                } else { displayMessage("Not in a sect.", 'error'); }
                updateStatsDisplay(this);
                Game.saveCurrentPlayerState();
            }
        }

        class Monster extends Character {
            constructor(name, health, str, agi, con, spr, intl, wil, cultivationLevel, xpReward, tamable = false, image = null) { 
                super(name, str, agi, con, spr, intl, wil, cultivationLevel); 
                this.xpReward = xpReward;
                this.spiritualRootMultiplier = 1; 
                this.tamable = tamable; 
                this.image = image;

                // Monsters have their health set directly from data, not derived like players initially
                this.maxHealth = health; // Use the direct health value for maxHealth
                this.health = health;
                // Qi can be derived or set if monsters use it (currently derived)
                this.maxQi = this.calculateMaxQi(); 
                this.currentQi = this.maxQi;
            }

            // Monsters use base Character's getTotalAttack and getPhysicalDefense,
            // which are derived from their STR and CON.
            // No need to override unless they have special mechanics.

            getCultivationRealmName() { 
                if (this.cultivationLevel < 5) return "Weak Beast";
                if (this.cultivationLevel < 15) return "Fierce Beast";
                if (this.cultivationLevel < 25) return "Demonic Beast";
                if (this.cultivationLevel < 35) return "Spirit Beast";
                return "Ancient Terror";
            }
            getLootDrops(player) {
                let loot = [];
                const currentAreaKey = Game.currentExploringAreaKey; // Relies on this being set
                const monsterRealmTier = Game.getRealmTier(this.cultivationLevel);

                // Common drops (can retain some player level scaling for spirit stones, or be fixed)
                if (Math.random() < 0.7) { 
                    const stonesFound = Math.floor(Math.random() * (Game.getRealmTier(player.cultivationLevel) * 2)) + Game.getRealmTier(player.cultivationLevel); 
                    loot.push({itemId: 'spiritStones', quantity: stonesFound});
                }
                if (Math.random() < 0.5) { loot.push({itemId: 'spiritStoneFragment', quantity: 1});}
                if (Math.random() < 0.25) { loot.push({itemId: 'monsterCoreWeak', quantity: 1});}
                if (Math.random() < 0.15 && Game.getRealmTier(player.cultivationLevel) > 1) { loot.push({itemId: 'beastBoneFragment', quantity: 1});}
                
                // Area-specific loot from the monster's current location
                if (currentAreaKey && Game.EXPLORATION_AREAS[currentAreaKey] && Game.EXPLORATION_AREAS[currentAreaKey].lootTable) {
                    const areaLootTable = Game.EXPLORATION_AREAS[currentAreaKey].lootTable;
                    areaLootTable.forEach(lootEntry => {
                        if (Math.random() < lootEntry.chance) {
                            const quantity = Math.floor(Math.random() * (lootEntry.maxQuantity - lootEntry.minQuantity + 1)) + lootEntry.minQuantity;
                            const itemData = Game.ITEM_DATA[lootEntry.itemId];

                            // Handle recipes specifically
                            if (itemData && itemData.type === 'recipe') {
                                const recipeItemKey = lootEntry.itemId;
                                const recipeLearnsKey = itemData.learnsRecipeKey;
                                const pillRecipe = Game.PILL_RECIPES[recipeLearnsKey];
                                let canDropRecipe = true;
                                if (pillRecipe) { // Check player level relevance for recipes
                                    canDropRecipe = player.cultivationLevel >= (pillRecipe.requiredCultivationLevel - 8) && // Adjusted range
                                                    player.cultivationLevel <= (pillRecipe.requiredCultivationLevel + 8);  // Adjusted range
                                } else {
                                    console.warn(`Recipe ${recipeLearnsKey} for item ${recipeItemKey} not found in Game.PILL_RECIPES.`);
                                    canDropRecipe = false;
                                }

                                if (canDropRecipe && (!player.knownRecipes || !player.knownRecipes.includes(recipeLearnsKey)) && (!player.resources[recipeItemKey] || player.resources[recipeItemKey] < 1)) {
                                    loot.push({itemId: recipeItemKey, quantity: quantity});
                                }
                            } else if (itemData && itemData.type !== 'refining_material') { // For non-recipe and non-refining_material items from area table
                                loot.push({itemId: lootEntry.itemId, quantity: quantity});
                            }
                        }
                    });
                } else {
                    console.warn(`Monster defeated in area '${currentAreaKey}' which has no lootTable, or currentExploringAreaKey not set. Skipping area-specific loot.`);
                }

                // --- Artifact Refining Material Drops ---
                // Monsters will have a chance to drop refining materials appropriate to their tier.
                const REFINING_MATERIAL_GENERAL_DROP_CHANCE = 0.65; // Increased from 0.50
                const REFINING_MATERIAL_PER_TIER_CHANCE = 0.8;  // Increased from 0.7

                if (this.cultivationLevel >= 1 && Math.random() < REFINING_MATERIAL_GENERAL_DROP_CHANCE) {
                    for (let tier = 1; tier <= monsterRealmTier; tier++) { // Iterate from Tier 1 up to monster's tier
                        if (Math.random() < REFINING_MATERIAL_PER_TIER_CHANCE) {
                            const materialsOfThisTier = [];
                            for (const itemKey in Game.ITEM_DATA) {
                                const item = Game.ITEM_DATA[itemKey];
                                if (item.type === 'refining_material' && item.tier === tier) { // item.tier > 0 is implicit here
                                    materialsOfThisTier.push(itemKey);
                                }
                            }
                            if (materialsOfThisTier.length > 0) {
                                const chosenItemKey = materialsOfThisTier[Math.floor(Math.random() * materialsOfThisTier.length)];
                                if (!loot.find(l => l.itemId === chosenItemKey)) { // Avoid duplicates from this specific logic block
                                    loot.push({ itemId: chosenItemKey, quantity: 1 });
                                }
                            }
                        }
                    }
                }

                // --- Demon Core Drop ---
                // Monsters at Core Formation (Tier 3, level 19+) and above have a chance to drop Demon Cores.
                const DEMON_CORE_DROP_CHANCE = 0.15; // 15% chance
                if (this.cultivationLevel >= 19 && Math.random() < DEMON_CORE_DROP_CHANCE) {
                    if (!loot.find(l => l.itemId === 'demonCore')) { // Ensure not already added if it somehow got in via area loot
                        loot.push({ itemId: 'demonCore', quantity: 1 });
                    }
                }

                return loot;
            }
        }

        class Sect {
            constructor(name, founderId, founderName, description = "A mysterious sect.", motto = "Cultivate and Ascend!", location = "Unspecified Region", bannerUrl = null) {
                this.sectId = Game.generateId(); // This will be overwritten by Firestore doc ID if loaded
                this.name = name;
                this.founderId = founderId;
                this.founderName = founderName; // Store founder's name for convenience
                this.description = description;
                this.motto = motto;
                this.location = location;
                this.bannerUrl = bannerUrl; // URL to an image or null
                this.createdAt = firebase.firestore.FieldValue.serverTimestamp(); // For new sects

                this.buffs = []; // Array of { type, value, description }
                
                // Members: object where key is playerId, value is { playerName, role, joinedAt, contributionPoints }
                this.members = {
                    [founderId]: {
                        playerName: founderName,
                        role: "Founder",
                        joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        contributionPoints: 0 // Initialize contribution points
                    }
                };
                
                this.ranks = JSON.parse(JSON.stringify(Game.DEFAULT_SECT_RANKS || [])); // Deep copy default ranks
                
                this.treasury = { // Example resources
                    spiritStones: 0
                    // commonHerbs: 0, etc.
                };
                
                this.totalContributionPoints = 0; // Sum of all members' contributions
                this.contributionLogs = []; // Array of { playerId, playerName, action, details, timestamp }

                this.sectPower = 0; // Placeholder for now
            }

            addMember(playerId, playerName, role = "Outer Disciple") {
                if (this.members[playerId]) {
                    displayMessage(`${playerName} is already a member of ${this.name}.`, 'narration');
                    return;
                }
                // Determine the actual role based on sect rules or default
                const defaultNewMemberRank = this.ranks.find(r => r.isDefaultNewMember) || this.ranks.find(r => r.name === "Outer Disciple");
                const assignedRole = role === "Founder" ? "Founder" : (defaultNewMemberRank ? defaultNewMemberRank.name : "Outer Disciple");

                this.members[playerId] = {
                    playerName: playerName,
                    role: assignedRole,
                    joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    contributionPoints: 0 // New members start with 0 contribution
                };
                displayMessage(`${playerName} (${assignedRole}) has joined the ${this.name} sect!`, 'success');
                this.updateSectPower();
                Game.saveSectData(this.sectId); // Save sect data after modification
            }

            removeMember(playerId) {
                if (this.members[playerId]) {
                    const memberName = this.members[playerId].playerName || "A member";
                    // Cannot remove founder easily, or last member (disband logic)
                    if (playerId === this.founderId && Object.keys(this.members).length > 1) {
                        displayMessage(`The founder ${memberName} cannot leave the sect while other members remain. Transfer leadership first.`, 'error');
                        return;
                    }
                    delete this.members[playerId];
                    displayMessage(`${memberName} has left the ${this.name} sect.`, 'narration');
                    this.updateSectPower();

                    if (Object.keys(this.members).length === 0) {
                        displayMessage(`Sect ${this.name} has been disbanded as the last member left.`, 'important');
                        delete Game.sects[this.sectId]; // Remove from local cache
                        // TODO: Add logic to delete or mark as disbanded in Firestore
                        db.collection("sects").doc(this.sectId).delete().catch(err => console.error("Error disbanding sect in DB:", err));
                    } else {
                        Game.saveSectData(this.sectId); // Save sect data
                    }
                } else {
                    displayMessage(`Player ID ${playerId} not found in sect ${this.name}.`, 'error');
                }
            }

            updateSectPower() { /* Placeholder */ }

            toFirestoreObject() {
                // Ensure serverTimestamps are handled correctly if they haven't been set yet
                const membersForFirestore = {};
                for (const pid in this.members) {
                    membersForFirestore[pid] = {
                        ...this.members[pid],
                        joinedAt: this.members[pid].joinedAt instanceof firebase.firestore.Timestamp ? this.members[pid].joinedAt : firebase.firestore.FieldValue.serverTimestamp()
                    };
                }

                return {
                    name: this.name,
                    founderId: this.founderId,
                    founderName: this.founderName,
                    description: this.description,
                    motto: this.motto,
                    location: this.location,
                    bannerUrl: this.bannerUrl,
                    createdAt: this.createdAt instanceof firebase.firestore.Timestamp ? this.createdAt : firebase.firestore.FieldValue.serverTimestamp(),
                    buffs: this.buffs,
                    members: membersForFirestore,
                    ranks: this.ranks,
                    treasury: this.treasury,
                    totalContributionPoints: this.totalContributionPoints,
                    contributionLogs: this.contributionLogs.slice(-50) // Store only recent logs to avoid large docs
                    // sectPower is client-side or calculated, not stored directly unless necessary
                };
            }
            static fromFirestoreObject(docData, sectId) { // Ensure sectId is passed and used
                const sect = new Sect(docData.name, docData.founderId, docData.founderName, docData.description, docData.motto, docData.location, docData.bannerUrl);
                Object.assign(sect, docData);
                sect.sectId = sectId; // Make sure this is set correctly
                sect.createdAt = docData.createdAt; // This should be a Firestore Timestamp
                // Ensure members and ranks are properly initialized if they might be undefined
                sect.members = sect.members || {};
                sect.ranks = sect.ranks || JSON.parse(JSON.stringify(Game.DEFAULT_SECT_RANKS || []));
                sect.treasury = sect.treasury || { spiritStones: 0 };
                sect.contributionLogs = sect.contributionLogs || [];
                return sect;
            }

            logContribution(playerId, playerName, action, details, amount = 0) {
                this.contributionLogs.unshift({ 
                    playerId: playerId,
                    playerName: playerName,
                    action: action, 
                    details: details, 
                    amount: amount, 
                    timestamp: new Date() 
                });
                if (this.contributionLogs.length > 100) { this.contributionLogs.pop(); }
            }
        }

        const Game = {
            players: {}, sects: {}, currentPlayerId: null, currentCombat: null, currentGameState: 'MAIN_GATE', 
            selectedClassForInfo: null, 
            currentExploringAreaKey: null, // For dedicated exploration
            tempTransactionData: null, 
            tempAttributeAllocations: {}, // For storing {str: increment, agi: increment, ...}
            DEFAULT_SECT_RANKS: [
                { 
                    name: "Founder", 
                    permissions: ["all"], // "all" covers everything implicitly
                    minContribution: 0, isDefaultNewMember: false, isFounder: true 
                },
                { 
                    name: "Elder", 
                    permissions: [
                        "invite_member", "kick_member_lower_rank", 
                        "promote_member_lower_rank", "demote_member_lower_rank", // Changed for clarity
                        "manage_treasury", "set_motto", "edit_description",
                        "accept_new_member", "start_sect_event",
                        "buy_from_sect_shop", "donate_to_treasury" // Elders can also do what lower ranks do
                    ], 
                    minContribution: 10000, isDefaultNewMember: false 
                },
                { 
                    name: "Core Disciple", 
                    permissions: [
                        "access_sect_storage_read", "access_sect_buffs", // Existing
                        "buy_from_sect_shop", "donate_to_treasury"
                    ], 
                    minContribution: 5000, isDefaultNewMember: false 
                },
                { 
                    name: "Inner Disciple", 
                    permissions: ["buy_from_sect_shop", "donate_to_treasury"], 
                    minContribution: 1000, isDefaultNewMember: true // Default for new members
                },
                { name: "Outer Disciple", permissions: ["donate_to_treasury"], minContribution: 100, isDefaultNewMember: false }
            ],


            initialFreeAttributePointsForSession: 0, // Points at start of allocation session
            PILL_RECIPES: {}, 
            chatMessagesListener: null,

            ITEM_DATA: {
                // ... (existing item data)
            },

            MONSTER_DATA: {
                // Realm 1: Qi Condensation
                "qiWisp": { name: "Qi Wisp", health: 20, str: 2, agi: 3, con: 0, spr: 5, intl: 1, wil: 1, cultivationLevel: 1, xpReward: 15, tamable: true, image: "assets/monsters/Qi_Wisp.png" },
                "snakeVine": { name: "Snake Vine", health: 30, str: 3, agi: 2, con: 1, spr: 1, intl: 1, wil: 2, cultivationLevel: 3, xpReward: 20, tamable: false, image: "assets/monsters/Snake_Vine.png" },
                "cloudGecko": { name: "Cloud Gecko", health: 25, str: 2, agi: 4, con: 2, spr: 2, intl: 1, wil: 1, cultivationLevel: 2, xpReward: 18, tamable: true, image: "assets/monsters/Cloud_Gecko.png" },
                "rockshellTortoise": { name: "Rockshell Tortoise", health: 50, str: 1, agi: 1, con: 5, spr: 1, intl: 1, wil: 3, cultivationLevel: 4, xpReward: 25, tamable: true, image: "assets/monsters/Rockshell_Tortoise.png" },
                "mistLeopardCub": { name: "Mist Leopard Cub", health: 35, str: 3, agi: 5, con: 1, spr: 2, intl: 2, wil: 2, cultivationLevel: 5, xpReward: 30, tamable: true, image: "assets/monsters/Mist_Leopard_Cub.png" },
                "spiritBat": { name: "Spirit Bat", health: 20, str: 4, agi: 6, con: 0, spr: 3, intl: 1, wil: 1, cultivationLevel: 4, xpReward: 22, tamable: false, image: "assets/monsters/Spirit_Bat.png" },
                "boneAnt": { name: "Bone Ant", health: 15, str: 2, agi: 3, con: 1, spr: 1, intl: 1, wil: 1, cultivationLevel: 6, xpReward: 20, tamable: false, image: "assets/monsters/Bone_Ant.png" },
                "leafbladeSerpent": { name: "Leafblade Serpent", health: 40, str: 4, agi: 5, con: 2, spr: 2, intl: 2, wil: 2, cultivationLevel: 7, xpReward: 35, tamable: false, image: "assets/monsters/Leafblade_Serpent.png" },
                "phantomBeetle": { name: "Phantom Beetle", health: 30, str: 3, agi: 4, con: 3, spr: 3, intl: 1, wil: 2, cultivationLevel: 8, xpReward: 30, tamable: false, image: "assets/monsters/Phantom_Beetle.png" },

                // Realm 2: Foundation Establishment
                "firefangTiger": { name: "Firefang Tiger", health: 80, str: 6, agi: 7, con: 3, spr: 4, intl: 3, wil: 4, cultivationLevel: 10, xpReward: 50, tamable: true, image: "assets/monsters/Firefang_Tiger.png" },
                "flameSalamander": { name: "Flame Salamander", health: 70, str: 5, agi: 5, con: 5, spr: 6, intl: 2, wil: 3, cultivationLevel: 11, xpReward: 45, tamable: true, image: "assets/monsters/Flame_Salamander.png" },
                "moltenRockApe": { name: "Molten Rock Ape", health: 100, str: 8, agi: 4, con: 4, spr: 3, intl: 2, wil: 5, cultivationLevel: 12, xpReward: 60, tamable: false, image: "assets/monsters/Molten_Rock_Ape.png" },
                "moonlitOwl": { name: "Moonlit Owl", health: 60, str: 5, agi: 8, con: 2, spr: 7, intl: 4, wil: 3, cultivationLevel: 13, xpReward: 40, tamable: true, image: "assets/monsters/Moonlit_Owl.png" },
                "whisperingSpecter": { name: "Whispering Specter", health: 75, str: 6, agi: 7, con: 1, spr: 8, intl: 3, wil: 4, cultivationLevel: 14, xpReward: 55, tamable: false, image: "assets/monsters/Whispering_Specter.png" },
                "echoWraith": { name: "Echo Wraith", health: 90, str: 7, agi: 6, con: 3, spr: 7, intl: 3, wil: 5, cultivationLevel: 15, xpReward: 65, tamable: false, image: "assets/monsters/Echo_Wraith.png" },

                // Realm 3: Core Formation
                "sandDevourerScorpion": { name: "Sand Devourer Scorpion", health: 160, str: 13, agi: 10, con: 8, spr: 6, intl: 4, wil: 7, cultivationLevel: 19, xpReward: 90, tamable: false, image: "assets/monsters/Sand_Devourer_Scorpion.png" },
                "mirageCrawler": { name: "Mirage Crawler", health: 140, str: 11, agi: 12, con: 6, spr: 7, intl: 5, wil: 6, cultivationLevel: 20, xpReward: 85, tamable: false, image: "assets/monsters/Mirage_Crawler.png" },
                "sunfireVulture": { name: "Sunfire Vulture", health: 150, str: 14, agi: 11, con: 5, spr: 8, intl: 4, wil: 7, cultivationLevel: 21, xpReward: 100, tamable: true, image: "assets/monsters/Sunfire_Vulture.png" },
                "icehowlWolf": { name: "Icehowl Wolf", health: 170, str: 13, agi: 10, con: 7, spr: 7, intl: 4, wil: 8, cultivationLevel: 22, xpReward: 95, tamable: true, image: "assets/monsters/Icehowl_Wolf.png" },
                "frostbiteBear": { name: "Frostbite Bear", health: 200, str: 15, agi: 8, con: 10, spr: 5, intl: 3, wil: 9, cultivationLevel: 23, xpReward: 120, tamable: false, image: "assets/monsters/Frostbite_Bear.png" },
                "crystallineSpiritMoth": { name: "Crystalline Spirit Moth", health: 130, str: 10, agi: 13, con: 4, spr: 10, intl: 6, wil: 5, cultivationLevel: 24, xpReward: 80, tamable: true, image: "assets/monsters/Crystalline_Spirit_Moth.png" },

                // Realm 4: Nascent Soul
                "voidEyedToad": { name: "Void-Eyed Toad", health: 300, str: 20, agi: 15, con: 15, spr: 12, intl: 8, wil: 10, cultivationLevel: 28, xpReward: 160, tamable: false, image: "assets/monsters/Void-Eyed_Toad.png" },
                "ghoulWillOWisp": { name: "Ghoul Will-O-Wisp", health: 250, str: 18, agi: 18, con: 10, spr: 15, intl: 10, wil: 12, cultivationLevel: 29, xpReward: 150, tamable: false, image: "assets/monsters/Ghoul_Will-O-Wisp.png" },
                "murkSerpent": { name: "Murk Serpent", health: 320, str: 23, agi: 16, con: 12, spr: 10, intl: 7, wil: 11, cultivationLevel: 30, xpReward: 180, tamable: false, image: "assets/monsters/Murk_Serpent.png" },
                "stormdrakeHatchling": { name: "Stormdrake Hatchling", health: 350, str: 25, agi: 20, con: 18, spr: 18, intl: 12, wil: 15, cultivationLevel: 31, xpReward: 200, tamable: true, image: "assets/monsters/Stormdrake_Hatchling.png" },
                "thunderclapApe": { name: "Thunderclap Ape", health: 380, str: 28, agi: 18, con: 16, spr: 15, intl: 10, wil: 16, cultivationLevel: 32, xpReward: 220, tamable: false, image: "assets/monsters/Thunderclap_Ape.png" },
                "skySerpent": { name: "Sky Serpent", health: 330, str: 24, agi: 22, con: 14, spr: 20, intl: 14, wil: 14, cultivationLevel: 33, xpReward: 190, tamable: true, image: "assets/monsters/Sky_Serpent.png" },

                // Realm 5: Soul Formation
                "blackflameShade": { name: "Blackflame Shade", health: 500, str: 33, agi: 30, con: 22, spr: 25, intl: 18, wil: 20, cultivationLevel: 37, xpReward: 320, tamable: false, image: "assets/monsters/Blackflame_Shade.png" },
                "soulEaterWasp": { name: "Soul-Eater Wasp", health: 450, str: 35, agi: 35, con: 18, spr: 28, intl: 20, wil: 22, cultivationLevel: 38, xpReward: 300, tamable: false, image: "assets/monsters/Soul-Eater_Wasp.png" },
                "ashPhoenixFragment": { name: "Ash Phoenix Fragment", health: 550, str: 30, agi: 28, con: 25, spr: 30, intl: 22, wil: 25, cultivationLevel: 39, xpReward: 350, tamable: false, image: "assets/monsters/Ash_Phoenix_Fragment.png" },
                "enlightenedSprite": { name: "Enlightened Sprite", health: 400, str: 28, agi: 32, con: 20, spr: 35, intl: 28, wil: 24, cultivationLevel: 40, xpReward: 280, tamable: true, image: "assets/monsters/Enlightened_Sprite.png" },
                "lotusPuppetMonk": { name: "Lotus Puppet Monk", health: 600, str: 38, agi: 25, con: 30, spr: 20, intl: 15, wil: 30, cultivationLevel: 41, xpReward: 400, tamable: false, image: "assets/monsters/Lotus_Puppet_Monk.png" },
                "spiralMindLeech": { name: "Spiral Mind Leech", health: 480, str: 40, agi: 30, con: 15, spr: 38, intl: 30, wil: 28, cultivationLevel: 42, xpReward: 380, tamable: false, image: "assets/monsters/Spiral_Mind_Leech.png" },

                // Realm 6: Transcendent
                "starboundChimera": { name: "Starbound Chimera", health: 800, str: 50, agi: 45, con: 40, spr: 40, intl: 30, wil: 35, cultivationLevel: 46, xpReward: 550, tamable: false, image: "assets/monsters/Starbound_Chimera.png" },
                "heavenpiercerLion": { name: "Heavenpiercer Lion", health: 900, str: 55, agi: 40, con: 45, spr: 35, intl: 28, wil: 40, cultivationLevel: 47, xpReward: 600, tamable: false, image: "assets/monsters/Heavenpiercer_Lion.png" },
                "timeBendingFox": { name: "Time-Bending Fox", health: 750, str: 45, agi: 55, con: 35, spr: 50, intl: 40, wil: 38, cultivationLevel: 48, xpReward: 500, tamable: true, image: "assets/monsters/Time-Bending_Fox.png" },
                "daoFragmentWraith": { name: "Dao Fragment Wraith", health: 1000, str: 60, agi: 35, con: 30, spr: 60, intl: 35, wil: 50, cultivationLevel: 49, xpReward: 700, tamable: false, image: "assets/monsters/Dao_Fragment_Wraith.png" },
                "crumblingGuardian": { name: "Crumbling Guardian", health: 1200, str: 50, agi: 30, con: 60, spr: 30, intl: 25, wil: 45, cultivationLevel: 50, xpReward: 650, tamable: false, image: "assets/monsters/Crumbling_Guardian.png" },
                "realityScar": { name: "Reality Scar", health: 850, str: 65, agi: 40, con: 25, spr: 55, intl: 30, wil: 40, cultivationLevel: 51, xpReward: 750, tamable: false, image: "assets/monsters/Reality_Scar.png" }
            },



            ITEM_DATA: {
                "commonHerbs": { name: "Common Herbs", description: "Basic herbs for alchemy.", type: "material", tier: 1, gameAsset: 'commonHerbs.png' },
                "roughIronOre": { name: "Rough Iron Ore", description: "Unrefined ore for forging.", type: "material", tier: 1, gameAsset: 'roughIronOre.png' },
                "blankTalismanPaper": { name: "Blank Talisman Paper", description: "Paper for drawing talismans.", type: "material", tier: 1, gameAsset: 'blankTalismanPaper.png' },
                "monsterCoreWeak": { name: "Monster Core (Weak)", description: "A weak core from a defeated monster.", type: "material", tier: 1, gameAsset: 'monsterCoreWeak.png' },
                "beastBoneFragment": { name: "Beast Bone Fragment", description: "A fragment of a beast's bone.", type: "material", tier: 2, gameAsset: 'beastBoneFragment.png' },
                "spiritDust": { name: "Spirit Dust", description: "Residue with faint spiritual energy.", type: "material", tier: 2, gameAsset: 'spiritDust.png' },
                "spiritStoneFragment": { name: "Spirit Stone Fragment", description: "A small piece of a spirit stone.", type: "material", tier: 1, gameAsset: 'spiritStoneFragment.png' },
                "spiritStones": { name: "Spirit Stones", description: "Currency of the cultivation world.", type: "currency", gameAsset: 'spiritStones.png' },
                
                "minorHealingPill": { name: "Minor Healing Pill", description: "Restores a small amount of health.", type: "consumable", gameAsset: 'minorHealingPill.png', effect: (player) => { const heal = 25; player.health = Math.min(player.maxHealth, player.health + heal); displayMessage(`Used Minor Healing Pill. Restored ${heal} HP.`, "item-use"); player.resources.minorHealingPill--; updateStatsDisplay(player); Game.saveCurrentPlayerState();}, usableInCombat: true },
                "minorQiPill": { name: "Minor QI Pill", description: "Restores a small amount of QI.", type: "consumable", gameAsset: 'minorQiPill.png', effect: (player) => { const qiRestore = 20; player.currentQi = Math.min(player.maxQi, player.currentQi + qiRestore); displayMessage(`Used Minor QI Pill. Restored ${qiRestore} QI.`, "item-use"); player.resources.minorQiPill--; updateStatsDisplay(player); Game.saveCurrentPlayerState();}, usableInCombat: true },
                "roughSword": { name: "Rough Sword", description: "A crudely made sword. Phys. Attack +5.", type: "weapon", weaponPhysicalAttackBonus: 5, gameAsset: 'roughSword.png', equipEffect: (player) => { player.equippedWeapon = "roughSword"; player.weaponPhysicalAttackBonus = 5; displayMessage("Equipped Rough Sword.", "item-use"); updateStatsDisplay(player); Game.saveCurrentPlayerState(); } },
                "minorFireTalisman": { name: "Minor Fire Talisman", description: "Unleashes a small burst of fire. (10 QI)", type: "talisman", qiCost: 10, baseDamage: 15, gameAsset: 'minorFireTalisman.png', effectInCombat: (player, opponent) => { if (player.currentQi >= 10) { player.currentQi -= 10; const spellDamage = Game.ITEM_DATA.minorFireTalisman.baseDamage + Math.floor(player.getSpellPower() / 2); displayCombatAction(`${player.name} uses a Minor Fire Talisman!`, "combat-text-player-action"); const damageResult = opponent.takeDamage(spellDamage); appendCombatAction(damageResult.message, damageResult.style); updateStatsDisplay(player); Game.saveCurrentPlayerState(); return true;} else { appendCombatAction("Not enough QI to use Fire Talisman!", "error"); return false;} } },

                "jadeleafGrass": { name: "Jadeleaf Grass", description: "Common herb that mildly restores qi.", type: "material", tier: 1, gameAsset: 'jadeleafGrass.png' },
                "crimsonSpiritBerry": { name: "Crimson Spirit Berry", description: "Used for blood regeneration and minor injuries.", type: "material", tier: 1, gameAsset: 'crimsonSpiritBerry.png' },
                "soothingRainPetal": { name: "Soothing Rain Petal", description: "Calms qi deviation; heals minor spiritual wounds.", type: "material", tier: 2, gameAsset: 'soothingRainPetal.png' },
                "moondewFlower": { name: "Moondew Flower", description: "A gentle restorative for mind and body.", type: "material", tier: 2, gameAsset: 'moondewFlower.png' },
                "earthrootGinseng": { name: "Earthroot Ginseng", description: "Recovers qi and physical stamina.", type: "material", tier: 3, gameAsset: 'earthrootGinseng.png' },
                "skyLotusBud": { name: "Sky Lotus Bud", description: "Advanced qi restoration, often used by Core cultivators.", type: "material", tier: 4, gameAsset: 'skyLotusBud.png' },
                "whisperingLeaf": { name: "Whispering Leaf", description: "Promotes faster energy circulation during rest.", type: "material", tier: 3, gameAsset: 'whisperingLeaf.png' },
                "radiantSunfruit": { name: "Radiant Sunfruit", description: "Restores both qi and vitality rapidly.", type: "material", tier: 4, gameAsset: 'radiantSunfruit.png' },
                "cloudmossVine": { name: "Cloudmoss Vine", description: "Stimulates spiritual veins; best for Nascent Soul users.", type: "material", tier: 5, gameAsset: 'cloudmossVine.png' },
                "spiritglowMushroom": { name: "Spiritglow Mushroom", description: "Heals internal meridian damage.", type: "material", tier: 5, isRare: true, gameAsset: 'spiritglowMushroom.png' },

                "breakthroughVine": { name: "Breakthrough Vine", description: "Helps cultivators leap into Foundation Establishment.", type: "material", tier: 1, isRare: true, forRealmBreak: 2, gameAsset: 'breakthroughVine.png' }, 
                "dragonboneFern": { name: "Dragonbone Fern", description: "Used in pills to stabilize Core Formation.", type: "material", tier: 2, isRare: true, forRealmBreak: 3, gameAsset: 'dragonboneFern.png' }, 
                "phoenixbloodHerb": { name: "Phoenixblood Herb", description: "Burns away impurities; ideal for advancing into Nascent Soul.", type: "material", tier: 3, isRare: true, forRealmBreak: 4, gameAsset: 'phoenixbloodHerb.png' }, 
                "ascensionOrchid": { name: "Ascension Orchid", description: "Rare orchid that assists in Soul Formation breakthroughs.", type: "material", tier: 4, isRare: true, forRealmBreak: 5, gameAsset: 'ascensionOrchid.png' }, 
                "heavenpierceRoot": { name: "Heavenpierce Root", description: "Violently clears bottlenecks; high risk, high reward.", type: "material", tier: 4, isRare: true, forRealmBreak: 5, gameAsset: 'heavenpierceRoot.png' }, 
                "divineFlameGrass": { name: "Divine Flame Grass", description: "Contains pure yang energy; used for fiery breakthroughs.", type: "material", tier: 3, isRare: true, gameAsset: 'divineFlameGrass.png' }, 
                "lunarBloom": { name: "Lunar Bloom", description: "Yin energy concentrated herb, used in realm balance pills.", type: "material", tier: 3, isRare: true, gameAsset: 'lunarBloom.png' }, 
                "immortalDustleaf": { name: "Immortal Dustleaf", description: "Needed for Transcendence Elixirs.", type: "material", tier: 5, isRare: true, forRealmBreak: 6, gameAsset: 'immortalDustleaf.png' }, 
                "voidberryThorn": { name: "Voidberry Thorn", description: "Bitter but crucial for soul ascension.", type: "material", tier: 5, isRare: true, forRealmBreak: 6, gameAsset: 'voidberryThorn.png' },
                "thunderclapFruit": { name: "Thunderclap Fruit", description: "Shocks dantian to force enlightenment at high realms.", type: "material", tier: 5, isRare: true, gameAsset: 'thunderclapFruit.png' },
                
                "starforgePetal": { name: "Starforge Petal", description: "A petal that glimmers with starlight.", type: "material", tier: 4, gameAsset: 'starforgePetal.png' },
                "stoneheartRoot": { name: "Stoneheart Root", description: "A root as hard as stone, imbued with earth essence.", type: "material", tier: 4, gameAsset: 'stoneheartRoot.png' },
                "spiritEyeFlower": { name: "Spirit-Eye Flower", description: "A flower that seems to gaze into the spiritual realm.", type: "material", tier: 3, gameAsset: 'spiritEyeFlower.png' },
                "heartblossomBud": { name: "Heartblossom Bud", description: "A bud said to open one's heart to spiritual senses.", type: "material", tier: 3, gameAsset: 'heartblossomBud.png' },
                "silverstormLeaf": { name: "Silverstorm Leaf", description: "A leaf that moves with incredible speed, even in stillness.", type: "material", tier: 3, gameAsset: 'silverstormLeaf.png' },
                "goldenDantianFruit": { name: "Golden Dantian Fruit", description: "A fruit believed to strengthen a cultivator's core.", type: "material", tier: 4, gameAsset: 'goldenDantianFruit.png' },
                "blackflameGinseng": { name: "Blackflame Ginseng", description: "Ginseng that smolders with dark fire.", type: "material", tier: 4, isRare: true, gameAsset: 'blackflameGinseng.png' },
                "frostmarrowMoss": { name: "Frostmarrow Moss", description: "Moss that chills to the bone, yet preserves essence.", type: "material", tier: 4, isRare: true, gameAsset: 'frostmarrowMoss.png' },
                "demonCore": { name: "Demon Core", description: "A core from a defeated demon, required for all artifact refining.", type: "material", tier: 0, isRare: true, gameAsset: 'assets/mats/demon_core.png' }, // Universal Tier 0 material

                // Artifact Refining Materials
                "spiritOreFragment": { name: "Spirit Ore Fragment", description: "Fragment of ore with faint spiritual energy.", type: "refining_material", tier: 1, gameAsset: 'assets/mats/spirit_ore_fragment.png' },
                "enchantedStoneDust": { name: "Enchanted Stone Dust", description: "Dust from enchanted stones, used to imbue magical properties.", type: "refining_material", tier: 1, gameAsset: 'assets/mats/enchanted_stone_dust.png' },
                "minorQiConductor": { name: "Minor Qi Conductor", description: "A material that conducts small amounts of Qi, enhancing artifact effects.", type: "refining_material", tier: 1, gameAsset: 'assets/mats/minor_qi_conductor.png' },

                "refinedSpiritOre": { name: "Refined Spirit Ore", description: "Spirit ore refined to improve its purity and conductivity.", type: "refining_material", tier: 2, gameAsset: 'refined_spirit_ore.png' },
                "moonsteelFragment": { name: "Moonsteel Fragment", description: "A fragment of moonsteel, known for its ability to store spiritual energy.", type: "refining_material", tier: 2, gameAsset: 'moonsteel_fragment.png' },
                "stabilizingRuneDust": { name: "Stabilizing Rune Dust", description: "Dust from runes used to stabilize and control magical flow in artifacts.", type: "refining_material", tier: 2, gameAsset: 'stabilizing_rune_dust.png' },

                "spiritAlloyShard": { name: "Spirit Alloy Shard", description: "A shard of spirit alloy, a stronger material for more powerful artifacts.", type: "refining_material", tier: 3, gameAsset: 'spirit_alloy_shard.png' },
                "frostIronOre": { name: "Frost-Iron Ore", description: "Ore infused with frost magic, enhancing cold-based or defensive artifacts.", type: "refining_material", tier: 3, gameAsset: 'frost_iron_ore.png' },
                "heatLinkedLens": { name: "Heat-Linked Lens", description: "A lens that channels heat and fire, used in offensive or fire-based artifacts.", type: "refining_material", tier: 3, gameAsset: 'heat_linked_lens.png' },

                "voidsteelFragment": { name: "Voidsteel Fragment", description: "A fragment of voidsteel, a mysterious material with unique properties.", type: "refining_material", tier: 4, gameAsset: 'voidsteel_fragment.png' },
                "lightningChargedPlate": { name: "Lightning-Charged Plate", description: "A plate that stores and conducts lightning, used to electrify or speed up artifacts.", type: "refining_material", tier: 4, gameAsset: 'lightning_charged_plate.png' },
                "soulEchoDust": { name: "Soul-Echo Dust", description: "Dust that resonates with souls, used to create artifacts that interact with spirits or souls.", type: "refining_material", tier: 4, gameAsset: 'soul_echo_dust.png' },

                "celestialAlloyChunk": { name: "Celestial Alloy Chunk", description: "A chunk of celestial alloy, an incredibly strong and conductive material.", type: "refining_material", tier: 5, gameAsset: 'celestial_alloy_chunk.png' },
                "phantomSilver": { name: "Phantom Silver", description: "A type of silver that interacts with the ethereal plane, useful for soul-based artifacts.", type: "refining_material", tier: 5, gameAsset: 'phantom_silver.png' },
                "echoCrystalSlab": { name: "Echo Crystal Slab", description: "A slab of crystal that echoes magical energy, amplifying artifact effects.", type: "refining_material", tier: 5, gameAsset: 'echo_crystal_slab.png' },

                "heavensteelCore": { name: "Heavensteel Core", description: "A core of heavensteel, an artifact material of legendary strength and power.", type: "refining_material", tier: 6, gameAsset: 'heavensteel_core.png' },
                "etherealJadeite": { name: "Ethereal Jadeite", description: "Jadeite that resonates with the ethereal plane, used for the most advanced soul artifacts.", type: "refining_material", tier: 6, gameAsset: 'ethereal_jadeite.png' },
                "originiteShard": { name: "Originite Shard", description: "A shard of originite, a material said to contain the original magical source.", type: "refining_material", tier: 6, gameAsset: 'originite_shard.png' },


                "harmonizingBellvine": { name: "Harmonizing Bellvine", description: "A vine whose flowers chime with balancing energies.", type: "material", tier: 5, gameAsset: 'harmonizingBellvine.png' },
                "eyeOfTheAncients": { name: "Eye of the Ancients", description: "A petrified eye that seems to hold ancient knowledge.", type: "material", tier: 5, isRare: true, gameAsset: 'eyeOfTheAncients.png' },

                // Qi Condensation Tier Equipment Sets - Spiritbound Set
                "spiritboundBlade": {
                    name: "Spiritbound Blade",
                    description: "A blade infused with nascent spirit energy. +6 STR.",
                    type: "weapon",
                    slot: "weapon", // Added slot definition
                    tier: 1,
                    weaponPhysicalAttackBonus: 10, // Example: +10 Physical Attack
                    stats: { strength: 6 }, // +6 STR
                    gameAsset: 'assets/equipment/SpiritboundBlade.png', // User confirmed path
                    equipEffect: (player) => Game.equipItem(player, "spiritboundBlade")
                },
                "spiritboundMail": {
                    name: "Spiritbound Mail",
                    description: "Armor woven with spirit-enhancing threads. +8 CON.",
                    type: "armor",
                    tier: 1,
                    slot: "body",
                    stats: { constitution: 8 },
                    gameAsset: 'assets/equipment/SpiritboundMailArmor.png', // User confirmed path
                    equipEffect: (player) => Game.equipItem(player, "spiritboundMail")
                },
                "spiritbandRing": {
                    name: "Spiritband Ring",
                    description: "A ring that hums with spiritual power. +5 SPR.",
                    type: "accessory",
                    tier: 1,
                    slot: "ring1", // Using ring1 slot
                    stats: { spirit: 5 },
                    gameAsset: 'assets/equipment/SpiritbandRing.png', // User confirmed path
                    equipEffect: (player) => Game.equipItem(player, "spiritbandRing")
                },
                "spiritstepBoots": {
                    name: "Spiritstep Boots",
                    description: "Boots that lighten your step with spirit energy. +5 AGI.",
                    type: "armor",
                    tier: 1,
                    slot: "feet",
                    stats: { agility: 5 },
                    gameAsset: 'assets/equipment/SpiritstepBoots.png', // User confirmed path
                    equipEffect: (player) => Game.equipItem(player, "spiritstepBoots")
                },
                "spiritguardHelm": {
                    name: "Spiritguard Helm",
                    description: "A helm that focuses spiritual defenses. +6 CON.",
                    type: "armor",
                    tier: 1,
                    slot: "head",
                    stats: { constitution: 6 },
                    gameAsset: 'assets/equipment/SpiritguardHelm.png', // User confirmed path
                    equipEffect: (player) => Game.equipItem(player, "spiritguardHelm")
                },
                // --- Dawnlight Set (Tier 1 Artifact Refiner) ---
                "dawnlightSword": {
                    name: "Dawnlight Sword",
                    description: "A sword that glimmers with the first light of dawn. +5 STR, +2 AGI.",
                    type: "weapon", tier: 1, slot: "weapon",
                    weaponPhysicalAttackBonus: 12, // Example, adjust as needed
                    stats: { strength: 5, agility: 2 },
                    gameAsset: 'assets/equipment/DawnlightSword.png',
                    equipEffect: (player) => Game.equipItem(player, "dawnlightSword")
                },
                "dawnlightVest": {
                    name: "Dawnlight Vest",
                    description: "Armor that catches the morning sun. +7 CON.",
                    type: "armor", tier: 1, slot: "body",
                    stats: { constitution: 7 },
                    gameAsset: 'assets/equipment/DawnlightVest.png',
                    equipEffect: (player) => Game.equipItem(player, "dawnlightVest")
                },
                "dawnbreakBand": {
                    name: "Dawnbreak Band",
                    description: "A ring that shines with hope. +4 SPR, +2 WIL.",
                    type: "accessory", tier: 1, slot: "ring1",
                    stats: { spirit: 4, willpower: 2 },
                    gameAsset: 'assets/equipment/DawnbreakBand.png',
                    equipEffect: (player) => Game.equipItem(player, "dawnbreakBand")
                },
                "dawnbreakTreads": {
                    name: "Dawnbreak Treads",
                    description: "Boots that carry the swiftness of dawn. +6 AGI.",
                    type: "armor", tier: 1, slot: "feet",
                    stats: { agility: 6 },
                    gameAsset: 'assets/equipment/DawnbreakTreads.png',
                    equipEffect: (player) => Game.equipItem(player, "dawnbreakTreads")
                },
                "dawnlightCirclet": {
                    name: "Dawnlight Circlet",
                    description: "A circlet that clears the mind like the morning sky. +4 INT.",
                    type: "armor", tier: 1, slot: "head",
                    stats: { intellect: 4 },
                    gameAsset: 'assets/equipment/DawnlightCirclet.png',
                    equipEffect: (player) => Game.equipItem(player, "dawnlightCirclet")
                },

                // --- Galeheart Set (Tier 1 Artifact Refiner) ---
                "galeheartSpear": {
                    name: "Galeheart Spear",
                    description: "A spear that whistles with the wind's fury. +4 STR, +5 AGI.",
                    type: "weapon", tier: 1, slot: "weapon",
                    weaponPhysicalAttackBonus: 11, // Example
                    stats: { strength: 4, agility: 5 },
                    gameAsset: 'assets/equipment/GaleheartSpear.png',
                    equipEffect: (player) => Game.equipItem(player, "galeheartSpear")
                },
                "galeheartArmor": {
                    name: "Galeheart Armor",
                    description: "Light armor that flows like the wind. +6 CON, +1 AGI.",
                    type: "armor", tier: 1, slot: "body",
                    stats: { constitution: 6, agility: 1 },
                    gameAsset: 'assets/equipment/GaleheartArmor.png',
                    equipEffect: (player) => Game.equipItem(player, "galeheartArmor")
                },
                "galeheartBand": {
                    name: "Galeheart Band",
                    description: "A ring that carries the whisper of gales. +3 AGI, +3 SPR.",
                    type: "accessory", tier: 1, slot: "ring1",
                    stats: { agility: 3, spirit: 3 },
                    gameAsset: 'assets/equipment/GaleheartBand.png',
                    equipEffect: (player) => Game.equipItem(player, "galeheartBand")
                },
                "galeheartGreaves": {
                    name: "Galeheart Greaves",
                    description: "Greaves that offer unmatched swiftness. +7 AGI.",
                    type: "armor", tier: 1, slot: "feet",
                    stats: { agility: 7 },
                    gameAsset: 'assets/equipment/GaleheartGreaves.png',
                    equipEffect: (player) => Game.equipItem(player, "galeheartGreaves")
                },
                "galeheartHelm": {
                    name: "Galeheart Helm",
                    description: "A helm shaped by the winds, offering resilience. +5 CON.",
                    type: "armor", tier: 1, slot: "head",
                    stats: { constitution: 5 },
                    gameAsset: 'assets/equipment/GaleheartHelm.png',
                    equipEffect: (player) => Game.equipItem(player, "galeheartHelm")
                },

                // --- Stonewall Set (Tier 1 Artifact Refiner) ---
                "stonewallHammer": {
                    name: "Stonewall Hammer",
                    description: "A hammer of unyielding stone. +8 STR.",
                    type: "weapon", tier: 1, slot: "weapon",
                    weaponPhysicalAttackBonus: 15, // Example
                    stats: { strength: 8 },
                    gameAsset: 'assets/equipment/StonewallHammer.png',
                    equipEffect: (player) => Game.equipItem(player, "stonewallHammer")
                },
                "stonewallPlate": {
                    name: "Stonewall Plate",
                    description: "Impenetrable plate armor. +10 CON.",
                    type: "armor", tier: 1, slot: "body",
                    stats: { constitution: 10 },
                    gameAsset: 'assets/equipment/StonewallPlate.png',
                    equipEffect: (player) => Game.equipItem(player, "stonewallPlate")
                },
                "stonewallBand": {
                    name: "Stonewall Band",
                    description: "A ring of solid rock. +3 STR, +3 CON.",
                    type: "accessory", tier: 1, slot: "ring1",
                    stats: { strength: 3, constitution: 3 },
                    gameAsset: 'assets/equipment/StonewallBand.png',
                    equipEffect: (player) => Game.equipItem(player, "stonewallBand")
                },
                "stonewallSabatons": {
                    name: "Stonewall Sabatons",
                    description: "Heavy boots that stand firm. +4 CON.",
                    type: "armor", tier: 1, slot: "feet",
                    stats: { constitution: 4 },
                    gameAsset: 'assets/equipment/StonewallSabatons.png',
                    equipEffect: (player) => Game.equipItem(player, "stonewallSabatons")
                },
                "stonewallHelm": {
                    name: "Stonewall Helm",
                    description: "A helm of solid stone, offering great protection. +6 CON.",
                    type: "armor", tier: 1, slot: "head",
                    stats: { constitution: 6 },
                    gameAsset: 'assets/equipment/StonewallHelm.png',
                    equipEffect: (player) => Game.equipItem(player, "stonewallHelm")
                },

                // --- Echoflow Set (Tier 1 Artifact Refiner) ---
                "echoflowStaff": {
                    name: "Echoflow Staff",
                    description: "A staff that resonates with spiritual echoes. +5 SPR, +3 INT.",
                    type: "weapon", tier: 1, slot: "weapon", // Staffs can be weapons
                    weaponPhysicalAttackBonus: 5, // Staffs might have some phys attack or it's mostly for spellcasting
                    stats: { spirit: 5, intellect: 3 },
                    gameAsset: 'assets/equipment/EchoflowStaff.png',
                    equipEffect: (player) => Game.equipItem(player, "echoflowStaff")
                },
                "echoflowRobe": {
                    name: "Echoflow Robe",
                    description: "Robes that shimmer with flowing energy. +7 SPR.",
                    type: "armor", tier: 1, slot: "body",
                    stats: { spirit: 7 },
                    gameAsset: 'assets/equipment/EchoflowRobe.png',
                    equipEffect: (player) => Game.equipItem(player, "echoflowRobe")
                },
                "echoflowBand": {
                    name: "Echoflow Band",
                    description: "A ring that amplifies spiritual resonance. +4 SPR.",
                    type: "accessory", tier: 1, slot: "ring1",
                    stats: { spirit: 4 },
                    gameAsset: 'assets/equipment/EchoflowBand.png',
                    equipEffect: (player) => Game.equipItem(player, "echoflowBand")
                },
                "echoflowShoes": {
                    name: "Echoflow Shoes",
                    description: "Shoes that allow one to tread on echoes. +5 AGI, +3 SPR.",
                    type: "armor", tier: 1, slot: "feet",
                    stats: { agility: 5, spirit: 3 },
                    gameAsset: 'assets/equipment/EchoflowShoes.png',
                    equipEffect: (player) => Game.equipItem(player, "echoflowShoes")
                },
                "echoflowHood": {
                    name: "Echoflow Hood",
                    description: "A hood that quiets the mind and enhances focus. +4 CON, +2 SPR.",
                    type: "armor", tier: 1, slot: "head",
                    stats: { constitution: 4, spirit: 2 },
                    gameAsset: 'assets/equipment/EchoflowHood.png',
                    equipEffect: (player) => Game.equipItem(player, "echoflowHood")
                }
            },
            
            ARTIFACT_RECIPES: {
                "spiritboundBladeRecipe": {
                    name: "Spiritbound Blade",
                    producesItemKey: "spiritboundBlade",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner",
                    requiredCultivationLevel: 1,
                    qiCost: 20
                },
                "spiritboundMailRecipe": {
                    name: "Spiritbound Mail",
                    producesItemKey: "spiritboundMail",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner",
                    requiredCultivationLevel: 1,
                    qiCost: 20
                },
                "spiritbandRingRecipe": {
                    name: "Spiritband Ring",
                    producesItemKey: "spiritbandRing",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner",
                    requiredCultivationLevel: 1,
                    qiCost: 15
                },
                "spiritstepBootsRecipe": {
                    name: "Spiritstep Boots",
                    producesItemKey: "spiritstepBoots",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner",
                    requiredCultivationLevel: 1,
                    qiCost: 15
                },
                "spiritguardHelmRecipe": {
                    name: "Spiritguard Helm",
                    producesItemKey: "spiritguardHelm",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner",
                    requiredCultivationLevel: 1,
                    qiCost: 15
                },
                // --- Dawnlight Set Recipes ---
                "dawnlightSwordRecipe": {
                    name: "Dawnlight Sword", producesItemKey: "dawnlightSword",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "dawnlightVestRecipe": {
                    name: "Dawnlight Vest", producesItemKey: "dawnlightVest",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "dawnbreakBandRecipe": {
                    name: "Dawnbreak Band", producesItemKey: "dawnbreakBand",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "dawnbreakTreadsRecipe": {
                    name: "Dawnbreak Treads", producesItemKey: "dawnbreakTreads",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "dawnlightCircletRecipe": {
                    name: "Dawnlight Circlet", producesItemKey: "dawnlightCirclet",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                // --- Galeheart Set Recipes ---
                "galeheartSpearRecipe": {
                    name: "Galeheart Spear", producesItemKey: "galeheartSpear",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "galeheartArmorRecipe": {
                    name: "Galeheart Armor", producesItemKey: "galeheartArmor",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "galeheartBandRecipe": {
                    name: "Galeheart Band", producesItemKey: "galeheartBand",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "galeheartGreavesRecipe": {
                    name: "Galeheart Greaves", producesItemKey: "galeheartGreaves",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "galeheartHelmRecipe": {
                    name: "Galeheart Helm", producesItemKey: "galeheartHelm",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                // --- Stonewall Set Recipes ---
                "stonewallHammerRecipe": {
                    name: "Stonewall Hammer", producesItemKey: "stonewallHammer",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "stonewallPlateRecipe": {
                    name: "Stonewall Plate", producesItemKey: "stonewallPlate",
                    ingredients: { "spiritOreFragment": 5, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 }, // Note: 5 Spirit Ore
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 25 // Slightly higher cost
                },
                "stonewallBandRecipe": {
                    name: "Stonewall Band", producesItemKey: "stonewallBand",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "stonewallSabatonsRecipe": {
                    name: "Stonewall Sabatons", producesItemKey: "stonewallSabatons",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "stonewallHelmRecipe": {
                    name: "Stonewall Helm", producesItemKey: "stonewallHelm",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                // --- Echoflow Set Recipes ---
                "echoflowStaffRecipe": {
                    name: "Echoflow Staff", producesItemKey: "echoflowStaff",
                    ingredients: { "spiritOreFragment": 2, "enchantedStoneDust": 2, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "echoflowRobeRecipe": {
                    name: "Echoflow Robe", producesItemKey: "echoflowRobe",
                    ingredients: { "spiritOreFragment": 3, "enchantedStoneDust": 1, "minorQiConductor": 1, "demonCore": 1 },
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 20
                },
                "echoflowBandRecipe": {
                    name: "Echoflow Band", producesItemKey: "echoflowBand",
                    ingredients: { "spiritOreFragment": 2, "minorQiConductor": 1, "demonCore": 1 }, // Note: No Enchanted Stone Dust
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "echoflowShoesRecipe": {
                    name: "Echoflow Shoes", producesItemKey: "echoflowShoes",
                    ingredients: { "spiritOreFragment": 2, "enchantedStoneDust": 1, "demonCore": 1 }, // Note: No Minor Qi Conductor
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                },
                "echoflowHoodRecipe": {
                    name: "Echoflow Hood", producesItemKey: "echoflowHood",
                    ingredients: { "spiritOreFragment": 2, "enchantedStoneDust": 1, "demonCore": 1 }, // Note: No Minor Qi Conductor
                    requiredClass: "artifact_refiner", requiredCultivationLevel: 1, qiCost: 15
                }
            },

            /* REALM_HERB_DROPS: { // This structure is being deprecated in favor of area-specific loot tables.
                1: [ 
                    { itemId: 'jadeleafGrass', chance: 0.45, minQuantity: 1, maxQuantity: 3 }, 
                    { itemId: 'crimsonSpiritBerry', chance: 0.30, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'breakthroughVine', chance: 0.08, minQuantity: 1, maxQuantity: 1 } 
                ],
                2: [ 
                    { itemId: 'jadeleafGrass', chance: 0.20, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'crimsonSpiritBerry', chance: 0.35, minQuantity: 1, maxQuantity: 3 },
                    { itemId: 'soothingRainPetal', chance: 0.30, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'moondewFlower', chance: 0.20, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'spiritEyeFlower', chance: 0.10, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'dragonboneFern', chance: 0.07, minQuantity: 1, maxQuantity: 1 } 
                ],
                3: [ 
                    { itemId: 'soothingRainPetal', chance: 0.20, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'moondewFlower', chance: 0.25, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'earthrootGinseng', chance: 0.35, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'whisperingLeaf', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'heartblossomBud', chance: 0.12, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'silverstormLeaf', chance: 0.10, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'phoenixbloodHerb', chance: 0.06, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'divineFlameGrass', chance: 0.04, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'lunarBloom', chance: 0.04, minQuantity: 1, maxQuantity: 1 }      
                ],
                4: [ 
                    { itemId: 'earthrootGinseng', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'whisperingLeaf', chance: 0.20, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'skyLotusBud', chance: 0.30, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'radiantSunfruit', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'starforgePetal', chance: 0.08, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'stoneheartRoot', chance: 0.08, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'goldenDantianFruit', chance: 0.07, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'blackflameGinseng', chance: 0.05, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'frostmarrowMoss', chance: 0.05, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'ascensionOrchid', chance: 0.05, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'heavenpierceRoot', chance: 0.03, minQuantity: 1, maxQuantity: 1 } 
                ],
                5: [ 
                    { itemId: 'skyLotusBud', chance: 0.15, minQuantity: 1, maxQuantity: 2 },
                    { itemId: 'radiantSunfruit', chance: 0.20, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'cloudmossVine', chance: 0.25, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'spiritglowMushroom', chance: 0.10, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'harmonizingBellvine', chance: 0.06, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'eyeOfTheAncients', chance: 0.04, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'immortalDustleaf', chance: 0.04, minQuantity: 1, maxQuantity: 1 }, 
                    { itemId: 'voidberryThorn', chance: 0.03, minQuantity: 1, maxQuantity: 1 },    
                    { itemId: 'thunderclapFruit', chance: 0.02, minQuantity: 1, maxQuantity: 1 } 
                ],
                6: [ 
                    { itemId: 'cloudmossVine', chance: 0.10, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'spiritglowMushroom', chance: 0.08, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'immortalDustleaf', chance: 0.05, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'voidberryThorn', chance: 0.04, minQuantity: 1, maxQuantity: 1 },
                    { itemId: 'thunderclapFruit', chance: 0.03, minQuantity: 1, maxQuantity: 1 }
                ]
            }, */
            getRealmTier: function(cultivationLevel) {
                if (cultivationLevel >= 46) return 6; 
                if (cultivationLevel >= 37) return 5; 
                if (cultivationLevel >= 28) return 4; 
                if (cultivationLevel >= 19) return 3; 
                if (cultivationLevel >= 10) return 2; 
                return 1; 
            },
            EXPLORATION_AREAS: {
                // Realm 1: Qi Condensation
                "whisperingGlade": { 
                    name: "Whispering Glade", requiredRealmTier: 1, description: "A tranquil glade where nascent spiritual energies gather.", monsters: ["qiWisp", "snakeVine", "cloudGecko"], image: "assets/areas/Whispering_Glade.png",
                    lootTable: [
                        { itemId: 'jadeleafGrass', chance: 0.6, minQuantity: 1, maxQuantity: 3 },
                        { itemId: 'crimsonSpiritBerry', chance: 0.4, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'breakthroughVine', chance: 0.05, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritStoneFragment', chance: 0.2, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritOreFragment', chance: 0.25, minQuantity: 1, maxQuantity: 2 }, // Added Spirit Ore Fragment
                        { itemId: toCamelCase("Basic Qi Recovery Pill") + "Recipe", chance: 0.03, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                "verdantStreamCaverns": {
                    name: "Verdant Stream Caverns", requiredRealmTier: 1, description: "Damp caverns echoing with the sound of flowing water, home to glowing flora.", monsters: ["rockshellTortoise", "mistLeopardCub", "spiritBat"], image: "assets/areas/Verdant_Stream_Caverns.png",
                    lootTable: [
                        { itemId: 'jadeleafGrass', chance: 0.5, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'crimsonSpiritBerry', chance: 0.5, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'spiritEyeFlower', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'breakthroughVine', chance: 0.07, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritStoneFragment', chance: 0.25, minQuantity: 1, maxQuantity: 2 }
                    ]
                },
                "fallenLeafHills": { 
                    name: "Fallen Leaf Hills", requiredRealmTier: 1, description: "Rolling hills covered in ancient, fallen leaves, hiding small beasts and herbs.", monsters: ["boneAnt", "leafbladeSerpent", "phantomBeetle"], image: "assets/areas/Fallen_Leaf_Hills.png",
                    lootTable: [
                        { itemId: 'jadeleafGrass', chance: 0.3, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'crimsonSpiritBerry', chance: 0.3, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'heartblossomBud', chance: 0.2, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'breakthroughVine', chance: 0.1, minQuantity: 1, maxQuantity: 1 }, // Higher chance in this "higher" T1 zone
                        { itemId: 'spiritStoneFragment', chance: 0.3, minQuantity: 1, maxQuantity: 2 },
                        { itemId: toCamelCase("Vitality Rejuvenation Pill") + "Recipe", chance: 0.02, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                // Realm 2: Foundation Establishment
                "crimsonEmberValley": { 
                    name: "Crimson Ember Valley", requiredRealmTier: 2, description: "A valley stained red by iron-rich soil, with lingering heat from ancient volcanic activity.", monsters: ["firefangTiger", "flameSalamander", "moltenRockApe"], image: "assets/areas/Crimson_Ember_Valley.png",
                    lootTable: [
                        { itemId: 'soothingRainPetal', chance: 0.5, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'moondewFlower', chance: 0.4, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'dragonboneFern', chance: 0.08, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'beastBoneFragment', chance: 0.25, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Mind-Calming Elixir") + "Recipe", chance: 0.03, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                "moonstoneRidge": { 
                    name: "Moonstone Ridge", requiredRealmTier: 2, description: "A high ridge where moon-kissed stones are said to enhance spiritual perception.", monsters: ["moonlitOwl", "whisperingSpecter", "echoWraith"], image: "assets/areas/Moonstone_Ridge.png",
                    lootTable: [
                        { itemId: 'soothingRainPetal', chance: 0.4, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'moondewFlower', chance: 0.5, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'silverstormLeaf', chance: 0.2, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'dragonboneFern', chance: 0.1, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'beastBoneFragment', chance: 0.3, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                // Realm 3: Core Formation
                "goldenDuneExpanse": { 
                    name: "Golden Dune Expanse", requiredRealmTier: 3, description: "A vast desert of golden sands, where powerful desert beasts roam.", monsters: ["sandDevourerScorpion", "mirageCrawler", "sunfireVulture"], image: "assets/areas/Golden_Dune_Expanse.png",
                    lootTable: [
                        { itemId: 'earthrootGinseng', chance: 0.5, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'whisperingLeaf', chance: 0.4, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'divineFlameGrass', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'phoenixbloodHerb', chance: 0.07, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Advanced Spirit Pill") + "Recipe", chance: 0.03, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                "frostspineTundra": { 
                    name: "Frostspine Tundra", requiredRealmTier: 3, description: "A frozen wasteland where only the hardiest creatures and herbs survive.", monsters: ["icehowlWolf", "frostbiteBear", "crystallineSpiritMoth"], image: "assets/areas/Frostspine_Tundra.png",
                    lootTable: [
                        { itemId: 'earthrootGinseng', chance: 0.4, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'lunarBloom', chance: 0.25, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'frostmarrowMoss', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'phoenixbloodHerb', chance: 0.1, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Flame Infusion Pill") + "Recipe", chance: 0.02, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                // Realm 4: Nascent Soul
                "abyssalVoidMarsh": { 
                    name: "Abyssal Void Marsh", requiredRealmTier: 4, description: "A treacherous marshland where the veil between worlds is thin.", monsters: ["voidEyedToad", "ghoulWillOWisp", "murkSerpent"], image: "assets/areas/Abyssal_Void_Marsh.png",
                    lootTable: [
                        { itemId: 'skyLotusBud', chance: 0.5, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'radiantSunfruit', chance: 0.4, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'blackflameGinseng', chance: 0.2, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'ascensionOrchid', chance: 0.07, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'heavenpierceRoot', chance: 0.05, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Nascent Soul Vital Pill") + "Recipe", chance: 0.03, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                "thunderreachPeaks": { 
                    name: "Thunderreach Peaks", requiredRealmTier: 4, description: "Towering peaks constantly battered by spiritual thunderstorms.", monsters: ["stormdrakeHatchling", "thunderclapApe", "skySerpent"], image: "assets/areas/Thunderreach_Peaks.png",
                    lootTable: [
                        { itemId: 'starforgePetal', chance: 0.3, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'stoneheartRoot', chance: 0.3, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'goldenDantianFruit', chance: 0.25, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'ascensionOrchid', chance: 0.1, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Starforge Strength Pill") + "Recipe", chance: 0.02, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                // Realm 5: Soul Formation
                "obsidianSpiritWastes": { 
                    name: "Obsidian Spirit Wastes", requiredRealmTier: 5, description: "Barren wastes littered with obsidian shards, resonating with potent soul energy.", monsters: ["blackflameShade", "soulEaterWasp", "ashPhoenixFragment"], image: "assets/areas/Obsidian_Spirit_Wastes.png",
                    lootTable: [
                        { itemId: 'cloudmossVine', chance: 0.5, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritglowMushroom', chance: 0.4, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'immortalDustleaf', chance: 0.08, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'voidberryThorn', chance: 0.06, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Balance Harmonization Pill") + "Recipe", chance: 0.03, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                "etherealLotusFields": { 
                    name: "Ethereal Lotus Fields", requiredRealmTier: 5, description: "Fields where phantom lotuses bloom, said to nourish the soul.", monsters: ["enlightenedSprite", "lotusPuppetMonk", "spiralMindLeech"], image: "assets/areas/Ethereal_Lotus_Fields.png",
                    lootTable: [
                        { itemId: 'harmonizingBellvine', chance: 0.3, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'eyeOfTheAncients', chance: 0.2, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'thunderclapFruit', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'immortalDustleaf', chance: 0.1, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Soul Formation Heaven Pill") + "Recipe", chance: 0.02, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                // Realm 6: Transcendent
                "celestialRiftDomain": { 
                    name: "Celestial Rift Domain", requiredRealmTier: 6, description: "A tear in the fabric of reality, leading to unpredictable and powerful energies.", monsters: ["starboundChimera", "heavenpiercerLion", "timeBendingFox"], image: "assets/areas/Celestial_Rift_Domain.png",
                    lootTable: [ // High tier areas might have fewer, but rarer drops
                        { itemId: 'immortalDustleaf', chance: 0.2, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'voidberryThorn', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'thunderclapFruit', chance: 0.1, minQuantity: 1, maxQuantity: 1 },
                        { itemId: toCamelCase("Transcendence Void Elixir") + "Recipe", chance: 0.05, minQuantity: 1, maxQuantity: 1 }
                    ]
                },
                "realmOfBrokenDao": { 
                    name: "Realm of Broken Dao", requiredRealmTier: 6, description: "A chaotic space where the laws of cultivation are fractured and dangerous.", monsters: ["daoFragmentWraith", "crumblingGuardian", "realityScar"], image: "assets/areas/Realm_of_Broken_Dao.png",
                    lootTable: [
                        { itemId: 'spiritglowMushroom', chance: 0.1, minQuantity: 1, maxQuantity: 1 }, // Example of a lower tier but rare herb appearing
                        { itemId: 'eyeOfTheAncients', chance: 0.1, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'immortalDustleaf', chance: 0.25, minQuantity: 1, maxQuantity: 1 }
                        // Potentially unique transcendent materials or very rare recipes
                    ]
                },
                // --- New Gathering Areas ---
                "emeraldVeinHollow": {
                    name: "Emerald Vein Hollow", requiredRealmTier: 1, description: "Where the earths first breath births the humblest herbs and whispering minerals.", monsters: [], image: "assets/areas/Emerald_Vein_Hollow.png",
                    lootTable: [
                        { itemId: 'jadeleafGrass', chance: 0.75, minQuantity: 2, maxQuantity: 5 },
                        { itemId: 'crimsonSpiritBerry', chance: 0.60, minQuantity: 1, maxQuantity: 3 },
                        { itemId: 'breakthroughVine', chance: 0.15, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'spiritStoneFragment', chance: 0.30, minQuantity: 1, maxQuantity: 2 }
                    ]
                },
                "starlitMossGarden": {
                    name: "Starlit Moss Garden", requiredRealmTier: 2, description: "Beneath glowing spores and moon-kissed leaves, the land grows firm in its Qi.", monsters: [], image: "assets/areas/Starlit_Moss_Garden.png",
                    lootTable: [
                        { itemId: 'soothingRainPetal', chance: 0.70, minQuantity: 2, maxQuantity: 4 },
                        { itemId: 'moondewFlower', chance: 0.65, minQuantity: 1, maxQuantity: 3 },
                        { itemId: 'spiritEyeFlower', chance: 0.30, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'dragonboneFern', chance: 0.12, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'spiritStoneFragment', chance: 0.35, minQuantity: 1, maxQuantity: 3 }
                    ]
                },
                "crimsonIronGrottos": {
                    name: "Crimson Iron Grottos", requiredRealmTier: 3, description: "Hidden within molten caverns and spirit-forged tunnels lie roots and ores of awakening power.", monsters: [], image: "assets/areas/Crimson_Iron_Grottos.png",
                    lootTable: [
                        { itemId: 'earthrootGinseng', chance: 0.65, minQuantity: 1, maxQuantity: 3 },
                        { itemId: 'whisperingLeaf', chance: 0.55, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'heartblossomBud', chance: 0.40, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'silverstormLeaf', chance: 0.35, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'phoenixbloodHerb', chance: 0.10, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'divineFlameGrass', chance: 0.08, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'lunarBloom', chance: 0.08, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritStones', chance: 0.15, minQuantity: 1, maxQuantity: 5 } // Small chance for actual stones
                    ]
                },
                "lotusfireMarshlands": {
                    name: "Lotusfire Marshlands", requiredRealmTier: 4, description: "A blooming abyss where soul-charged flowers and rare metals shimmer in toxic fog.", monsters: [], image: "assets/areas/Lotusfire_Marshlands.png",
                    lootTable: [
                        { itemId: 'skyLotusBud', chance: 0.60, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'radiantSunfruit', chance: 0.50, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'starforgePetal', chance: 0.30, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'stoneheartRoot', chance: 0.30, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'goldenDantianFruit', chance: 0.25, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'blackflameGinseng', chance: 0.10, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'frostmarrowMoss', chance: 0.10, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'ascensionOrchid', chance: 0.08, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'heavenpierceRoot', chance: 0.06, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'spiritStones', chance: 0.20, minQuantity: 3, maxQuantity: 8 }
                    ]
                },
                "mirrorwindHighlands": {
                    name: "Mirrorwind Highlands", requiredRealmTier: 5, description: "Wind-warped cliffs where illusions dance and spirit iron hums in stone-veiled shrines.", monsters: [], image: "assets/areas/Mirrorwind_Highlands.png",
                    lootTable: [
                        { itemId: 'cloudmossVine', chance: 0.55, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'spiritglowMushroom', chance: 0.35, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'harmonizingBellvine', chance: 0.30, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'eyeOfTheAncients', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'immortalDustleaf', chance: 0.07, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'voidberryThorn', chance: 0.07, minQuantity: 1, maxQuantity: 1 }, // For next realm
                        { itemId: 'thunderclapFruit', chance: 0.05, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritStones', chance: 0.25, minQuantity: 5, maxQuantity: 12 }
                    ]
                },
                "eclipticDreamRealm": {
                    name: "Ecliptic Dream Realm", requiredRealmTier: 6, description: "Where the world begins to blurphantom blossoms, primal jade, and unformed Dao await.", monsters: [], image: "assets/areas/Ecliptic_Dream_Realm.png",
                    lootTable: [
                        { itemId: 'immortalDustleaf', chance: 0.40, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'voidberryThorn', chance: 0.35, minQuantity: 1, maxQuantity: 2 },
                        { itemId: 'thunderclapFruit', chance: 0.25, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritglowMushroom', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'eyeOfTheAncients', chance: 0.15, minQuantity: 1, maxQuantity: 1 },
                        { itemId: 'spiritStones', chance: 0.30, minQuantity: 10, maxQuantity: 25 }
                    ]
                },
            },

            CULTIVATOR_CLASSES: {
                "martial_cultivator": { name: "Martial Cultivator", specialty: "Physical combat, brute strength, melee dominance, endurance.", recommendation: "Frontline DPS or tank roles; players who enjoy direct combat and body refinement.", effect: (player) => { player.strength += 3; player.constitution += 2; player.maxHealth = player.calculateMaxHealth(); player.health = player.maxHealth; displayMessage("Your physique strengthens! +3 STR, +2 CON.", "class-info"); } },
                "qi_cultivator": { name: "Qi Cultivator", specialty: "Elemental spells, ranged attacks, flying swords, formations.", recommendation: "Ranged DPS, strategic players focused on spellcasting and control.", effect: (player) => { player.spirit += 3; player.intellect += 2; player.maxQi = player.calculateMaxQi(); player.currentQi = player.maxQi; displayMessage("You feel a natural affinity for Qi. +3 SPR, +2 INT. Your meditation is more effective.", "class-info");} },
                "alchemist": { name: "Alchemist", specialty: "Crafting pills for healing, breakthrough, poison, or buffing.", recommendation: "Support role or merchant-style gameplay; influences world through economics and rare pill production.", effect: (player) => { player.intellect += 3; player.willpower += 1; player.spirit +=1; player.resources.jadeleafGrass = (player.resources.jadeleafGrass || 0) + 5; player.resources.crimsonSpiritBerry = (player.resources.crimsonSpiritBerry || 0) + 3; displayMessage("You start with an innate knowledge of herbs and keen mind. +3 INT, +1 WIL, +1 SPR. +5 Jadeleaf Grass, +3 Crimson Spirit Berry.", "class-info");} },
                "artifact_refiner": { name: "Artifact Refiner", specialty: "Forging spiritual weapons, defensive artifacts, arrays.", recommendation: "Crafters and strategic support players who arm others or gain power through custom gear.", effect: (player) => { player.intellect += 3; player.strength +=1; player.constitution +=1; player.resources.roughIronOre = (player.resources.roughIronOre || 0) + 3; displayMessage("You have a knack for finding quality materials and a strong focus. +3 INT, +1 STR, +1 CON. +3 Rough Iron Ore.", "class-info");} },
                "talisman_master": { name: "Talisman Master", specialty: "Drawing talismans for attack, defense, sealing, summoning.", recommendation: "Burst combat or utility players who enjoy preparation and setup playstyles.", effect: (player) => { player.spirit += 2; player.intellect += 2; player.willpower +=1; player.resources.blankTalismanPaper = (player.resources.blankTalismanPaper || 0) + 10; displayMessage("You begin with a supply of talisman paper and a focused spirit. +2 SPR, +2 INT, +1 WIL. +10 Blank Talisman Paper.", "class-info");} },
                "formation_master": { name: "Formation Master", specialty: "Setting up battlefield formations for area control, traps, or enhancement.", recommendation: "Tactical thinkers; for team buffs, enemy restriction, and battlefield control.", effect: (player) => { player.intellect += 3; player.spirit += 2; displayMessage("Your mind is adept at complex patterns. +3 INT, +2 SPR.", "class-info");} },
                "beast_tamer": { name: "Beast Tamer", specialty: "Taming and commanding spirit beasts or demonic creatures.", recommendation: "Summoner-style players, beast combat synergy, or solo adventuring with companions.", effect: (player) => { player.willpower += 3; player.spirit += 2; displayMessage("You possess a strong will to command beasts. +3 WIL, +2 SPR.", "class-info");} },
                "poison_master": { name: "Poison Master", specialty: "Toxins, stealth, curse arts, assassination.", recommendation: "Debuffers, rogue-style gameplay, or players who enjoy subversive tactics.", effect: (player) => { player.intellect += 2; player.agility += 3; displayMessage("You have a subtle and cunning nature. +2 INT, +3 AGI.", "class-info");} },
                "puppet_master": { name: "Puppet Master", specialty: "Constructs animated puppets for combat, defense, spying.", recommendation: "Tech/artifact lovers, indirect combat style, and versatile setups.", effect: (player) => { player.intellect += 3; player.spirit += 1; player.strength +=1; displayMessage("You are skilled in intricate constructions. +3 INT, +1 SPR, +1 STR.", "class-info");} },
                "soul_cultivator": { name: "Soul Cultivator", specialty: "Attacks based on divine soul/spiritual awareness, illusions, or mind control.", recommendation: "High-risk, high-reward players; focuses on soul damage and mental battles.", effect: (player) => { player.spirit += 3; player.willpower += 2; displayMessage("Your connection to the soul is profound. +3 SPR, +2 WIL.", "class-info");} },
                "demon_cultivator": { name: "Demon Cultivator", specialty: "Dark techniques, fast growth through taboo methods, body possession, curses.", recommendation: "Villainous or anti-hero players; strong but risky path with moral choices.", effect: (player) => { player.strength +=1; player.spirit +=1; player.demonicCorruption = 0; displayMessage("You tread the path of demons. +1 STR, +1 SPR. Be wary of corruption.", "class-info");} },
                "heavenly_oracle": { name: "Heavenly Oracle", specialty: "Prophecy, luck manipulation, fate techniques.", recommendation: "Utility/support or RP-focused players; can influence events or gain rare opportunities.", effect: (player) => { player.willpower += 3; player.intellect += 2; displayMessage("You are attuned to the whispers of fate. +3 WIL, +2 INT.", "class-info");} }
            },

            CLASS_STAT_GROWTH: {
                "martial_cultivator": { str: 3, agi: 1, con: 3, spr: 0, intl: 0, wil: 0 },
                "qi_cultivator":      { str: 0, agi: 1, con: 1, spr: 4, intl: 0, wil: 0 },
                "alchemist":          { str: 0, agi: 0, con: 1, spr: 2, intl: 3, wil: 1 },
                "artifact_refiner":   { str: 1, agi: 0, con: 2, spr: 1, intl: 3, wil: 1 },
                "talisman_master":    { str: 0, agi: 2, con: 0, spr: 3, intl: 2, wil: 1 },
                "formation_master":   { str: 0, agi: 0, con: 2, spr: 2, intl: 4, wil: 0 },
                "beast_tamer":        { str: 2, agi: 3, con: 1, spr: 2, intl: 0, wil: 0 },
                "poison_master":      { str: 1, agi: 3, con: 1, spr: 2, intl: 2, wil: 1 },
                "soul_cultivator":    { str: 0, agi: 0, con: 0, spr: 3, intl: 1, wil: 4 },
                "demon_cultivator":   { str: 4, agi: 1, con: 2, spr: 0, intl: 0, wil: 1 },
                "heavenly_oracle":    { str: 0, agi: 0, con: 0, spr: 2, intl: 3, wil: 3 }
            },

            generateId: function() { return db.collection("players").doc().id; },

            updateEquippedItemsUI: function(player) { // Renamed from global to Game method
                if (!player || !player.equippedItems) return;

                const slotMappings = {
                    weapon: 'equipped-weapon', // HTML ID for weapon slot
                    body:   'equipped-armor',  // HTML ID for body/armor slot
                    head:   'equipped-helmet', // HTML ID for head/helmet slot
                    feet:   'equipped-boots',  // HTML ID for feet/boots slot
                    ring1:  'equipped-ring'    // HTML ID for the (first) ring slot
                };

                for (const slotKey in slotMappings) {
                    const elementId = slotMappings[slotKey];
                    const uiElement = document.getElementById(elementId);
                    if (uiElement) {
                        const itemKey = player.equippedItems[slotKey];
                        const item = itemKey ? Game.ITEM_DATA[itemKey] : null;

                        // Remove existing unequip button for this slot if it exists
                        const existingUnequipBtn = document.getElementById(`${elementId}-unequip-btn`);
                        if (existingUnequipBtn) {
                            existingUnequipBtn.remove();
                        }

                        if (item && item.name) {
                            safeSetTextContent(uiElement, item.name);
                            uiElement.className = 'stat-value text-green-400'; // Example: Green text for equipped

                            // Add unequip button
                            const unequipBtn = document.createElement('button');
                            unequipBtn.id = `${elementId}-unequip-btn`;
                            unequipBtn.textContent = "Unequip";
                            unequipBtn.classList.add('unequip-button');
                            unequipBtn.onclick = () => Game.promptUnequipItem(slotKey); // slotKey is 'weapon', 'body', etc.
                            uiElement.insertAdjacentElement('afterend', unequipBtn);

                        } else {
                            safeSetTextContent(uiElement, 'Empty');
                            uiElement.className = 'stat-value text-gray-400';
                        }
                    } else {
                        console.warn(`UI element for equipment slot ID '${elementId}' (key: ${slotKey}) not found.`);
                    }
                }
                // Update the general weapon stat display as well
                const generalWeaponStatElement = document.getElementById('stat-weapon');
                if (generalWeaponStatElement) {
                    const weaponItemKey = player.equippedItems.weapon; // 'weapon' is the slotKey for weapons
                    const weaponItem = weaponItemKey ? Game.ITEM_DATA[weaponItemKey] : null;
                    if (weaponItem && weaponItem.name) {
                        safeSetTextContent(generalWeaponStatElement, weaponItem.name);
                    } else {
                        safeSetTextContent(generalWeaponStatElement, 'Unarmed');
                    }
                }
            },
            
            // --- START: Equipment Handling ---
            unequipItem: function(player, slotToUnequip) { // slotToUnequip is 'weapon', 'body', etc.
                if (!player || !player.equippedItems) return;
                let itemKeyCurrentlyEquipped = player.equippedItems[slotToUnequip];
                let itemData = null;

                if (!itemKeyCurrentlyEquipped) return; // Nothing to unequip in this slot

                itemData = this.ITEM_DATA[itemKeyCurrentlyEquipped];
                if (!itemData) {
                    console.error(`Cannot unequip: Item data not found for key ${itemKeyCurrentlyEquipped}`);
                    return;
                }

                // Revert stat bonuses
                if (itemData.stats) {
                    for (const stat in itemData.stats) {
                        if (player.hasOwnProperty(stat)) {
                            player[stat] -= itemData.stats[stat];
                        } else {
                            console.warn(`Player does not have stat: ${stat} to unequip from ${itemData.name}`);
                        }
                    }
                }

                // No longer need to check slotToUnequip === 'weapon' separately for unequip logic for player object
                player.equippedItems[slotToUnequip] = null;
                if (slotToUnequip === 'weapon') { // Still need to reset specific weapon bonus
                    player.weaponPhysicalAttackBonus = 0;
                }
                
                // Recalculate derived stats like health/Qi if CON/SPR changed
                player.maxHealth = player.calculateMaxHealth();
                player.health = Math.min(player.health, player.maxHealth); // Cap health at new max
                player.maxQi = player.calculateMaxQi();
                player.currentQi = Math.min(player.currentQi, player.maxQi); // Cap Qi at new max

                // displayMessage(`Unequipped ${itemData.name}.`, "item-use"); // Message handled by caller or executeUnequipItem
                // updateStatsDisplay(player); // Will be called by equipItem or other callers
                // Game.saveCurrentPlayerState(); // Will be called by equipItem or other callers
            },

            equipItem: function(player, itemKeyToEquip) {
                if (!player || !itemKeyToEquip) return;
                const itemData = this.ITEM_DATA[itemKeyToEquip];
                if (!itemData) {
                    console.error(`Cannot equip: Item data not found for key ${itemKeyToEquip}`);
                    return;
                }

                const slot = itemData.slot;
                if (!slot) {
                    console.error(`Cannot equip: Item ${itemKeyToEquip} has no slot defined.`);
                    return;
                }

                // Unequip existing item in the slot first
                // The slot variable from itemData.slot should directly match keys in player.equippedItems
                if (player.equippedItems && player.equippedItems[slot]) {
                    this.unequipItem(player, slot); // Pass the correct slot key like 'weapon', 'armor'
                }

                // Apply stat bonuses
                if (itemData.stats) {
                    for (const stat in itemData.stats) {
                        if (player.hasOwnProperty(stat)) {
                            player[stat] = (player[stat] || 0) + itemData.stats[stat];
                        } else {
                             console.warn(`Player does not have stat: ${stat} to equip from ${itemData.name}`);
                        }
                    }
                }

                // The slot variable from itemData.slot should directly match keys in player.equippedItems
                if (player.equippedItems.hasOwnProperty(slot)) {
                    player.equippedItems[slot] = itemKeyToEquip;
                    if (slot === 'weapon' && itemData.weaponPhysicalAttackBonus) {
                        player.weaponPhysicalAttackBonus = itemData.weaponPhysicalAttackBonus;
                    }
                } else {
                    console.error(`Cannot equip: Invalid slot "${slot}" defined in item data or player.equippedItems.`);
                    return;
                }
                
                // Recalculate derived stats like health/Qi if CON/SPR changed
                player.maxHealth = player.calculateMaxHealth();
                player.health = Math.min(player.health, player.maxHealth);
                player.maxQi = player.calculateMaxQi();
                player.currentQi = Math.min(player.currentQi, player.maxQi);

                showEquipmentToast(`Successfully equipped ${itemData.name}!`); // Show toast notification

                displayMessage(`Equipped ${itemData.name}.`, "item-use");
                updateStatsDisplay(player); // updateStatsDisplay will be called after this
                this.saveCurrentPlayerState(); // saveCurrentPlayerState will be called after this
            },

            async promptUnequipItem(slotKey) {
                const player = this.players[this.currentPlayerId];
                if (!player || !player.equippedItems || !player.equippedItems[slotKey]) {
                    displayMessage("Nothing to unequip in that slot.", "narration");
                    return;
                }
                const itemKey = player.equippedItems[slotKey];
                const itemData = this.ITEM_DATA[itemKey];
                if (!itemData) {
                    console.error(`Item data not found for ${itemKey} in slot ${slotKey}`);
                    return;
                }

                const confirm = await getYesNoModalInput(`Unequip ${itemData.name}?`);
                if (confirm === true) {
                    await this.executeUnequipItem(slotKey);
                } else {
                    displayMessage(`Unequip of ${itemData.name} cancelled.`, "narration");
                }
            },

            async executeUnequipItem(slotKey) {
                const player = this.players[this.currentPlayerId];
                const itemKey = player.equippedItems[slotKey]; // Get key before unequipItem clears it
                const itemName = this.ITEM_DATA[itemKey] ? this.ITEM_DATA[itemKey].name : "Item";

                this.unequipItem(player, slotKey); // Core logic
                showEquipmentToast(`Successfully unequipped ${itemName}!`);
                updateStatsDisplay(player);
                await this.saveCurrentPlayerState();
                if (gridInventoryModal && (gridInventoryModal.style.display === 'flex' || gridInventoryModal.style.display === 'block')) {
                    populateModalInventoryGrid(player); // Refresh inventory if open
                }
            },
            // --- END: Equipment Handling ---
            
            async saveCurrentPlayerState() {
                if (!this.currentPlayerId || !this.players[this.currentPlayerId]) {
                    console.error("No current player to save.");
                    return;
                }
                const player = this.players[this.currentPlayerId];
                try {
                    const playerData = player.toFirestoreObject();
                    await db.collection("players").doc(player.playerId).set(playerData);
                } catch (error) {
                    console.error("Error saving player state:", error);
                    displayMessage("Failed to save your progress. Check connection.", "error");
                }
            },

            async saveSectData(sectId) {
                if (!sectId || !this.sects[sectId]) {
                    console.error("No sect data to save for ID:", sectId); return;
                }
                const sect = this.sects[sectId];
                try {
                    await db.collection("sects").doc(sectId).set(sect.toFirestoreObject());
                } catch (error) { console.error("Error saving sect data:", error); displayMessage("Failed to save sect data.", "error");}
            },

            async initializeGame() {
                this.loadPillDataFromCSV(pillCsvData);
                displayMessage("=== Welcome to the Path of the Ascendant Dragon ===", 'important');
                
                // Ensure player object, if created or loaded before full Game init, has correct equipment structure
                // This is mostly a safeguard; constructor and fromFirestoreObject should handle it.
                if (this.players && this.players[this.currentPlayerId] && !this.players[this.currentPlayerId].equippedItems) {
                    this.players[this.currentPlayerId].equippedItems = { weapon: null, armor: null, helmet: null, boots: null, ring: null };
                } else if (this.players && this.players[this.currentPlayerId] && this.players[this.currentPlayerId].equippedItems) {
                    // Ensure all new slots exist if loading from an older save
                    const p = this.players[this.currentPlayerId];
                    if (!p.equippedItems.hasOwnProperty('weapon')) p.equippedItems.weapon = null;
                    if (!p.equippedItems.hasOwnProperty('armor')) p.equippedItems.armor = null;
                    if (!p.equippedItems.hasOwnProperty('helmet')) p.equippedItems.helmet = null;
                    if (!p.equippedItems.hasOwnProperty('boots')) p.equippedItems.boots = null;
                    if (!p.equippedItems.hasOwnProperty('ring')) p.equippedItems.ring = null;
                }

                // Define permission keys for easier reference and to avoid typos
                this.SECT_PERMISSIONS = {
                    // ... (permissions remain the same)
                };

                const urlParams = new URLSearchParams(window.location.search);
                const initialAction = urlParams.get('action');
                // Optional: Clear action from URL to prevent re-trigger on refresh
                // window.history.replaceState({}, document.title, window.location.pathname);

                // Attempt to restore session first
                const restored = await this.checkAndRestoreSession();
                if (!restored) {
                    // If session not restored, then check URL params
                    if (initialAction === 'create') {
                        this.showCreateAccountForm();
                    } else if (initialAction === 'login') {
                        this.showLoginForm();
                    } else {
                        this.showMainGate();
                    }
                } else {
                    // Session restored, player is logged in.
                }
            },
            async initializeGame_orig() { // Renamed original for reference
                this.loadPillDataFromCSV(pillCsvData);
                displayMessage("=== Welcome to the Path of the Ascendant Dragon ===", 'important');
                displayMessage("A Wuxia Cultivation RPG", 'narration');

                // Define permission keys for easier reference and to avoid typos
                this.SECT_PERMISSIONS = {
                    RENAME_SECT: "rename_sect",
                    PROMOTE_MEMBER: "promote_member_lower_rank",
                    DEMOTE_MEMBER: "demote_member_lower_rank",
                    KICK_MEMBER: "kick_member_lower_rank",
                    ACCEPT_NEW_MEMBER: "accept_new_member", // Also covers invite
                    START_SECT_EVENT: "start_sect_event",
                    DONATE_TO_TREASURY: "donate_to_treasury",
                    BUY_FROM_SECT_SHOP: "buy_from_sect_shop",
                    MANAGE_TREASURY: "manage_treasury",
                    SET_MOTTO: "set_motto",
                    EDIT_DESCRIPTION: "edit_description",
                    // Add other specific permissions as needed
                    ALL: "all" 
                };
                this.showMainGate();
            },
            async checkAndRestoreSession() {
                const storedPlayerId = localStorage.getItem('currentPlayerId');
                if (storedPlayerId) {
                    try {
                        const playerDoc = await db.collection("players").doc(storedPlayerId).get();
                        if (playerDoc.exists) {
                            const playerData = playerDoc.data();
                            const player = Player.fromFirestoreObject(playerData);
                            player.playerId = playerDoc.id; // Ensure playerId is set from doc.id

                            this.players[player.playerId] = player;
                            this.currentPlayerId = player.playerId;

                            if (player.sectId) {
                                const sectDoc = await db.collection("sects").doc(player.sectId).get();
                                if (sectDoc.exists) {
                                    this.sects[sectDoc.id] = Sect.fromFirestoreObject(sectDoc.data(), sectDoc.id);
                                }
                            }
                            displayMessage(`Welcome back, ${player.name}! Session restored.`, 'success');
                            if (chatInput) { chatInput.disabled = false; chatInput.placeholder = "Type your message..."; }
                            if (chatSendButton) chatSendButton.disabled = false;
                            this.listenForChatMessages();
                            this.showLoggedInMenu();
                            return true; // Session restored
                        } else {
                            localStorage.removeItem('currentPlayerId'); // Player not found, clear invalid ID
                        }
                    } catch (error) {
                        console.error("Error restoring session:", error);
                        localStorage.removeItem('currentPlayerId'); // Error, clear ID
                    }
                }
                return false; // Session not restored
            },
            getPlayerSectRole(playerId, sectId) {
                const sect = this.sects[sectId];
                if (sect && sect.members && sect.members[playerId]) {
                    return sect.members[playerId].role;
                }
                return null;
            },
            getRankOrder(rankName, sectRanksArray) {
                if (!sectRanksArray) return -1; // Should not happen if sect.ranks exists
                const rankIndex = sectRanksArray.findIndex(r => r.name === rankName);
                return rankIndex; // Lower index means higher rank
            },
            hasSectPermission(playerId, sectId, permissionKey, targetPlayerIdForRankCheck = null) {
                const sect = this.sects[sectId];
                if (!sect) return false;

                const actingPlayerRoleName = this.getPlayerSectRole(playerId, sectId);
                if (!actingPlayerRoleName) return false;

                const rankObject = sect.ranks.find(r => r.name === actingPlayerRoleName);
                if (!rankObject || !rankObject.permissions) return false;

                if (rankObject.permissions.includes(this.SECT_PERMISSIONS.ALL)) return true;
                if (!rankObject.permissions.includes(permissionKey)) return false;

                // If permission requires rank check (e.g., promote_member_lower_rank)
                if (targetPlayerIdForRankCheck && (permissionKey === this.SECT_PERMISSIONS.PROMOTE_MEMBER || permissionKey === this.SECT_PERMISSIONS.DEMOTE_MEMBER || permissionKey === this.SECT_PERMISSIONS.KICK_MEMBER)) {
                    const actingPlayerRankOrder = this.getRankOrder(actingPlayerRoleName, sect.ranks);
                    const targetPlayerRoleName = this.getPlayerSectRole(targetPlayerIdForRankCheck, sectId);
                    const targetPlayerRankOrder = this.getRankOrder(targetPlayerRoleName, sect.ranks);
                    return actingPlayerRankOrder < targetPlayerRankOrder && actingPlayerRankOrder !== -1 && targetPlayerRankOrder !== -1;
                }
                return true; // Passed basic permission check and no further rank check needed or it passed
            },
            showMainGate() {
                this.currentGameState = 'MAIN_GATE'; this.currentPlayerId = null; 
                combatInterface.style.display = 'none'; 
                if (classSelectionInfoDiv) classSelectionInfoDiv.style.display = 'none';
                if (inventoryMenuDiv) inventoryMenuDiv.style.display = 'none';
                if (gridInventoryModal) gridInventoryModal.style.display = 'none';
                if (marketMenuDiv) marketMenuDiv.style.display = 'none';
                if (marketListingsViewDiv) marketListingsViewDiv.style.display = 'none';
                if (concoctionMenuDiv) concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attrAllocMenu = document.getElementById('attribute-allocation-menu');
                if (attrAllocMenu) attrAllocMenu.style.display = 'none';
                
                // Hide auth forms
                if (createAccountFormContainer) createAccountFormContainer.style.display = 'none';
                if (loginFormContainer) loginFormContainer.style.display = 'none';

                // Show main game layout elements
                const gameHeader = document.querySelector('header.mb-4');
                if (gameHeader) gameHeader.style.display = 'block';
                if (mainContentArea) mainContentArea.style.display = 'flex';
                if (actionButtonsContainer) actionButtonsContainer.style.display = 'grid';
                if (statsPanelAside) statsPanelAside.style.display = 'none';
                if (gameOutput) gameOutput.innerHTML = ''; // Clear log
                if (chatFooter) chatFooter.style.display = 'none';

                displayMessage("=== Welcome to the Path of the Ascendant Dragon ===", 'important');
                displayMessage("A Wuxia Cultivation RPG", 'narration');
                displayMessage("\n--- Main Gate ---", 'system');

                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none'; // Old text menu
                if(gridInventoryModal) gridInventoryModal.style.display = 'none'; // New grid modal
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                populateActionButtons([ 
                    { text: "Create Cultivator", action: "show_create_form_action", style: "confirm" },
                    { text: "Login", action: "show_login_form_action", style: "confirm" },
                    { text: "Exit (Reload Page)", action: "exit_game", style: "danger" }
                ], actionButtonsContainer);
                statName.textContent = "Nameless One"; statClass.textContent = "Undetermined"; 
                statRealm.textContent = "Mortal"; statLevel.textContent = "0"; 
                statSpiritualRoot.textContent = "Undetermined";
                statProgress.textContent = "0/0 XP";
                statHealth.textContent = "N/A"; statQi.textContent = "N/A"; statStrength.textContent = "N/A"; statAgility.textContent = "N/A"; statConstitution.textContent = "N/A"; statSpirit.textContent = "N/A"; statIntellect.textContent = "N/A"; statWillpower.textContent = "N/A";
                statPhysAttack.textContent = "N/A"; statPhysDefense.textContent = "N/A"; 
                statSpiritStones.textContent = "N/A";
                statSect.textContent = "None"; 
                statWeapon.textContent = "Unarmed";
                statDemonicCorruptionContainer.style.display = 'none';

                if (chatInput) {
                    chatInput.disabled = true;
                    chatInput.placeholder = "Login to chat...";
                    chatInput.value = '';
                }
                if (chatSendButton) chatSendButton.disabled = true;
                if (chatLogContainer) chatLogContainer.innerHTML = ''; 
            },
            toggleGridInventoryModal() {
                // Ensure it doesn't open if in a state where it shouldn't (e.g. combat)
                if (this.currentGameState === 'COMBAT' || this.currentGameState === 'IN_DEDICATED_EXPLORATION') {
                    return; // Or display a message "Cannot open inventory now"
                }
                const player = this.players[this.currentPlayerId];
                if (!gridInventoryModal || !player) return;

                if (gridInventoryModal.style.display === 'none' || gridInventoryModal.style.display === '') {
                    populateModalInventoryGrid(player); // Populate/Refresh before showing
                    gridInventoryModal.style.display = 'flex';
                } else {
                    gridInventoryModal.style.display = 'none';
                }
            },
            showLoggedInMenu() {
                this.currentGameState = 'LOGGED_IN_MENU'; 
                // Hide auth forms if they were visible
                if (createAccountFormContainer) createAccountFormContainer.style.display = 'none';
                if (loginFormContainer) loginFormContainer.style.display = 'none';

                // Clear game output for a fresh start on the main menu
                if (gameOutput) gameOutput.innerHTML = '';

                // Ensure main game layout elements are visible
                const gameHeader = document.querySelector('header.mb-4');
                if (gameHeader) gameHeader.style.display = 'block';
                if (mainContentArea) mainContentArea.style.display = 'flex';
                if (actionButtonsContainer) actionButtonsContainer.style.display = 'grid';
                if (statsPanelAside) statsPanelAside.style.display = 'block'; // Show stats panel
                if (chatFooter) chatFooter.style.display = 'flex'; // Show chat


                combatInterface.style.display = 'none'; 
                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none'; // Old text menu
                if(gridInventoryModal) gridInventoryModal.style.display = 'none'; // Ensure new grid modal is hidden
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none'; 
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                if (statsPanelAside) statsPanelAside.style.display = 'block'; // Or 'flex' if it's a flex item, 'block' is usually fine for an aside
                combatSpecificActions.innerHTML = ''; 

                actionButtonsContainer.classList.remove('exploration-mode'); // Ensure exploration mode is off
                const player = this.players[this.currentPlayerId]; if (!player) { this.logout(); return; }

                if (!player.hasRolledSpiritualRoot) {
                    displayMessage(`\nWelcome, ${player.name}. Your destiny awaits the revealing of your Spiritual Roots.`, 'system');
                    populateActionButtons([
                        { text: "Divine Your Spiritual Roots", action: "roll_spiritual_root", style: "divine" },
                        { text: "Logout", action: "logout", style: "neutral" }
                    ], actionButtonsContainer);
                    updateStatsDisplay(player);
                    return;
                }
                if (!player.hasClassChosen) {
                    this.showClassSelectionMenu();
                    return;
                }

                if (!player.isAlive()) {
                    displayMessage("\nIncapacitated. Recover health.", 'error'); player.health = Math.floor(player.maxHealth / 4);
                    displayMessage(`Recovered some health. HP: ${player.health}/${player.maxHealth}`, 'success');
                    if (!player.isAlive()) { displayMessage("Still weak. Meditate.", 'error');}
                    this.saveCurrentPlayerState(); 
                }
                updateStatsDisplay(player); 
                displayMessage(`\n--- ${player.name}'s Journey (${player.getCultivationRealmName()}) ---`, 'system');
                
                let menuActions = [ 
                    { text: "Meditate", action: "meditate", style: "confirm", tooltip: "Recover health and Qi." }, 
                    { text: "Explore Area", action: "explore", tooltip: "Venture into new lands to find resources or face challenges." },
                    { text: "Inventory", action: "toggle_grid_inventory", style: "special", tooltip: "View and manage your items." },
                    { text: "Marketplace", action: "show_market_menu", style: "special", tooltip: "Trade items with other cultivators." },
                    { text: "Tianji Pavilion", action: "show_tianji_pavilion", style: "special", tooltip: "Seek wisdom and uncover secrets. (Placeholder)" },
                    { text: "Sect Hall", action: "manage_sects", style: "special", tooltip: "Interact with your sect or find a new one." }, 
                    { text: "Challenge Rival (PvP)", action: "pvp", style: "danger", tooltip: "Test your might against a formidable opponent." }
                ];
                if (player.freeAttributePoints > 0) {
                    menuActions.splice(3, 0, { text: `Allocate Points (${player.freeAttributePoints})`, action: "show_allocate_attributes", style: "confirm" });
                }
                if (player.chosenClassKey === 'alchemist') { // Only Alchemists see Concoct Pills
                    menuActions.splice(3, 0, { text: "Concoct Pills", action: "show_concoction_menu", style: "crafting_action" });
                }

                if (player.chosenClassKey === 'artifact_refiner') {
                     menuActions.splice(4,0, { text: "Forge Artifact", action: "forge_artifact", style: "special" }); 
                } else if (player.chosenClassKey === 'talisman_master') {
                     menuActions.splice(4,0, { text: "Draw Talisman", action: "draw_talisman", style: "special" }); 
                }

                menuActions.push({ text: "Logout", action: "logout", style: "neutral" });
                populateActionButtons(menuActions, actionButtonsContainer);
            },
            showClassSelectionMenu() {
                this.currentGameState = 'CLASS_SELECTION';
                classSelectionInfoDiv.style.display = 'block';
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                classSelectionInfoDiv.innerHTML = '<h3>Choose Your Path</h3><p>Select a class to view its details, then confirm your choice.</p>';
                this.selectedClassForInfo = null; 

                const player = this.players[this.currentPlayerId];
                displayMessage(`\n${player.name}, with your <span class="spiritual-root">${player.spiritualRootName}</span>, it is time to choose your cultivation path.`, 'system');
                
                let classButtons = [];
                for (const classKey in this.CULTIVATOR_CLASSES) {
                    classButtons.push({ text: this.CULTIVATOR_CLASSES[classKey].name, action: 'show_class_info', value: classKey, style: 'class_select' });
                }
                classButtons.push({ text: "Confirm Class", action: "select_class", value: null, style: "confirm" }); 
                classButtons.push({ text: "Logout", action: "logout", style: "neutral" });
                
                populateActionButtons(classButtons, actionButtonsContainer);
            },
            showClassInfo(classKey) {
                const classData = this.CULTIVATOR_CLASSES[classKey];
                if (!classData) return;
                this.selectedClassForInfo = classKey; 

                classSelectionInfoDiv.innerHTML = `
                    <h3>${classData.name}</h3>
                    <p><strong>Specialty:</strong> ${classData.specialty}</p>
                    <p><strong>Recommended for:</strong> ${classData.recommendation}</p>
                `;
                let classButtons = [];
                for (const key in this.CULTIVATOR_CLASSES) {
                    classButtons.push({ text: this.CULTIVATOR_CLASSES[key].name, action: 'show_class_info', value: key, style: 'class_select' });
                }
                classButtons.push({ text: `Confirm ${classData.name}`, action: "select_class", value: classKey, style: "confirm" });
                classButtons.push({ text: "Logout", action: "logout", style: "neutral" });
                populateActionButtons(classButtons, actionButtonsContainer);
            },
            async selectClass(classKey) {
                const player = this.players[this.currentPlayerId];
                if (!player || !classKey || !this.CULTIVATOR_CLASSES[classKey]) {
                    displayMessage("Invalid class selection.", "error");
                    this.showClassSelectionMenu();
                    return;
                }
                const chosenClassData = this.CULTIVATOR_CLASSES[classKey];
                player.chosenClassName = chosenClassData.name;
                player.chosenClassKey = classKey;
                player.hasClassChosen = true;

                displayMessage(`You have chosen the path of the <span class="class-info">${chosenClassData.name}</span>!`, "success");
                
                if (typeof chosenClassData.effect === 'function') {
                    chosenClassData.effect(player);
                }

                await this.saveCurrentPlayerState(); 
                updateStatsDisplay(player);
                classSelectionInfoDiv.style.display = 'none'; 
                this.showLoggedInMenu();
            },
            async promptUseItem(itemKey, itemName) {
                const player = this.players[this.currentPlayerId];
                const itemData = Game.ITEM_DATA[itemKey];

                if (!player || !itemData || !player.resources[itemKey] || player.resources[itemKey] <= 0) {
                    displayMessage("Item not found or out of stock.", "error");
                    return;
                }

                // Check if item is one that executeUseItem handles (consumable, weapon, recipe)
                if (!(itemData.type === 'consumable' || itemData.type === 'weapon' || itemData.type === 'armor' || itemData.type === 'accessory' || itemData.type === 'recipe')) {
                    displayMessage(`${itemName || itemData.name}: ${itemData.description || 'This item cannot be used directly from here.'}`, 'narration');
                    return;
                }

                const confirm = await getYesNoModalInput(`Use ${itemName || itemData.name}?`);
                if (confirm === true) {
                    await this.executeUseItem(itemKey);
                } else {
                    displayMessage("Item use cancelled.", "narration");
                }
            },
            async executeUseItem(itemKey) {
                const player = this.players[this.currentPlayerId];
                const itemData = Game.ITEM_DATA[itemKey];
                if (!player || !itemData || !player.resources[itemKey] || player.resources[itemKey] <= 0) {
                    displayMessage("Item not found or out of stock.", "error");
                    return;
                }
                let itemConsumedOrChanged = false;

                if (itemData.type === 'consumable' || itemData.type === 'recipe') {
                    const originalQuantity = player.resources[itemKey];
                    itemData.effect(player); // This might consume the item or teach a recipe
                    if (player.resources[itemKey] < originalQuantity || itemData.type === 'recipe') {
                        itemConsumedOrChanged = true;
                    }
                } else if (itemData.type === 'weapon' || itemData.type === 'armor' || itemData.type === 'accessory') {
                    // Determine the currently equipped item in the target slot
                    let currentEquippedInSlot = null;
                    if (itemData.slot === 'weapon') {
                        currentEquippedInSlot = player.equippedWeapon;
                    } else if (player.equippedItems && player.equippedItems.hasOwnProperty(itemData.slot)) {
                        currentEquippedInSlot = player.equippedItems[itemData.slot];
                    }

                    if (currentEquippedInSlot && currentEquippedInSlot === itemKey) {
                        displayMessage(`${itemData.name} is already equipped in the ${itemData.slot} slot.`, "narration");
                    } else {
                        // The equipEffect for these items should now be: (player) => Game.equipItem(player, "itemKey")
                        // Game.equipItem handles un-equipping the old item and equipping the new one.
                        itemData.equipEffect(player); // This will call Game.equipItem(player, itemKey)
                        itemConsumedOrChanged = true; // Indicate that equipment state changed
                    }
                }
                
                if (itemConsumedOrChanged || this.currentCombat) {
                    updateStatsDisplay(player); 
                    await this.saveCurrentPlayerState(); 
                    // If inventory modal is open, refresh it
                    if (gridInventoryModal && (gridInventoryModal.style.display === 'flex' || gridInventoryModal.style.display === 'block')) {
                        populateModalInventoryGrid(player);
                    }
                }
                
                if (this.currentCombat && itemData.usableInCombat) { 
                    // Combat logic handles its own UI updates after item use
                } 
            },
            showMarketMenu() {
                this.currentGameState = 'MARKET_MENU';
                marketMenuDiv.style.display = 'block';
                marketListingsViewDiv.style.display = 'none'; 
                actionButtonsContainer.innerHTML = '';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none';
                classSelectionInfoDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none';
                combatInterface.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                if(gridInventoryModal) gridInventoryModal.style.display = 'none';


                marketMenuDiv.innerHTML = '<h3>Marketplace</h3>';
                displayMessage("Welcome to the Marketplace. What would you like to do?", "market");

                populateActionButtons([
                    { text: "List Item for Sale", action: "market_list_item_select", style: "market_action"},
                    { text: "View Market Listings", action: "market_view_listings", style: "market_action"}, 
                    { text: "Back to Menu", action: "show_logged_in_menu", style: "neutral"}
                ], marketMenuDiv); 
            },
            async marketListItemSelect() {
                const player = this.players[this.currentPlayerId];
                if (!player) return;

                marketMenuDiv.innerHTML = '<h3>List Item for Sale - Select Item</h3>';
                let itemsToList = [];
                for (const itemKey in player.resources) {
                    if (player.resources[itemKey] > 0 && Game.ITEM_DATA[itemKey]) {
                        const itemData = Game.ITEM_DATA[itemKey];
                        if (itemData.type !== 'currency' && itemData.type !== 'quest_item') { 
                             itemsToList.push({
                                text: `${itemData.name} (x${player.resources[itemKey]})`,
                                action: 'list_item_for_sale_prompt', 
                                value: itemKey, 
                                style: 'inventory_item_original' // Using the old style for this context
                            });
                        }
                    }
                }

                if (itemsToList.length === 0) {
                    marketMenuDiv.innerHTML += '<p class="text-gray-500 text-center">You have no items to list.</p>';
                }
                populateActionButtons(itemsToList, marketMenuDiv);

                const backButton = document.createElement('button');
                backButton.textContent = "Back to Marketplace";
                backButton.classList.add('action-button', 'bg-gray-600', 'hover:bg-gray-700', 'text-white', 'font-semibold', 'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'm-1', 'mt-4', 'mx-auto', 'block');
                backButton.onclick = () => this.showMarketMenu();
                marketMenuDiv.appendChild(backButton);
            },

            async promptListItemForSale(itemKey) {
                const player = this.players[this.currentPlayerId];
                const itemData = Game.ITEM_DATA[itemKey];
                if (!player || !itemData || !player.resources[itemKey] || player.resources[itemKey] <= 0) {
                    displayMessage("Invalid item or no stock.", "error");
                    this.showMarketMenu();
                    return;
                }

                const quantityToSellStr = await getModalInput(`How many ${itemData.name} to sell? (You have ${player.resources[itemKey]})`, 'number');
                const quantityToSell = parseInt(quantityToSellStr);

                if (isNaN(quantityToSell) || quantityToSell <= 0 || quantityToSell > player.resources[itemKey]) {
                    displayMessage("Invalid quantity or not enough stock.", "error");
                    this.showMarketMenu();
                    return;
                }

                const pricePerItemStr = await getModalInput(`Price per ${itemData.name} (in Spirit Stones):`, 'number');
                const pricePerItem = parseInt(pricePerItemStr);

                if (isNaN(pricePerItem) || pricePerItem <= 0) {
                    displayMessage("Invalid price.", "error");
                    this.showMarketMenu();
                    return;
                }

                const confirm = await getModalInput(`List ${quantityToSell}x ${itemData.name} for ${pricePerItem} Spirit Stones each? (Total: ${quantityToSell * pricePerItem}) (yes/no)`);
                if (confirm && confirm.toLowerCase() === 'yes') {
                    await this.listItemOnMarket(itemKey, quantityToSell, pricePerItem);
                } else {
                    displayMessage("Listing cancelled.", "narration");
                    this.showMarketMenu();
                }
            },

            async listItemOnMarket(itemKey, quantity, pricePerItem) {
                const player = this.players[this.currentPlayerId];
                if (!player || !Game.ITEM_DATA[itemKey] || player.resources[itemKey] < quantity) {
                    displayMessage("Cannot list item: Insufficient stock or invalid item.", "error");
                    this.showMarketMenu(); 
                    return;
                }

                player.resources[itemKey] -= quantity; 

                const listingId = db.collection("marketListings").doc().id; 
                const listingData = {
                    listingId: listingId,
                    itemId: itemKey,
                    itemName: Game.ITEM_DATA[itemKey].name,
                    quantity: quantity,
                    pricePerItem: pricePerItem,
                    sellerId: player.playerId,
                    sellerName: player.name,
                    listedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    status: "active" 
                };

                try {
                    await db.collection("marketListings").doc(listingId).set(listingData);
                    await this.saveCurrentPlayerState(); 
                    displayMessage(`${quantity}x ${listingData.itemName} listed on the market for ${pricePerItem} Spirit Stones each.`, "market");
                    updateStatsDisplay(player); 
                } catch (error) {
                    console.error("Error listing item on market:", error);
                    displayMessage("Failed to list item. Please try again.", "error");
                    player.resources[itemKey] += quantity; 
                }
                this.showMarketMenu(); 
            },
            async showMarketListings() {
                this.currentGameState = 'VIEW_MARKET_LISTINGS';
                marketListingsViewDiv.style.display = 'block';
                marketMenuDiv.style.display = 'none'; 
                actionButtonsContainer.innerHTML = ''; 
                concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                if(gridInventoryModal) gridInventoryModal.style.display = 'none';


                marketListingsViewDiv.innerHTML = '<h3>Active Market Listings</h3>';
                displayMessage("Fetching market listings...", "system");

                const player = this.players[this.currentPlayerId];
                if (!player) { this.showMarketMenu(); return; }


                try {
                    const listingsQuery = await db.collection("marketListings")
                                                .where("status", "==", "active")
                                                .orderBy("listedAt", "desc") 
                                                .limit(20) 
                                                .get();
                    
                    if (listingsQuery.empty) {
                        marketListingsViewDiv.innerHTML += '<p class="text-gray-500 text-center">The marketplace is currently empty.</p>';
                    } else {
                        let listingsHtml = '<div class="space-y-2">';
                        listingsQuery.forEach(doc => {
                            const listing = doc.data();
                            const totalPrice = listing.quantity * listing.pricePerItem;
                            listingsHtml += `
                                <div class="market-listing-item p-2 bg-gray-700 rounded">
                                    <p class="font-semibold text-lg">${listing.itemName} (x${listing.quantity})</p>
                                    <p class="text-sm">Price: ${listing.pricePerItem} Spirit Stones each</p>
                                    <p class="text-sm">Total: ${totalPrice} Spirit Stones</p>
                                    <p class="text-xs text-gray-400">Seller: ${listing.sellerName} ${listing.sellerId === player.playerId ? "(You)" : ""}</p>
                                    ${listing.sellerId !== player.playerId ?
                                        `<button class="action-button bg-green-600 hover:bg-green-700 text-white text-sm py-1 px-3 rounded mt-1" onclick="Game.promptBuyItem('${listing.listingId}')">Buy</button>` :
                                        `<button class="action-button bg-red-600 hover:bg-red-700 text-white text-sm py-1 px-3 rounded mt-1" onclick="Game.promptRemoveListing('${listing.listingId}')">Remove Listing</button>`
                                    }
                                </div>
                            `;
                        });
                        listingsHtml += '</div>';
                        marketListingsViewDiv.innerHTML += listingsHtml;
                    }
                } catch (error) {
                    console.error("Error fetching market listings:", error);
                    marketListingsViewDiv.innerHTML += '<p class="text-red-500 text-center">Could not load market listings. Please try again later.</p>';
                }

                const backButton = document.createElement('button');
                backButton.textContent = "Back to Marketplace";
                backButton.classList.add('action-button', 'bg-gray-600', 'hover:bg-gray-700', 'text-white', 'font-semibold', 'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'm-1', 'mt-4', 'mx-auto', 'block');
                backButton.onclick = () => this.showMarketMenu();
                marketListingsViewDiv.appendChild(backButton);
            },
            async promptBuyItem(listingId) {
                const buyer = this.players[this.currentPlayerId];
                if (!buyer) return;

                marketListingsViewDiv.style.display = 'none'; 

                try {
                    const listingDoc = await db.collection("marketListings").doc(listingId).get();
                    if (!listingDoc.exists) {
                        displayMessage("Listing no longer available.", "error");
                        this.showMarketListings(); return;
                    }
                    const listingData = listingDoc.data();

                    if (listingData.status !== 'active') {
                        displayMessage("This item is no longer for sale.", "error");
                        this.showMarketListings(); return;
                    }
                    if (listingData.sellerId === buyer.playerId) {
                        displayMessage("You cannot buy your own items.", "error");
                        this.showMarketListings(); return;
                    }

                    let quantityToBuy = 1;
                    if (listingData.quantity > 1) {
                        const quantityStr = await getModalInput(`How many ${listingData.itemName} to buy? (Max ${listingData.quantity}, Price: ${listingData.pricePerItem} each)`, 'number');
                        quantityToBuy = parseInt(quantityStr);
                        if (isNaN(quantityToBuy) || quantityToBuy <= 0 || quantityToBuy > listingData.quantity) {
                            displayMessage("Invalid quantity.", "error");
                            this.showMarketListings(); return;
                        }
                    }

                    const totalPrice = listingData.pricePerItem * quantityToBuy;
                    if ((buyer.resources.spiritStones || 0) < totalPrice) {
                        displayMessage(`Not enough Spirit Stones. You need ${totalPrice}, but have ${buyer.resources.spiritStones || 0}.`, "error");
                        this.showMarketListings(); return;
                    }

                    const confirm = await getModalInput(`Buy ${quantityToBuy}x ${listingData.itemName} for ${totalPrice} Spirit Stones? (yes/no)`);
                    if (confirm && confirm.toLowerCase() === 'yes') {
                        await this.executeBuyItem(listingId, quantityToBuy);
                    } else {
                        displayMessage("Purchase cancelled.", "narration");
                        this.showMarketListings();
                    }

                } catch (error) {
                    console.error("Error prompting for buy:", error);
                    displayMessage("Error processing purchase. Please try again.", "error");
                    this.showMarketListings();
                }
            },
            async executeBuyItem(listingId, quantityToBuy) {
                const buyer = this.players[this.currentPlayerId];
                if (!buyer) return;

                try {
                    await db.runTransaction(async (transaction) => {
                        const listingRef = db.collection("marketListings").doc(listingId);
                        const listingDoc = await transaction.get(listingRef);

                        if (!listingDoc.exists) throw new Error("Listing not found.");
                        const listingData = listingDoc.data();

                        if (listingData.status !== "active") throw new Error("This listing is no longer active.");
                        if (listingData.quantity < quantityToBuy) throw new Error("Not enough items in stock for this quantity.");
                        if (listingData.sellerId === buyer.playerId) throw new Error("You cannot buy your own items.");
                        
                        const totalPrice = listingData.pricePerItem * quantityToBuy;
                        if ((buyer.resources.spiritStones || 0) < totalPrice) throw new Error("Not enough Spirit Stones.");

                        const sellerRef = db.collection("players").doc(listingData.sellerId);
                        const sellerDoc = await transaction.get(sellerRef);
                        if (!sellerDoc.exists) throw new Error("Seller not found. Purchase cannot be completed.");
                        const sellerData = sellerDoc.data();

                        const newBuyerResources = { ...(buyer.resources || {}) };
                        newBuyerResources.spiritStones = (newBuyerResources.spiritStones || 0) - totalPrice;
                        newBuyerResources[listingData.itemId] = (newBuyerResources[listingData.itemId] || 0) + quantityToBuy;

                        const newSellerResources = { ...(sellerData.resources || {}) };
                        newSellerResources.spiritStones = (newSellerResources.spiritStones || 0) + totalPrice;

                        transaction.update(listingRef, {
                            quantity: listingData.quantity - quantityToBuy,
                            status: (listingData.quantity - quantityToBuy === 0) ? "sold" : "active"
                        });
                        const buyerRef = db.collection("players").doc(buyer.playerId);
                        transaction.update(buyerRef, { resources: newBuyerResources });
                        transaction.update(sellerRef, { resources: newSellerResources });

                        this.tempTransactionData = {
                            buyerResources: newBuyerResources,
                            itemBoughtId: listingData.itemId,
                            itemBoughtName: listingData.itemName, 
                            quantityBought: quantityToBuy
                        };
                    });

                    buyer.resources = this.tempTransactionData.buyerResources;
                    displayMessage(`Successfully purchased ${this.tempTransactionData.quantityBought}x ${this.tempTransactionData.itemBoughtName}.`, "market");
                    
                    updateStatsDisplay(buyer); 

                } catch (error) {
                    console.error("Transaction failed: ", error);
                    displayMessage(`Purchase failed: ${error.message}`, "error");
                } finally {
                    delete this.tempTransactionData; 
                    this.showMarketListings(); 
                }
            },
            async promptRemoveListing(listingId) {
                const player = this.players[this.currentPlayerId];
                if (!player) return;

                marketListingsViewDiv.style.display = 'none'; 

                try {
                    const listingDoc = await db.collection("marketListings").doc(listingId).get();
                    if (!listingDoc.exists) {
                        displayMessage("Listing no longer available.", "error");
                        this.showMarketListings(); return;
                    }
                    const listingData = listingDoc.data();

                    if (listingData.sellerId !== player.playerId) {
                        displayMessage("This is not your listing.", "error");
                        this.showMarketListings(); return;
                    }
                    if (listingData.status !== 'active') {
                        displayMessage("This listing is not active and cannot be removed.", "error");
                        this.showMarketListings(); return;
                    }

                    const confirm = await getModalInput(`Remove your listing of ${listingData.quantity}x ${listingData.itemName}? The items will be returned to your inventory. (yes/no)`);
                    if (confirm && confirm.toLowerCase() === 'yes') {
                        await this.executeRemoveListing(listingId);
                    } else {
                        displayMessage("Removal cancelled.", "narration");
                        this.showMarketListings();
                    }

                } catch (error) {
                    console.error("Error prompting for removal:", error);
                    displayMessage("Error processing removal. Please try again.", "error");
                    this.showMarketListings();
                }
            },
            async executeRemoveListing(listingId) {
                const player = this.players[this.currentPlayerId];
                if (!player) return;

                try {
                    await db.runTransaction(async (transaction) => {
                        const listingRef = db.collection("marketListings").doc(listingId);
                        const listingDoc = await transaction.get(listingRef);

                        if (!listingDoc.exists) throw new Error("Listing not found.");
                        const listingData = listingDoc.data();

                        if (listingData.sellerId !== player.playerId) throw new Error("Cannot remove: Not your listing.");
                        if (listingData.status !== "active") throw new Error("Cannot remove: Listing is not active.");

                        const newPlayerResources = { ...(player.resources || {}) };
                        newPlayerResources[listingData.itemId] = (newPlayerResources[listingData.itemId] || 0) + listingData.quantity;
                        
                        transaction.update(listingRef, { status: "removed" });

                        const playerRef = db.collection("players").doc(player.playerId);
                        transaction.update(playerRef, { resources: newPlayerResources });

                        this.tempTransactionData = {
                            playerResources: newPlayerResources,
                            itemRemovedId: listingData.itemId,
                            itemRemovedName: listingData.itemName,
                            quantityRemoved: listingData.quantity
                        };
                    });

                    player.resources = this.tempTransactionData.playerResources;
                    displayMessage(`Successfully removed ${this.tempTransactionData.quantityRemoved}x ${this.tempTransactionData.itemRemovedName} from the market. Items returned to inventory.`, "market");

                    updateStatsDisplay(player); 

                } catch (error) {
                    console.error("Transaction failed (Remove Listing): ", error);
                    displayMessage(`Removal failed: ${error.message}`, "error");
                } finally {
                    delete this.tempTransactionData; 
                    this.showMarketListings(); 
                }
            },

            showConcoctionMenu() {
                this.currentGameState = 'CONCOCTION_MENU';
                concoctionMenuDiv.style.display = 'block';
                actionButtonsContainer.innerHTML = ''; 
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                classSelectionInfoDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                combatInterface.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                if(gridInventoryModal) gridInventoryModal.style.display = 'none';


                const player = this.players[this.currentPlayerId];
                if (!player) { this.showMainGate(); return; }

                concoctionMenuDiv.innerHTML = '<h3>Pill Concoction Chamber</h3>';
                let availableRecipes = [];

                for (const recipeKey in Game.PILL_RECIPES) {
                    const recipe = Game.PILL_RECIPES[recipeKey];
                    if (recipe.isBasic || (player.knownRecipes && player.knownRecipes.includes(recipeKey))) {
                        if (player.cultivationLevel >= recipe.requiredCultivationLevel) {
                            availableRecipes.push(recipe);
                        }
                    }
                }
                
                if (availableRecipes.length === 0) {
                    concoctionMenuDiv.innerHTML += '<p class="text-gray-500 text-center">No recipes known or you do not meet requirements.</p>';
                } else {
                    availableRecipes.sort((a,b) => a.requiredCultivationLevel - b.requiredCultivationLevel || a.name.localeCompare(b.name));
                    
                    availableRecipes.forEach(recipe => {
                        let ingredientsHtml = '<ul class="concoction-ingredient-list">';
                        let canCraft = true;
                        for (const ingKey in recipe.ingredients) {
                            const requiredCount = recipe.ingredients[ingKey];
                            const possessedCount = player.resources[ingKey] || 0;
                            const color = possessedCount >= requiredCount ? 'text-green-400' : 'text-red-400';
                            ingredientsHtml += `<li class="${color}">${Game.ITEM_DATA[ingKey].name}: ${possessedCount}/${requiredCount}</li>`;
                            if (possessedCount < requiredCount) canCraft = false;
                        }
                        ingredientsHtml += '</ul>';

                        const recipeDiv = document.createElement('div');
                        recipeDiv.classList.add('concoction-recipe-item');
                        recipeDiv.innerHTML = `
                            <h4>${recipe.name}</h4>
                            <p><strong>Use:</strong> ${recipe.useDescription}</p>
                            <p><strong>Ingredients:</strong></p>
                            ${ingredientsHtml}
                            <p><strong>Qi Cost:</strong> ${recipe.qiCost}</p>
                            <p><strong>Produces:</strong> ${recipe.productName}</p>
                        `;
                        
                        const concoctButton = document.createElement('button');
                        concoctButton.textContent = "Concoct";
                        concoctButton.classList.add('action-button', 'bg-lime-600', 'hover:bg-lime-700', 'text-gray-900', 'font-semibold', 'py-1', 'px-3', 'rounded', 'mt-2', 'text-sm');
                        if (!canCraft || player.currentQi < recipe.qiCost) {
                            concoctButton.disabled = true;
                            concoctButton.classList.add('opacity-50', 'cursor-not-allowed');
                        }
                        concoctButton.onclick = () => Game.promptConcoctQuantity(recipe.recipeKey);
                        recipeDiv.appendChild(concoctButton);
                        concoctionMenuDiv.appendChild(recipeDiv);
                    });
                }
                
                const backButton = document.createElement('button');
                backButton.textContent = "Back to Menu";
                backButton.classList.add('action-button', 'bg-gray-600', 'hover:bg-gray-700', 'text-white', 'font-semibold', 'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'm-1', 'mt-4', 'mx-auto', 'block');
                backButton.onclick = () => this.showLoggedInMenu();
                concoctionMenuDiv.appendChild(backButton);
            },

            async promptConcoctQuantity(recipeKey) {
                const player = this.players[this.currentPlayerId];
                const recipe = Game.PILL_RECIPES[recipeKey];
                if (!player || !recipe) return;

                let maxPossible = Infinity;
                for (const ingKey in recipe.ingredients) {
                    maxPossible = Math.min(maxPossible, Math.floor((player.resources[ingKey] || 0) / recipe.ingredients[ingKey]));
                }
                if (recipe.qiCost > 0) {
                    maxPossible = Math.min(maxPossible, Math.floor(player.currentQi / recipe.qiCost));
                }
                if (maxPossible === Infinity || maxPossible <= 0) { 
                    displayMessage("Cannot concoct: Not enough resources or Qi for even one.", "error");
                    this.showConcoctionMenu();
                    return;
                }

                const quantityStr = await getModalInput(`How many ${recipe.productName} to concoct? (Max possible: ${maxPossible})`, 'number');
                const quantity = parseInt(quantityStr);

                if (isNaN(quantity) || quantity <= 0) {
                    displayMessage("Invalid quantity.", "error");
                    this.showConcoctionMenu(); 
                    return;
                }
                if (quantity > maxPossible) {
                    displayMessage(`Cannot concoct ${quantity}. You can only make up to ${maxPossible}.`, "error");
                    this.showConcoctionMenu();
                    return;
                }
                await this.executeConcoction(recipeKey, quantity);
            },

            async executeConcoction(recipeKey, quantity) {
                const player = this.players[this.currentPlayerId];
                const recipe = Game.PILL_RECIPES[recipeKey];
                if (!player || !recipe) return;

                if (player.currentQi < recipe.qiCost * quantity) {
                    displayMessage(`Not enough Qi. Need ${recipe.qiCost * quantity}, have ${player.currentQi}.`, "error");
                    this.showConcoctionMenu(); return;
                }

                for (const ingKey in recipe.ingredients) {
                    if ((player.resources[ingKey] || 0) < recipe.ingredients[ingKey] * quantity) {
                        displayMessage(`Not enough ${Game.ITEM_DATA[ingKey].name}. Need ${recipe.ingredients[ingKey] * quantity}, have ${player.resources[ingKey] || 0}.`, "error");
                        this.showConcoctionMenu(); return;
                    }
                }

                player.currentQi -= recipe.qiCost * quantity;

                for (const ingKey in recipe.ingredients) {
                    player.resources[ingKey] -= recipe.ingredients[ingKey] * quantity;
                }

                player.resources[recipe.producesItemKey] = (player.resources[recipe.producesItemKey] || 0) + quantity;

                displayMessage(`Successfully concocted ${quantity}x ${recipe.productName}!`, "crafting");
                
                updateStatsDisplay(player); 
                await this.saveCurrentPlayerState();
                this.showConcoctionMenu(); 
            },


            async handlePlayerChoice(action, value) {
                try {
                    const player = this.players[this.currentPlayerId]; // This might be null for initial actions
                    if (action === 'show_create_form_action') { this.showCreateAccountForm(); return; } // New action
                    if (action === 'show_login_form_action') { this.showLoginForm(); return; }       // New action
                    if (action === 'exit_game') { window.location.reload(); return; }
                    if (action === 'roll_spiritual_root' && player && !player.hasRolledSpiritualRoot) { await this.rollSpiritualRoot(); return; } 
                    if (action === 'show_class_info') { this.showClassInfo(value); return; }
                    if (action === 'select_class') { await this.selectClass(value); return; } 
                    if (action === 'toggle_grid_inventory') { this.toggleGridInventoryModal(); return; } // New action for grid inventory
                    if (action === 'show_market_menu') { this.showMarketMenu(); return; }
                    if (action === 'market_list_item_select') { await this.marketListItemSelect(); return; }
                    if (action === 'list_item_for_sale_prompt') { this.promptListItemForSale(value); return; } 
                    if (action === 'market_view_listings') { await this.showMarketListings(); return; }
                    if (action === 'show_logged_in_menu') { this.showLoggedInMenu(); return; }
                    if (action === 'show_concoction_menu') {
                        if (player && player.chosenClassKey === 'alchemist') {
                            this.showConcoctionMenu();
                        } else {
                            displayMessage("Only Alchemists can concoct pills.", "error"); this.showLoggedInMenu();
                        } return;
                    } 
                    if (action === 'show_concoction_menu') { this.showConcoctionMenu(); return; } 
                    if (action === 'prompt_concoct_quantity') { this.promptConcoctQuantity(value); return; } 

                    // New exploration actions
                    if (action === 'perform_dedicated_explore_action') { await this.performDedicatedExploreAction(value); return; }
                    if (action === 'leave_dedicated_exploration_area') { this.leaveDedicatedExplorationArea(); return; }

                    if (action === 'switch_sect_tab') { this.switchSectDashboardTab(value); return; }
                    if (action === 'prompt_view_player_profile') { this.promptViewPlayerProfile(value.playerId, value.playerName); return; }
                    if (action === 'view_player_profile') { this.viewPlayerProfile(value.playerId, value.playerName); return; }
                    if (action === 'show_player_search') { this.showPlayerSearch(); return; } // Added for menu
                    if (action === 'show_allocate_attributes') { this.showAttributeAllocationMenu(); return; } // New system
                    if (action === 'temp_allocate_point') { this.handleTempAllocatePoint(value); return; }
                    if (action === 'temp_unallocate_point') { this.handleTempUnallocatePoint(value); return; }
                    if (action === 'confirm_attribute_allocations') { await this.confirmAttributeAllocations(); return; }
                    if (action === 'cancel_attribute_allocations') { this.cancelAttributeAllocations(); return; }
                    if (action === 'sect_create_prompt') { this.showSectCreationPanel(); return; }
                    if (action === 'confirm_sect_creation') { await this.confirmSectCreation(); return; }
                    if (action === 'cancel_sect_creation') { this.cancelSectCreation(); return; }

                    if (action === 'show_tianji_pavilion') {
                        this.showTianjiPavilion(); return;
                    }

                    if (!player && action !== 'logout') { displayMessage("Login required.", 'error'); this.showMainGate(); return; }
                    if (player && !player.hasRolledSpiritualRoot && action !== 'logout') {
                        displayMessage("You must first divine your spiritual roots!", "error"); this.showLoggedInMenu(); return;
                    }
                    if (player && !player.hasClassChosen && action !== 'logout' && action !== 'roll_spiritual_root') { 
                        displayMessage("You must first choose your cultivation class!", "error"); this.showClassSelectionMenu(); return;
                    }

                    switch (action) {
                        case 'meditate': player.meditate(); break; 
                        case 'explore': this.exploreArea(); break; // Changed to show area selection
                        case 'explore_specific_area': this.showDedicatedExplorationView(value); break; 
                        case 'manage_sects': this.manageSects(); break;
                        case 'pvp': await this.pvpChallenge(); break; 
                        case 'logout': this.logout(); break;
                        case 'combat_attack': if(this.currentCombat) await this.currentCombat.playerAction('attack'); break; 
                        case 'combat_flee': if(this.currentCombat) await this.currentCombat.playerAction('flee'); break; 
                        case 'combat_attempt_tame': if(this.currentCombat) await this.currentCombat.playerAction('attempt_tame'); break;
                        case 'combat_use_talisman': if(this.currentCombat) await this.currentCombat.playerAction('use_talisman', value); break;
                        case 'ignore_devour_essence': this.ignoreDevourEssence(); break; // New action for ignoring devour
                        case 'combat_use_item': if(this.currentCombat) await this.currentCombat.playerAction('use_combat_item', value); break; 
                        case 'combat_devour_essence': if(this.currentCombat && this.currentCombat.postCombatAction === 'devour_essence_prompt') await Game.devourEssence(); break; 
                        case 'forge_artifact': if(player.chosenClassKey === 'artifact_refiner') await Game.forgeArtifact(); break;
                        case 'draw_talisman': if(player.chosenClassKey === 'talisman_master') await Game.drawTalisman(); break;                        
                        case 'sect_view_all': this.viewAllSects(); break;
                        case 'sect_join_prompt': await this.joinSectPrompt(); break;
                        case 'sect_view_mine': this.viewMySectInfo(); break;
                        case 'sect_leave': this.leaveMySect(); break; 
                        case 'sect_back_to_main': this.showLoggedInMenu(); break;
                        default: displayMessage("Unknown action.", 'error'); if(player) this.showLoggedInMenu(); else this.showMainGate();
                    }
                } catch (e) { console.error(`Error in handlePlayerChoice (${action}):`, e); displayMessage("Action error.", "error"); if (Game.currentPlayerId) Game.showLoggedInMenu(); else Game.showMainGate(); }
            },
            async rollSpiritualRoot() { 
                const player = this.players[this.currentPlayerId];
                if (!player || player.hasRolledSpiritualRoot) return;
                const roll = Math.random() * 1000; 
                let rootName = "", multiplier = 1, qualityMessage = "";
                if (roll < 150) { rootName = "Five Spiritual Roots"; multiplier = 1; qualityMessage = "Common root, slow progress."; } 
                else if (roll < 400) { rootName = "Four Spiritual Roots"; multiplier = 2; qualityMessage = "Low talent, chaotic affinity."; } 
                else if (roll < 700) { rootName = "Three Spiritual Roots"; multiplier = 4; qualityMessage = "Average talent. Focus is key."; } 
                else if (roll < 900) { rootName = "Dual Spiritual Roots"; multiplier = 8; qualityMessage = "Good compatibility, balanced growth."; } 
                else if (roll < 980) { rootName = "Single Spiritual Root"; multiplier = 16; qualityMessage = "Extremely rare, high purity, fast cultivation!"; } 
                else if (roll < 995) { rootName = "Heavenly Spiritual Root"; multiplier = 32; qualityMessage = "Perfect harmony! Divine potential!"; } 
                else { rootName = "Chaos Spiritual Root"; multiplier = 64; qualityMessage = "Mythical root of immense power!";}
                player.spiritualRootName = rootName; player.spiritualRootMultiplier = multiplier; player.hasRolledSpiritualRoot = true;
                displayMessage(`\nSpiritual Roots: <span class="spiritual-root">${rootName}</span>!`, 'important');
                displayMessage(qualityMessage, 'narration'); displayMessage(`Cultivation speed x${multiplier}.`, 'success');
                
                await this.saveCurrentPlayerState(); 
                updateStatsDisplay(player); 
                this.showLoggedInMenu(); 
            },            
            showCreateAccountForm() {
                this.currentGameState = 'CREATE_ACCOUNT_FORM';
                if (document.querySelector('header.mb-4')) document.querySelector('header.mb-4').style.display = 'none';
                if (mainContentArea) mainContentArea.style.display = 'none';
                if (actionButtonsContainer) actionButtonsContainer.style.display = 'none';
                if (loginFormContainer) loginFormContainer.style.display = 'none';
                if (createAccountFormContainer) {
                    createAccountFormContainer.style.display = 'block';
                    clearFormError('create');
                    if (createUsernameInput) createUsernameInput.value = '';
                    if (createPasswordInput) createPasswordInput.value = '';
                    if (createEmailInput) createEmailInput.value = ''; // Clear email input
                    if (createUsernameInput) createUsernameInput.focus();
                }
                if (statsPanelAside) statsPanelAside.style.display = 'none';
                if (gameOutput) gameOutput.innerHTML = ''; 
                if (chatFooter) chatFooter.style.display = 'none';
            },
            showLoginForm() {
                this.currentGameState = 'LOGIN_FORM';
                if (document.querySelector('header.mb-4')) document.querySelector('header.mb-4').style.display = 'none';
                if (mainContentArea) mainContentArea.style.display = 'none';
                if (actionButtonsContainer) actionButtonsContainer.style.display = 'none';
                if (createAccountFormContainer) createAccountFormContainer.style.display = 'none';
                if (loginFormContainer) {
                    loginFormContainer.style.display = 'block';
                    clearFormError('login');
                    if (loginUsernameInput) loginUsernameInput.value = '';
                    if (loginPasswordInput) loginPasswordInput.value = '';
                    if (loginUsernameInput) loginUsernameInput.focus();
                }
                if (statsPanelAside) statsPanelAside.style.display = 'none';
                if (gameOutput) gameOutput.innerHTML = '';
                if (chatFooter) chatFooter.style.display = 'none';
            },
            async handleCreateAccountFormSubmit() {
                clearFormError('create');
                const u = createUsernameInput.value.trim();
                const p = createPasswordInput.value.trim();
                const email = createEmailInput.value.trim() || null; // Get email, default to null if empty

                if (!u || !p) {
                    displayFormError('create', "Username and Password cannot be empty.");
                    return;
                }
                // The cultivator's name will be the username 'u'

                try {
                    const existingUserQuery = await db.collection("players").where("username", "==", u).get();
                    if (!existingUserQuery.empty) {
                        displayFormError('create', "This username is already taken. Please choose another.");
                        return;
                    }
                    // Pass username (u) as name, and the optional email
                    const newPlayer = new Player(u, p, email); 
                    this.players[newPlayer.playerId] = newPlayer; 
                    this.currentPlayerId = newPlayer.playerId;

                    await db.collection("players").doc(newPlayer.playerId).set(newPlayer.toFirestoreObject());
                    localStorage.setItem('currentPlayerId', newPlayer.playerId); // Store session
                    
                    if (createAccountFormContainer) createAccountFormContainer.style.display = 'none';
                    if (document.querySelector('header.mb-4')) document.querySelector('header.mb-4').style.display = 'block';
                    if (mainContentArea) mainContentArea.style.display = 'flex';
                    if (chatFooter) chatFooter.style.display = 'flex';

                    displayMessage(`\nWelcome, ${newPlayer.name}! Account created and saved.`, 'success'); 
                    
                    if (chatInput) {
                        chatInput.disabled = false;
                        chatInput.placeholder = "Type your message...";
                    }
                    if (chatSendButton) chatSendButton.disabled = false;
                    this.listenForChatMessages();
                    this.showLoggedInMenu(); 
                } catch (e) { console.error("Create Account Error:", e); displayMessage("Account creation error. Check console.", "error"); this.showMainGate(); }
            },
            async handleLoginFormSubmit() {
                clearFormError('login');
                const u = loginUsernameInput.value.trim();
                const p = loginPasswordInput.value.trim();

                if (!u || !p) {
                    displayFormError('login', "Username and Password cannot be empty.");
                    return;
                }

                try {
                    const playerQuery = await db.collection("players").where("username", "==", u).get();
                    if (playerQuery.empty) {
                        displayFormError('login', "Invalid username or password.");
                        return;
                    }

                    let foundPlayer = null;
                    playerQuery.forEach(doc => {
                        const playerData = doc.data();
                        if (playerData.password === p) { 
                            foundPlayer = Player.fromFirestoreObject(playerData); // fromFirestoreObject now handles email
                            foundPlayer.playerId = doc.id;
                        }
                    });

                    if (foundPlayer) {
                        this.players[foundPlayer.playerId] = foundPlayer; 
                        this.currentPlayerId = foundPlayer.playerId;
                        if (foundPlayer.sectId) {
                            // Make sure to load all sects the player might be part of or interact with
                            const sectDoc = await db.collection("sects").doc(foundPlayer.sectId).get();
                            if (sectDoc.exists) {
                                this.sects[sectDoc.id] = Sect.fromFirestoreObject(sectDoc.data(), sectDoc.id);
                            } // else: Player's sectId points to a non-existent sect? Handle potential data inconsistency.
                        }

                        if (loginFormContainer) loginFormContainer.style.display = 'none';
                        if (document.querySelector('header.mb-4')) document.querySelector('header.mb-4').style.display = 'block';
                        if (mainContentArea) mainContentArea.style.display = 'flex';
                        if (chatFooter) chatFooter.style.display = 'flex';

                        localStorage.setItem('currentPlayerId', foundPlayer.playerId); // Store session
                        displayMessage(`Welcome back, ${foundPlayer.name}!`, 'success'); 
                        
                        if (chatInput) {
                            chatInput.disabled = false;
                            chatInput.placeholder = "Type your message...";
                        }
                        if (chatSendButton) chatSendButton.disabled = false;
                        this.listenForChatMessages();
                        this.showLoggedInMenu(); 
                    } else { 
                        displayFormError('login', "Invalid username or password.");
                    }
                } catch (e) { console.error("Login Error:", e); displayFormError('login', "Login error. Check console or try again."); }
            },            
            logout() {
                if (this.currentPlayerId && this.players[this.currentPlayerId]) { displayMessage(`Safe travels, ${this.players[this.currentPlayerId].name}.`, 'narration'); }
                else { displayMessage("Logged out.", 'narration'); }
                
                localStorage.removeItem('currentPlayerId'); // Clear session
                this.stopListeningForChatMessages();
                if (chatInput) {
                    chatInput.disabled = true;
                    chatInput.placeholder = "Login to chat...";
                    chatInput.value = '';
                }
                if (chatSendButton) chatSendButton.disabled = true;
                if (chatLogContainer) chatLogContainer.innerHTML = '';

                if (this.currentPlayerId) delete this.players[this.currentPlayerId]; 
                this.currentPlayerId = null; 
                this.showMainGate();
            },

            getMonster(areaKey = null) { // Added areaKey parameter
                const player = this.players[this.currentPlayerId]; 
                if (!player) { 
                    // Default monster if no player context (should ideally not happen in normal gameplay)
                    return new Monster("Lost Spirit", 10, 1,1,1,1,1,1, 0, 5); // health, str, agi, con, spr, int, wil, level, xp
                }
                const pl = player.cultivationLevel;
            
                if (areaKey && this.EXPLORATION_AREAS[areaKey] && this.EXPLORATION_AREAS[areaKey].monsters && this.EXPLORATION_AREAS[areaKey].monsters.length > 0) {
                    const areaMonsters = this.EXPLORATION_AREAS[areaKey].monsters;
                    const randomMonsterKey = areaMonsters[Math.floor(Math.random() * areaMonsters.length)];
                    const monsterData = this.MONSTER_DATA[randomMonsterKey];
                    if (monsterData) {
                        return new Monster(
                            monsterData.name,
                            monsterData.health,
                            monsterData.str || 1, monsterData.agi || 1, monsterData.con || 1, 
                            monsterData.spr || 1, monsterData.intl || 1, monsterData.wil || 1,
                            monsterData.cultivationLevel,
                            monsterData.xpReward,
                            monsterData.tamable,
                            monsterData.image // Pass the image path
                        );
                    }
                }
            
                // Fallback to generic tier-based monster (should be rare if areas are well-defined)
                const monsterTier = Game.getRealmTier(pl);
                const baseStr = 3 + monsterTier * 2 + Math.floor(pl/3);
                const baseCon = 1 + monsterTier + Math.floor(pl/4);
                const baseHealth = 20 + monsterTier * 15 + pl * 2;
                return new Monster(`Generic Tier ${monsterTier} Beast`, baseHealth, baseStr, baseStr-1, baseCon, baseStr-2, 1, 1, pl, 20 + monsterTier * 10 + pl, Math.random() < 0.5, null); // No image for generic
            },
            exploreArea() { // This function now shows the area selection menu
                const player = this.players[this.currentPlayerId];
                if (!player) { this.showMainGate(); return; }
                if (!player.isAlive()) { displayMessage("Too weak to explore.", 'error'); this.showLoggedInMenu(); return; }

                this.currentGameState = 'AREA_SELECTION';
                Game.setMainView('gameplay'); // Ensure correct base layout
                combatInterface.style.display = 'none';
                if (gameOutput) gameOutput.style.display = 'block'; // Ensure log is visible
                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none';
                combatSpecificActions.innerHTML = '';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background for area selection
                
                actionButtonsContainer.innerHTML = ''; // Clear previous buttons/cards
                actionButtonsContainer.classList.add('exploration-mode'); // Apply special styling for exploration cards
                // Ensure the default grid styling for main menu buttons is not active or overridden
                actionButtonsContainer.style.gridTemplateColumns = ''; // Let the .exploration-mode class dictate

                if(gridInventoryModal) gridInventoryModal.style.display = 'none';

                displayMessage("\n--- Choose an Area to Explore ---", 'system');
                const playerRealmTier = Game.getRealmTier(player.cultivationLevel);
                
                const lockIconSvg = `<svg aria-hidden="true" focusable="false" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"></path></svg>`;

                for (const areaKey in this.EXPLORATION_AREAS) {
                    const area = this.EXPLORATION_AREAS[areaKey];
                    const isLocked = playerRealmTier < area.requiredRealmTier;

                    const card = document.createElement('div');
                    card.classList.add('exploration-card');
                    if (isLocked) {
                        card.classList.add('locked-true');
                    }
                    const imageUrl = area.image && area.image !== "null" && area.image !== "" ? area.image : 'assets/areas/default_area.png'; // Ensure you have a default_area.png
                    card.style.backgroundImage = `url('${imageUrl}')`;

                    let cardOverlayContent = `
                        <div class="exploration-card-header">
                            <div>
                                <h4 class="exploration-card-name">${area.name}</h4>
                                <span class="exploration-card-status ${isLocked ? 'locked' : 'unlocked'}">${isLocked ? 'Locked' : 'Unlocked'}</span>
                            </div>
                        </div>
                        <div class="exploration-card-details">
                            <p class="exploration-card-req">Requires: Realm Tier ${area.requiredRealmTier}</p>
                            <p class="exploration-card-desc">${area.description}</p>
                        </div>
                        <button class="action-button exploration-card-button ${isLocked ? 'bg-gray-600 hover:bg-gray-600' : 'bg-green-600 hover:bg-green-700'}" 
                                ${isLocked ? 'disabled' : ''} 
                                onclick="Game.handlePlayerChoice('explore_specific_area', '${areaKey}')">
                            ${isLocked ? 'Locked' : 'Explore'}
                        </button>
                    `;
                    
                    const overlayDiv = document.createElement('div');
                    overlayDiv.classList.add('exploration-card-overlay');
                    overlayDiv.innerHTML = cardOverlayContent;
                    card.appendChild(overlayDiv);

                    if (isLocked) {
                        const lockIconDiv = document.createElement('div');
                        lockIconDiv.classList.add('exploration-card-lock-icon');
                        lockIconDiv.innerHTML = lockIconSvg;
                        card.appendChild(lockIconDiv);
                    }
                    actionButtonsContainer.appendChild(card);
                }

                const backButtonContainer = document.createElement('div');
                backButtonContainer.style.gridColumn = '1 / -1'; 
                backButtonContainer.style.textAlign = 'center';
                backButtonContainer.style.marginTop = '1.5rem';
                const backButton = document.createElement('button');
                backButton.textContent = "Back to Menu";
                backButton.classList.add('action-button', 'bg-slate-700', 'hover:bg-slate-800', 'text-white', 'font-semibold', 'py-3', 'px-6', 'rounded-lg', 'shadow-md');
                backButton.style.minWidth = '220px'; 
                backButton.onclick = () => {
                    actionButtonsContainer.classList.remove('exploration-mode');
                    actionButtonsContainer.style.gridTemplateColumns = ''; // Reset to default from CSS
                    this.showLoggedInMenu();
                };
                backButtonContainer.appendChild(backButton);
                actionButtonsContainer.appendChild(backButtonContainer);
            },
            showDedicatedExplorationView(areaKey) {
                const player = this.players[this.currentPlayerId];
                if (!player) { this.showMainGate(); return; }
                const areaData = this.EXPLORATION_AREAS[areaKey];
                if (!areaData) { displayMessage("Invalid area.", "error"); this.exploreArea(); return; }

                this.currentGameState = 'IN_DEDICATED_EXPLORATION';
                this.currentExploringAreaKey = areaKey;
                Game.setMainView('gameplay'); // Use gameplay layout as base

                // Hide all other specific panels
                combatInterface.style.display = 'none';
                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                if(gridInventoryModal) gridInventoryModal.style.display = 'none';

                actionButtonsContainer.classList.remove('exploration-mode');
                actionButtonsContainer.innerHTML = '';
                // gameOutput.innerHTML = ''; // Optionally clear log, or let it persist

                // Set background image for the dedicated area view
                const imageUrl = areaData.image && areaData.image !== "null" && areaData.image !== "" ? areaData.image : 'assets/areas/default_area.png';
                gameContainer.style.backgroundImage = `url('${imageUrl}')`;
                gameContainer.classList.add('dedicated-exploration-background');

                displayMessage(`\n--- Exploring ${areaData.name} ---`, 'system');

                populateActionButtons([
                    { text: `Explore Deeper in ${areaData.name}`, action: "perform_dedicated_explore_action", value: areaKey, style: "confirm" },
                    { text: `Leave ${areaData.name}`, action: "leave_dedicated_exploration_area", style: "neutral" }
                ], actionButtonsContainer);
            },
            leaveDedicatedExplorationArea() {
                displayMessage(`Leaving ${this.EXPLORATION_AREAS[this.currentExploringAreaKey].name}.`, 'narration');
                this.currentExploringAreaKey = null;
                gameContainer.classList.remove('dedicated-exploration-background');
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset to default background
                // Clear the game output when leaving a dedicated exploration area and returning to area selection
                // to avoid clutter from previous exploration messages.
                if (gameOutput) {
                    // Check if the last message is the "Leaving..." message, if so, keep it, otherwise clear.
                    // Or simply clear it all. For now, let's clear it to make the area selection cleaner.
                    // gameOutput.innerHTML = ''; // Uncomment this if you want a completely clean log
                    // displayMessage("Choose an area to explore.", "system"); // Optional: Add a fresh prompt
                }
                this.exploreArea(); // Show the main list of area cards again
            },
            async performDedicatedExploreAction(areaKey) { 
                const player = this.players[this.currentPlayerId]; if (!player) {this.showMainGate(); return;}
                if (!player.isAlive()) { displayMessage("Too weak to explore.", 'error'); this.showLoggedInMenu(); return; }
                const areaData = this.EXPLORATION_AREAS[areaKey];
                if (!areaData) { displayMessage("Invalid area selected.", "error"); this.showLoggedInMenu(); return; }

                const realmTierToQiCost = { 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 8 };
                const qiCost = realmTierToQiCost[areaData.requiredRealmTier] || 2; // Default to 2 if tier not mapped

                if (player.currentQi < qiCost) {
                    displayMessage(`Not enough Qi to explore ${areaData.name}. You need ${qiCost} Qi, but only have ${player.currentQi}.`, "error");
                    // Optionally, you might want to stay in the dedicated exploration view or go back to area selection.
                    // For now, let's keep them in the dedicated view so they can see the message and then choose to leave.
                    // Or, automatically leave:
                    // this.leaveDedicatedExplorationArea();
                    return;
                }

                player.currentQi -= qiCost;
                displayMessage(`Spent ${qiCost} Qi to explore.`, "system");
                updateStatsDisplay(player); // Update stats immediately after Qi deduction
                // No need to save here yet, will save after other actions or at end of combat.
            
                let foundSomething = false;
                displayMessage(`\nVenturing into ${areaData.name}...`, 'narration');
                let itemsFoundThisExplore = []; 

                // Loot from area's lootTable
                if (areaData.lootTable) {
                    // General chance to find *anything* from the table during dedicated exploration
                    if (Math.random() < 0.65) { // Increased general chance for dedicated exploration
                        areaData.lootTable.forEach(lootEntry => {
                            if (Math.random() < lootEntry.chance) { // Then roll for each specific item in the table
                                const quantity = Math.floor(Math.random() * (lootEntry.maxQuantity - lootEntry.minQuantity + 1)) + lootEntry.minQuantity;
                                
                                if (Game.ITEM_DATA[lootEntry.itemId] && Game.ITEM_DATA[lootEntry.itemId].type === 'recipe') {
                                    const recipeItemKey = lootEntry.itemId;
                                    const recipeLearnsKey = Game.ITEM_DATA[recipeItemKey].learnsRecipeKey;
                                    const pillRecipe = Game.PILL_RECIPES[recipeLearnsKey];

                                    let canDropRecipe = true;
                                    if (pillRecipe) { // Player level relevance for recipes
                                        canDropRecipe = player.cultivationLevel >= (pillRecipe.requiredCultivationLevel - 5) &&
                                                        player.cultivationLevel <= (pillRecipe.requiredCultivationLevel + 10);
                                    } else {
                                        console.warn(`Recipe ${recipeLearnsKey} for item ${recipeItemKey} not found in Game.PILL_RECIPES.`);
                                        canDropRecipe = false;
                                    }

                                    if (canDropRecipe && (!player.knownRecipes || !player.knownRecipes.includes(recipeLearnsKey)) && (!player.resources[recipeItemKey] || player.resources[recipeItemKey] < 1) ) {
                                        player.resources[recipeItemKey] = (player.resources[recipeItemKey] || 0) + quantity;
                                        itemsFoundThisExplore.push(`${Game.ITEM_DATA[recipeItemKey].name}`);
                                        foundSomething = true;
                                    }
                                } else { // For non-recipe items
                                    player.resources[lootEntry.itemId] = (player.resources[lootEntry.itemId] || 0) + quantity;
                                    itemsFoundThisExplore.push(`${Game.ITEM_DATA[lootEntry.itemId].name} (x${quantity})`);
                                    foundSomething = true;
                                }
                            }
                        });
                    }
                } else {
                    console.warn(`Exploring area '${areaKey}' which has no lootTable defined.`);
                }

                // Alchemist bonus can remain generic or be tied to specific herb types if desired
                if (player.chosenClassKey === 'alchemist' && Math.random() < 0.15) { 
                    // Example: Give a common herb or a chance for a random herb from the area table again
                    if (areaData.lootTable && areaData.lootTable.length > 0) {
                        const randomBonusHerbEntry = areaData.lootTable[Math.floor(Math.random() * areaData.lootTable.length)];
                        if (Game.ITEM_DATA[randomBonusHerbEntry.itemId] && Game.ITEM_DATA[randomBonusHerbEntry.itemId].type === 'material') { // Ensure it's a material
                            player.resources[randomBonusHerbEntry.itemId] = (player.resources[randomBonusHerbEntry.itemId] || 0) + 1;
                            itemsFoundThisExplore.push(`an extra ${Game.ITEM_DATA[randomBonusHerbEntry.itemId].name} (Alchemist bonus)`);
                            foundSomething = true;
                        }
                    }
                }

                if(itemsFoundThisExplore.length > 0) {
                     displayMessage(`You found: ${itemsFoundThisExplore.join(', ')}!`, "loot");
                }


                if(foundSomething) {
                    updateStatsDisplay(player); 
                    await this.saveCurrentPlayerState();
                }
                 if (player.chosenClassKey === 'poison_master' && Math.random() < 0.3) { 
                    displayMessage("\nYou sense an opportunity to use your stealth...", 'narration');
                    const choice = await getModalInput("Attempt a Stealthy Approach? (yes/no)");
                    if (choice && choice.toLowerCase() === 'yes') {
                        if (Math.random() < 0.7) { 
                            displayMessage("Your stealthy approach was successful! You avoid any immediate danger and gain some insight.", 'success');
                            player.gainCultivationXP(Math.floor(Math.random() * 5) + 3); 
                            this.showLoggedInMenu();
                            return;
                        } else {
                            displayMessage("Your stealth attempt failed! A creature noticed you!", 'error');
                        }
                    } else if (choice !== null) { // Only show "decide against" if not cancelled
                        displayMessage("You decide against stealth.", 'narration');
                    }
                }

                let monsterEncountered = false;
                // Check if area HAS monsters AND roll for encounter succeeds
                if (areaData.monsters && areaData.monsters.length > 0 && Math.random() < 0.7) {
                    await this.startCombat(player, this.getMonster(areaKey));
                    monsterEncountered = true;
                }

                // If no monster was encountered (either area has no monsters, or encounter roll failed)
                if (!monsterEncountered) {
                    if (!foundSomething) { // Only show "quiet" message if nothing was found
                         displayMessage("The area is quiet. You find a moment to reflect.", 'narration');
                    }
                    // Only give reflection XP if no items were found AND no monster encountered
                    if (!foundSomething) { // Check again, as stealth success might have given XP
                        const baseXp = Math.floor(Math.random()*(3+player.cultivationLevel/2))+2; // Slightly less XP for pure gathering reflection
                        displayMessage(`Gained insights from your surroundings.`, 'success');
                        player.gainCultivationXP(baseXp);
                    }
                    this.showDedicatedExplorationView(areaKey); // Return to the same area's view
                }
            },
            async startCombat(player, opponent) { 
                this.currentGameState = 'COMBAT'; 
                Game.setMainView('gameplay'); // Ensure correct base layout for combat
                combatInterface.style.display = 'block';
                actionButtonsContainer.innerHTML = ''; 
                combatActionText.innerHTML = ''; 
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                if(gridInventoryModal) gridInventoryModal.style.display = 'none'; // Close inventory if open

                displayMessage(`Encounter: ${opponent.name} (${opponent.getCultivationRealmName()})`, 'important'); 
                updateCombatUI(player, opponent);
                this.currentCombat = {
                    player: player, opponent: opponent, turn: 'player', postCombatAction: null,
                    playerAction: async function(action, itemKey) { 
                        if (this.turn!=='player' || !this.player.isAlive() || !this.opponent.isAlive()) return;
                        if (action==='attack') {
                            this.player.attackTarget(this.opponent); 
                        } else if (action==='flee') {
                            displayCombatAction("Attempting to flee...", 'combat-text-narration'); 
                            if (Math.random()<0.5) { 
                                displayMessage("Fled successfully!",'success'); 
                                const areaKeyToReturnTo = Game.currentExploringAreaKey; // Check the area key directly
                                Game.currentCombat=null; 
                                if (areaKeyToReturnTo) {
                                    Game.showDedicatedExplorationView(areaKeyToReturnTo);
                                } else {
                                    Game.showLoggedInMenu(); 
                                }
                                return; 
                            } else {
                                appendCombatAction("Failed to flee!", 'combat-text-opponent-action'); 
                            }
                        } else if (action === 'attempt_tame') {
                            displayCombatAction(`${player.name} attempts to tame the ${opponent.name}...`, 'combat-text-player-action');
                            if (player.currentQi >= 15) {
                                player.currentQi -= 15; 
                                appendCombatAction(`The ${opponent.name} seems wary... (Taming WIP)`, 'combat-text-narration');
                            } else {
                                appendCombatAction("Not enough QI to attempt taming!", 'error');
                            }
                            updateStatsDisplay(player); Game.saveCurrentPlayerState();
                        } else if (action === 'use_talisman') {
                            const talismanData = Game.ITEM_DATA[itemKey];
                            if (player.resources[itemKey] > 0 && talismanData && talismanData.effectInCombat) {
                                if (talismanData.effectInCombat(player, this.opponent)) { 
                                    player.resources[itemKey]--;
                                    updateStatsDisplay(player); 
                                }
                            } else {
                                appendCombatAction("Cannot use this talisman now.", "error");
                            }
                        } else if (action === 'use_combat_item') { 
                             const combatItemData = Game.ITEM_DATA[itemKey];
                             if (player.resources[itemKey] > 0 && combatItemData && combatItemData.usableInCombat && typeof combatItemData.effect === 'function') {
                                 combatItemData.effect(player); 
                             } else {
                                 appendCombatAction("Cannot use this item now.", "error");
                                 this.promptPlayerAction(); 
                                 return;
                             }
                        }
                        else { 
                            displayCombatAction("Invalid action.",'error'); 
                            this.promptPlayerAction(); return; 
                        }
                        
                        if (!this.opponent.isAlive()) {
                            await this.endCombat(true); 
                        } else { 
                            this.turn='opponent'; 
                            setTimeout(()=>this.opponentTurn(), 1000); 
                        }
                    },
                    opponentTurn: async function() { 
                        if (this.turn!=='opponent' || !this.opponent.isAlive() || !this.player.isAlive()) return;
                        displayCombatAction(`--- ${this.opponent.name}'s Turn ---`, 'combat-text-opponent-turn');
                        setTimeout(async () => { 
                           this.opponent.attackTarget(this.player); 
                           if (!this.player.isAlive()) {
                               await this.endCombat(false); 
                           } else { 
                               this.turn='player'; 
                               this.promptPlayerAction(); 
                           }
                        }, 1000); 
                    },
                    promptPlayerAction: function() {
                        if (!this.player.isAlive() || !this.opponent.isAlive()) return; 
                        displayCombatAction(`--- Your Turn ---`, 'combat-text-player-turn'); 
                        let combatActions = [
                            { text: "Attack", action: "combat_attack", style: "danger" },
                        ];

                        const player = Game.players[Game.currentPlayerId];
                        for (const itemKey in player.resources) {
                            if (player.resources[itemKey] > 0 && Game.ITEM_DATA[itemKey] && Game.ITEM_DATA[itemKey].usableInCombat) {
                                const item = Game.ITEM_DATA[itemKey];
                                if (item.type === 'talisman') {
                                     combatActions.push({ text: `Use ${item.name} (x${player.resources[itemKey]})`, action: 'combat_use_talisman', value: itemKey, style: 'special'});
                                } else if (item.type === 'consumable') { 
                                    combatActions.push({ text: `Use ${item.name} (x${player.resources[itemKey]})`, action: 'combat_use_item', value: itemKey, style: 'confirm'});
                                }
                            }
                        }

                        if (player.chosenClassKey === 'beast_tamer' && this.opponent.tamable) {
                            combatActions.push({ text: "Attempt Tame (15 QI)", action: "combat_attempt_tame", style: "special" });
                        }
                         combatActions.push({ text: "Flee", action: "combat_flee", style: "neutral" }); 
                        populateActionButtons(combatActions, combatSpecificActions); 
                    },
                    endCombat: async function(playerWon) { 
                        combatInterface.style.display = 'none'; 
                        combatSpecificActions.innerHTML = ''; 
                        const player = this.player; 
                        if (playerWon) {
                            displayMessage(`${this.opponent.name} slain!`, 'success'); 
                            
                            let baseXp = this.opponent.xpReward || 0;
                            
                            if (player.chosenClassKey === 'heavenly_oracle' && Math.random() < 0.2) { 
                                const bonusXpOracle = Math.floor(baseXp * 0.15); 
                                baseXp += bonusXpOracle;
                                displayMessage("A Glimpse of Fortune blesses you with extra insight!", 'spiritual-root');
                            }
                            if (baseXp > 0) player.gainCultivationXP(baseXp); 

                            let lootFoundMessage = []; 
                            if (this.opponent instanceof Monster) {
                                const droppedLoot = this.opponent.getLootDrops(player);
                                droppedLoot.forEach(lootItem => {
                                    player.resources[lootItem.itemId] = (player.resources[lootItem.itemId] || 0) + lootItem.quantity;
                                    lootFoundMessage.push(`${Game.ITEM_DATA[lootItem.itemId].name} (x${lootItem.quantity})`);
                                });
                            }


                            if(lootFoundMessage.length > 0) {
                                displayMessage(`Loot: ${lootFoundMessage.join(', ')}!`, "loot");
                                updateStatsDisplay(player); 
                            }


                            if (this.opponent instanceof Player) displayMessage("Duel victory! Reputation grows.", 'success');

                            if (player.chosenClassKey === 'demon_cultivator') {
                                displayMessage("The defeated foe's essence lingers... A dark opportunity presents itself.", 'demonic');
                                this.postCombatAction = 'devour_essence_prompt'; 
                                populateActionButtons([ // These buttons appear in the main actionButtonsContainer
                                    { text: "Devour Essence", action: "combat_devour_essence", style: "danger" },
                                    { text: "Ignore", action: "ignore_devour_essence", style: "neutral" } 
                                ], Game.actionButtonsContainer); // Explicitly target main action buttons
                                await Game.saveCurrentPlayerState(); 
                                return; 
                            }

                        } else { 
                            displayMessage("Defeated...", 'error'); 
                            player.health = 1; 
                            displayMessage("Awakened, weakened.", 'narration');
                            if (this.opponent instanceof Player) { 
                                player.cultivationProgress = Math.max(0, player.cultivationProgress - 20);
                                displayMessage("Humbling duel loss.", 'narration');
                            }
                        }
                        await Game.saveCurrentPlayerState(); 
                        updateStatsDisplay(player); 

                        // Game.currentGameState is 'COMBAT' here. Use currentExploringAreaKey to decide.
                        const areaKeyToReturnTo = Game.currentExploringAreaKey;
                        Game.currentCombat=null; 

                        if (areaKeyToReturnTo) {
                            Game.showDedicatedExplorationView(areaKeyToReturnTo);
                        } else {
                            Game.showLoggedInMenu();
                        }
                    }
                };
                this.currentCombat.promptPlayerAction(); 
            },
            ignoreDevourEssence() { // New function to handle ignoring devour
                Game.currentCombat.postCombatAction = null; // Clear the action
                const areaKeyToReturnTo = Game.currentExploringAreaKey;
                if (areaKeyToReturnTo) {
                    Game.showDedicatedExplorationView(areaKeyToReturnTo);
                } else { Game.showLoggedInMenu(); }
            },
            async devourEssence() {
                const player = this.players[this.currentPlayerId];
                if (!player || player.chosenClassKey !== 'demon_cultivator') return;

                const bonusXp = Math.floor(Math.random() * 20) + 10; 
                const corruptionGain = Math.floor(Math.random() * 3) + 1; 

                player.demonicCorruption = (player.demonicCorruption || 0) + corruptionGain;
                displayMessage(`You devour the lingering essence, gaining ${bonusXp} bonus Cultivation XP!`, 'demonic');
                displayMessage(`Your Demonic Corruption increases by ${corruptionGain}. Total: ${player.demonicCorruption}`, 'demonic');
                player.gainCultivationXP(bonusXp); 

                Game.currentCombat.postCombatAction = null; 
                const areaKeyToReturnTo = Game.currentExploringAreaKey;
                if (areaKeyToReturnTo) {
                    Game.showDedicatedExplorationView(areaKeyToReturnTo);
                } else {
                    this.showLoggedInMenu(); 
                }
            },
            async forgeArtifact() {
                const player = this.players[this.currentPlayerId];
                if (!player || player.chosenClassKey !== 'artifact_refiner') {
                    displayMessage("Only Artifact Refiners can forge artifacts.", "error");
                    this.showLoggedInMenu();
                    return;
                }

                this.currentGameState = 'FORGE_ARTIFACT_MENU';
                // Hide other menus
                if (combatInterface) combatInterface.style.display = 'none';
                if (classSelectionInfoDiv) classSelectionInfoDiv.style.display = 'none';
                if (inventoryMenuDiv) inventoryMenuDiv.style.display = 'none';
                if (marketMenuDiv) marketMenuDiv.style.display = 'none';
                if (marketListingsViewDiv) marketListingsViewDiv.style.display = 'none';
                if (concoctionMenuDiv) concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                if (gridInventoryModal) gridInventoryModal.style.display = 'none';
                
                gameContainer.style.backgroundImage = "url('main.png')";
                actionButtonsContainer.innerHTML = ''; // Clear main action buttons for the forging UI

                const forgingMenuDiv = document.createElement('div'); // Create a temporary div for forging UI
                forgingMenuDiv.id = 'forging-menu'; // Assign an ID for potential styling
                forgingMenuDiv.classList.add('rpg-ui-panel', 'p-4', 'max-w-md', 'mx-auto'); // Add some basic styling
                forgingMenuDiv.innerHTML = '<h3 class="text-xl font-bold text-yellow-400 mb-4 text-center">Artifact Forge</h3>';
                
                let hasForgeableRecipes = false;

                for (const recipeKey in Game.ARTIFACT_RECIPES) {
                    const recipe = Game.ARTIFACT_RECIPES[recipeKey];
                    if (recipe.requiredClass === player.chosenClassKey && player.cultivationLevel >= recipe.requiredCultivationLevel) {
                        hasForgeableRecipes = true;
                        let ingredientsHtml = '<ul class="text-sm text-gray-300 mb-1 list-disc list-inside">';
                        let canCraft = true;
                        for (const ingKey in recipe.ingredients) {
                            const requiredCount = recipe.ingredients[ingKey];
                            const possessedCount = player.resources[ingKey] || 0;
                            const color = possessedCount >= requiredCount ? 'text-green-400' : 'text-red-400';
                            ingredientsHtml += `<li class="${color}">${Game.ITEM_DATA[ingKey].name}: ${possessedCount}/${requiredCount}</li>`;
                            if (possessedCount < requiredCount) canCraft = false;
                        }
                        ingredientsHtml += '</ul>';

                        const recipeDiv = document.createElement('div');
                        recipeDiv.classList.add('mb-3', 'p-3', 'bg-gray-700', 'rounded-md', 'border', 'border-gray-600');
                        recipeDiv.innerHTML = `
                            <h4 class="text-lg font-semibold text-yellow-300">${recipe.name}</h4>
                        <img src="${Game.ITEM_DATA[recipe.producesItemKey].gameAsset}" alt="${recipe.productName}" class="mx-auto mb-2 h-20 w-20 object-cover rounded-md">
                            <p class="text-xs text-gray-400">Produces: ${Game.ITEM_DATA[recipe.producesItemKey].name}</p>
                            <p class="text-xs text-gray-400">Requires: ${recipe.qiCost} QI</p>
                            <p class="text-sm font-medium mt-1">Ingredients:</p>
                            ${ingredientsHtml}
                        `;
                        
                        const forgeButton = document.createElement('button');
                        forgeButton.textContent = "Forge Item";
                        forgeButton.classList.add('action-button', 'bg-green-600', 'hover:bg-green-700', 'text-white', 'text-sm', 'py-1', 'px-3', 'rounded', 'mt-2');
                        if (!canCraft || player.currentQi < recipe.qiCost) {
                            forgeButton.disabled = true;
                            forgeButton.classList.add('opacity-50', 'cursor-not-allowed');
                        }

                        forgeButton.onclick = () => Game.displayItemRefiningUI(recipeKey);
                        recipeDiv.appendChild(forgeButton);
                        forgingMenuDiv.appendChild(recipeDiv);

                        const recipeButton = document.createElement('button');
                         recipeButton.textContent = recipe.name;
                         recipeButton.classList.add('action-button'); // Ensure proper styling
                         recipeButton.onclick = () => Game.displayItemRefiningUI(recipeKey);
                    }
                }

                if (!hasForgeableRecipes) {
                    forgingMenuDiv.innerHTML += '<p class="text-gray-400 text-center">No artifacts available to forge at your current skill or level.</p>';
                }

                const backButton = document.createElement('button');
                backButton.textContent = "Back to Menu";
                backButton.classList.add('action-button', 'bg-gray-600', 'hover:bg-gray-700', 'text-white', 'font-semibold', 'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'mt-4', 'mx-auto', 'block');
                backButton.onclick = () => {
                    gameOutput.removeChild(forgingMenuDiv); // Remove the temporary div
                    this.showLoggedInMenu();
                };
                forgingMenuDiv.appendChild(backButton);
                
                // Append the forging menu to gameOutput or another suitable container
                gameOutput.innerHTML = ''; // Clear previous game output
                gameOutput.appendChild(forgingMenuDiv);
            },

            displayItemRefiningUI(recipeKey) {
                const player = this.players[this.currentPlayerId];
                const recipe = Game.ARTIFACT_RECIPES[recipeKey];
                if (!player || !recipe) {
                    displayMessage("Invalid recipe selected.", "error");
                    return;
                }
                
                const STAT_ABBREVIATIONS = {
                    strength: "STR",
                    agility: "AGI",
                    constitution: "CON",
                    spirit: "SPR",
                    intellect: "INT",
                    willpower: "WIL"
                };

                const itemDataForStats = Game.ITEM_DATA[recipe.producesItemKey];
                let statsDisplayString = "No specific stats.";
                if (itemDataForStats.stats && Object.keys(itemDataForStats.stats).length > 0) {
                    statsDisplayString = Object.entries(itemDataForStats.stats)
                        .map(([statKey, statValue]) => `+${statValue} ${STAT_ABBREVIATIONS[statKey] || statKey.toUpperCase()}`)
                        .join(', ');
                }
                if (itemDataForStats.weaponPhysicalAttackBonus) {
                    const attackBonusString = `+${itemDataForStats.weaponPhysicalAttackBonus} Phys. Attack`;
                    statsDisplayString = (statsDisplayString === "No specific stats.") ? attackBonusString : `${statsDisplayString}, ${attackBonusString}`;
                }

                // Clear existing game output
                if (gameOutput) gameOutput.innerHTML = '';
                const itemDiv = document.createElement('div');
                itemDiv.id = 'refining-ui'; // A new ID for the refining UI section
                itemDiv.classList.add('rpg-ui-panel', 'p-4', 'max-w-md', 'mx-auto');
                itemDiv.innerHTML = `
                    <h3 class="text-xl font-bold text-yellow-400 mb-4 text-center">Refining Process: ${recipe.name}</h3>
                    <img src="${itemDataForStats.gameAsset}" alt="${recipe.productName}" class="mx-auto mb-4 h-24 w-24 object-cover rounded-md">
                    <p class="mb-2 text-gray-300"><strong>Stats:</strong> ${statsDisplayString}</p>
                    <h4 class="text-lg font-semibold text-yellow-300 mb-2">Materials Required:</h4>
                    <ul class="list-disc list-inside text-gray-300"></ul>
                    <p class="text-xs text-gray-400">QI Cost: ${recipe.qiCost}</p>
                    <button class="action-button bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg shadow-md mt-4">Craft</button>
                    <button class="action-button bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg shadow-md mt-4" style="margin-left: 0.5rem;">Back to Selection</button>
                `;

                // Populate material list
                const materialsList = itemDiv.querySelector('ul');
                let canCraft = true;
                let hasForgeableRecipes = false; // Initialize here

                for (const ingKey in recipe.ingredients) {
                    const requiredCount = recipe.ingredients[ingKey];
                    const possessedCount = (player.resources[ingKey] || 0);
                    const itemData = Game.ITEM_DATA[ingKey];
                    const color = possessedCount >= requiredCount ? 'text-green-400' : 'text-red-400';

                    const listItem = document.createElement('li');
                    listItem.classList.add(color);
                    listItem.textContent = `${itemData.name}: ${possessedCount}/${requiredCount}`;
                    materialsList.appendChild(listItem);
                    
                     // Early check for required items. If there isn't a recipe, that's an error we want to catch.
                    if (recipe.requiredClass === player.chosenClassKey && player.cultivationLevel >= recipe.requiredCultivationLevel) {
                        hasForgeableRecipes = true;
                    }
                    if (possessedCount < requiredCount) {
                        canCraft = false;
                    }
                }
                  
                 // Check available qi.
                if (player.currentQi < recipe.qiCost) {
                     canCraft = false;
                }
                

                const craftButton = itemDiv.querySelector('button:nth-of-type(1)');
                if (canCraft) {
                    craftButton.onclick = () => Game.executeForgeArtifact(recipeKey);
                } else {
                    craftButton.disabled = true;
                    craftButton.classList.add('opacity-50', 'cursor-not-allowed');
                }

                const backButton = itemDiv.querySelector('button:nth-of-type(2)');
                backButton.onclick = () => { 
                    Game.forgeArtifact(); 
                }
                
                  // Check the hasForgeableRecipes flag after iterating through the ingredients.
                if (!hasForgeableRecipes) {
                  displayMessage("No recipes known or you do not meet requirements.", "narration");
                   canCraft = false; // You can't craft if you don't have a recipe, obviously
                   if (craftButton) {
                     craftButton.disabled = true;
                     craftButton.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                   
                   if (backButton) {
                    backButton.textContent = "Back";
                    backButton.onclick = () => {
                     Game.showLoggedInMenu(); // Or another appropriate "back" navigation.
                     Game.setMainView('gameplay');
                    }
                   }
                 displayMessage("You do not have permission or there are no recipes.", "error");
                  return;
                  
                }
                
                 displayMessage(`Choose item to craft for ${recipe.name}!`, "success");

                 gameOutput.appendChild(itemDiv);
            },

            async executeForgeArtifact(recipeKey) {
                const player = this.players[this.currentPlayerId];
                const recipe = Game.ARTIFACT_RECIPES[recipeKey];
                if (!player || !recipe) return;

                if (player.currentQi < recipe.qiCost) {
                    displayMessage(`Not enough Qi. Need ${recipe.qiCost}, have ${player.currentQi}.`, "error");
                    this.forgeArtifact(); // Refresh menu
                    return;
                }

                for (const ingKey in recipe.ingredients) {
                    if ((player.resources[ingKey] || 0) < recipe.ingredients[ingKey]) {
                        displayMessage(`Not enough ${Game.ITEM_DATA[ingKey].name}. Need ${recipe.ingredients[ingKey]}, have ${player.resources[ingKey] || 0}.`, "error");
                        this.forgeArtifact(); // Refresh menu
                        return;
                    }
                }

                player.currentQi -= recipe.qiCost;
                for (const ingKey in recipe.ingredients) {
                    player.resources[ingKey] -= recipe.ingredients[ingKey];
                }
                player.resources[recipe.producesItemKey] = (player.resources[recipe.producesItemKey] || 0) + 1;

                displayMessage(`Successfully forged 1x ${Game.ITEM_DATA[recipe.producesItemKey].name}!`, "crafting");
                
                updateStatsDisplay(player);
                await this.saveCurrentPlayerState();
                this.forgeArtifact(); // Refresh the forging menu to show updated resources
            },

            async drawTalisman() {
                const player = this.players[this.currentPlayerId];
                if (!player || player.chosenClassKey !== 'talisman_master') return;
                displayMessage("\nAttempting to draw a talisman...", "narration");
                if ((player.resources.blankTalismanPaper || 0) >= 1 && player.currentQi >= 5) {
                    player.resources.blankTalismanPaper -= 1;
                    player.currentQi -= 5;
                    player.resources.minorFireTalisman = (player.resources.minorFireTalisman || 0) + 1;
                    displayMessage("Successfully drew a Minor Fire Talisman!", "success");
                    updateStatsDisplay(player); 
                } else {
                    displayMessage("Not enough Blank Talisman Paper (need 1) or QI (need 5).", "error");
                }
                await this.saveCurrentPlayerState();
                if (Game.currentGameState === 'IN_DEDICATED_EXPLORATION' && Game.currentExploringAreaKey) {
                    Game.showDedicatedExplorationView(Game.currentExploringAreaKey); // Stay in area
                } else {
                    this.showLoggedInMenu();
                }
            },
            manageSects() { 
                const player = this.players[this.currentPlayerId]; 
                if (!player) { this.showMainGate(); return; }

                if (player.sectId && this.sects[player.sectId]) {
                    this.showSectDashboard(player.sectId);
                } else {
                    this.currentGameState = 'SECT_MANAGEMENT_NO_SECT'; 
                    combatInterface.style.display = 'none';
                    Game.setMainView('gameplay'); 
                    concoctionMenuDiv.style.display = 'none';
                    combatSpecificActions.innerHTML = ''; 
                    if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                    const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                    if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                    if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                    if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                    if(gridInventoryModal) gridInventoryModal.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background

                    displayMessage("\n--- Sect Hall ---", 'system');
                    displayMessage("Not in a sect.", 'narration');
                    const actions = [
                        { text: "Create Sect", action: "sect_create_prompt", style: "confirm" }, 
                        { text: "View Sects", action: "sect_view_all" },
                        { text: "Join Sect (ID)", action: "sect_join_prompt" },
                        { text: "Back to Menu", action: "sect_back_to_main", style: "neutral" }
                    ];
                    populateActionButtons(actions, actionButtonsContainer); 
                }
            },
            showSectDashboard(sectId) {
                const player = this.players[this.currentPlayerId];
                const sect = this.sects[sectId];
                if (!player || !sect) {
                    displayMessage("Sect not found or player error.", "error");
                    this.showLoggedInMenu();
                    return;
                }

                this.currentGameState = 'SECT_DASHBOARD';
                this.currentOpenSectId = sectId; // Store current sect being viewed
                Game.setMainView('gameplay'); // Ensure correct base layout

                // Hide all other specific panels
                combatInterface.style.display = 'none';
                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                if(gridInventoryModal) gridInventoryModal.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                actionButtonsContainer.innerHTML = ''; // Clear main action buttons

                // Show the sect dashboard
                sectDashboardPanelDiv.style.display = 'flex';

                // Populate header
                document.getElementById('sect-dashboard-name').textContent = sect.name;
                document.getElementById('sect-dashboard-motto').textContent = sect.motto;

                this.renderSectDashboardTabs(sect);
                this.switchSectDashboardTab(this.currentSectDashboardTab || 'hall', sect); // Default to 'hall' tab

                document.getElementById('sect-dashboard-back-button').onclick = () => {
                    this.currentOpenSectId = null;
                    this.currentSectDashboardTab = null;
                    this.showLoggedInMenu();
                };
            },
            renderSectDashboardTabs(sect) {
                const tabsContainer = document.getElementById('sect-dashboard-tabs');
                tabsContainer.innerHTML = ''; // Clear existing tabs
                const tabDefinitions = [
                    { id: 'hall', name: 'Hall' },
                    { id: 'members', name: 'Members' },
                    { id: 'shop', name: 'Shop' },
                    { id: 'treasury', name: 'Treasury' },
                    { id: 'quests', name: 'Quests/Events' }
                ];

                tabDefinitions.forEach(tabDef => {
                    const button = document.createElement('button');
                    button.id = `sect-tab-${tabDef.id}`;
                    button.classList.add('sect-tab-button');
                    button.textContent = tabDef.name;
                    button.onclick = () => Game.handlePlayerChoice('switch_sect_tab', tabDef.id);
                    tabsContainer.appendChild(button);
                });
            },
            switchSectDashboardTab(tabId, sectToDisplay = null) {
                const sect = sectToDisplay || (this.currentOpenSectId ? this.sects[this.currentOpenSectId] : null);
                if (!sect) return;

                this.currentSectDashboardTab = tabId;
                const contentDiv = document.getElementById('sect-dashboard-main-content');
                contentDiv.innerHTML = ''; // Clear previous content

                // Deactivate all tab buttons
                document.querySelectorAll('.sect-tab-button').forEach(btn => btn.classList.remove('active'));
                // Activate the current tab button
                const activeTabButton = document.getElementById(`sect-tab-${tabId}`);
                if (activeTabButton) activeTabButton.classList.add('active');

                switch (tabId) {
                    case 'hall': Game.renderSectHallTab(sect, contentDiv); break;
                    case 'members': Game.renderSectMembersTab(sect, contentDiv); break;
                    case 'shop': Game.renderSectShopTab(sect, contentDiv); break;
                    case 'treasury': Game.renderSectTreasuryTab(sect, contentDiv); break;
                    case 'quests': Game.renderSectQuestsTab(sect, contentDiv); break;
                    default: contentDiv.innerHTML = '<h4>Unknown Tab</h4><p>Content not found.</p>';
                }
            },
            renderSectHallTab(sect, contentDiv) {
                contentDiv.innerHTML = `<h4>Sect Hall: ${sect.name}</h4>
                                        <p><strong>Description:</strong> <span id="sect-hall-description">${sect.description || "A mysterious sect."}</span></p>
                                        <p><strong>Motto:</strong> "<span id="sect-hall-motto">${sect.motto || "Cultivate and Ascend!"}</span>"</p>
                                        <p><strong>Location:</strong> ${sect.location || "Unspecified Region"}</p>
                                        <p><strong>Founder:</strong> ${sect.founderName || "Unknown"}</p>
                                        <p><strong>Total Members:</strong> ${Object.keys(sect.members || {}).length}</p>
                                        <!-- Add sect buffs display here later -->`;
                
                let hallActionsHtml = '<div class="mt-4 space-y-2">';
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.RENAME_SECT)) { // Assumes "all" for Founder covers rename
                    hallActionsHtml += `<button class="action-button bg-yellow-600 hover:bg-yellow-700 text-sm" onclick="Game.promptRenameSect('${sect.sectId}')">Rename Sect</button>`;
                }
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.EDIT_DESCRIPTION)) {
                    hallActionsHtml += `<button class="action-button bg-yellow-600 hover:bg-yellow-700 text-sm" onclick="Game.promptEditSectDescription('${sect.sectId}')">Edit Description</button>`;
                }
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.SET_MOTTO)) {
                    hallActionsHtml += `<button class="action-button bg-yellow-600 hover:bg-yellow-700 text-sm" onclick="Game.promptEditSectMotto('${sect.sectId}')">Edit Motto</button>`;
                }
                hallActionsHtml += '</div>';
                contentDiv.innerHTML += hallActionsHtml;
            },
            renderSectMembersTab(sect, contentDiv) {
                contentDiv.innerHTML = `<h4>Sect Members</h4>`;
                const player = this.players[this.currentPlayerId];

                if (this.hasSectPermission(player.playerId, sect.sectId, this.SECT_PERMISSIONS.ACCEPT_NEW_MEMBER)) {
                    contentDiv.innerHTML += `<button class="action-button bg-green-500 hover:bg-green-600 text-sm mb-3" onclick="Game.promptInviteMemberToSect('${sect.sectId}')">Invite Member (by Name)</button>`;
                }

                let membersHtml = '<div class="space-y-2">';
                const sortedMemberIds = Object.keys(sect.members).sort((a, b) => {
                    const rankOrderA = this.getRankOrder(sect.members[a].role, sect.ranks);
                    const rankOrderB = this.getRankOrder(sect.members[b].role, sect.ranks);
                    if (rankOrderA !== rankOrderB) return rankOrderA - rankOrderB;
                    return (sect.members[a].playerName || '').localeCompare(sect.members[b].playerName || '');
                });

                sortedMemberIds.forEach(memberId => {
                    const member = sect.members[memberId];
                    membersHtml += `<div class="p-2 bg-gray-700 rounded">
                                        <p class="font-semibold">${member.playerName} <span class="text-xs text-gray-400">(${member.role})</span></p>
                                        <p class="text-xs">Contribution: ${member.contributionPoints || 0}</p>`;
                    
                    if (player.playerId !== memberId) { // Don't show actions for oneself
                        if (this.hasSectPermission(player.playerId, sect.sectId, this.SECT_PERMISSIONS.PROMOTE_MEMBER, memberId)) {
                            membersHtml += `<button class="action-button bg-blue-500 hover:bg-blue-600 text-xs py-1 px-2 mr-1" onclick="Game.promptPromoteMember('${sect.sectId}', '${memberId}')">Promote</button>`;
                        }
                        if (this.hasSectPermission(player.playerId, sect.sectId, this.SECT_PERMISSIONS.DEMOTE_MEMBER, memberId)) {
                            membersHtml += `<button class="action-button bg-yellow-500 hover:bg-yellow-600 text-xs py-1 px-2 mr-1" onclick="Game.promptDemoteMember('${sect.sectId}', '${memberId}')">Demote</button>`;
                        }
                        if (this.hasSectPermission(player.playerId, sect.sectId, this.SECT_PERMISSIONS.KICK_MEMBER, memberId)) {
                            membersHtml += `<button class="action-button bg-red-500 hover:bg-red-600 text-xs py-1 px-2" onclick="Game.confirmKickMember('${sect.sectId}', '${memberId}')">Kick</button>`;
                        }
                    }
                    membersHtml += `</div>`;
                });
                membersHtml += `</div>`;
                contentDiv.innerHTML += membersHtml;
            },
            renderSectShopTab(sect, contentDiv) {
                contentDiv.innerHTML = `<h4>Sect Shop</h4>`;
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.BUY_FROM_SECT_SHOP)) {
                    contentDiv.innerHTML += `<p>Welcome! Browse sect-exclusive items. (Shop items TBD)</p>
                                             <!-- Example: <button onclick="Game.buyFromSectShop('${sect.sectId}', 'item_id')">Buy Healing Pill (100 Contrib)</button> -->`;
                } else {
                    contentDiv.innerHTML += `<p>You do not have permission to purchase from the sect shop. Increase your rank or contribution.</p>`;
                }
            },
            renderSectTreasuryTab(sect, contentDiv) {
                contentDiv.innerHTML = `<h4>Sect Treasury</h4>
                                        <p>Current Spirit Stones: <span id="sect-treasury-stones">${sect.treasury.spiritStones || 0}</span></p>`;
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.DONATE_TO_TREASURY)) {
                    contentDiv.innerHTML += `<div class="mt-3">
                                                <input type="number" id="sect-donate-amount" class="modal-input w-1/2 inline-block" placeholder="Amount">
                                                <button class="action-button bg-green-500 hover:bg-green-600 text-sm ml-2" onclick="Game.donateToSectTreasury('${sect.sectId}')">Donate Spirit Stones</button>
                                             </div>`;
                }
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.MANAGE_TREASURY)) {
                     contentDiv.innerHTML += `<p class="mt-2 text-yellow-400">Treasury management features (withdraw, logs) coming soon.</p>`;
                }
            },
            renderSectQuestsTab(sect, contentDiv) {
                contentDiv.innerHTML = `<h4>Sect Quests & Events</h4>`;
                if (this.hasSectPermission(this.currentPlayerId, sect.sectId, this.SECT_PERMISSIONS.START_SECT_EVENT)) {
                    contentDiv.innerHTML += `<button class="action-button bg-purple-500 hover:bg-purple-600 text-sm mb-3" onclick="Game.startSectEvent('${sect.sectId}')">Start New Sect Event (Placeholder)</button>`;
                }
                contentDiv.innerHTML += `<p>Daily and weekly missions for the sect. (Coming Soon)</p>`;
            },
            showSectCreationPanel() {
                const player = this.players[this.currentPlayerId];
                if (!player) { this.showMainGate(); return; }

                if (player.sectId) { 
                    displayMessage("You are already in a sect. You must leave your current sect to create a new one.", 'error'); 
                    this.manageSects(); 
                    return; 
                }
                if (player.cultivationLevel < 10) { 
                    displayMessage("You must reach the Foundation Establishment realm (Level 10) to create a sect.", 'error'); 
                    this.manageSects(); 
                    return; 
                }
                if ((player.resources.spiritStones || 0) < 1000) {
                    displayMessage("You need at least 1000 Spirit Stones to establish a sect.", 'error');
                    this.manageSects();
                    return;
                }

                this.currentGameState = 'SECT_CREATION_PANEL';
                Game.setMainView('gameplay'); // Or a specific view if you create one
                
                // Hide other specific panels
                combatInterface.style.display = 'none';
                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none';
                const attributeAllocationDiv = document.getElementById('attribute-allocation-menu');
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (attributeAllocationDiv) attributeAllocationDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                actionButtonsContainer.innerHTML = ''; // Clear main action buttons

                sectCreationPanelDiv.style.display = 'block';
                sectCreationPanelDiv.innerHTML = `
                    <h3>Establish Your Sect</h3>
                    <div><label for="sect-create-name">Sect Name:</label><input type="text" id="sect-create-name" class="form-input"></div>
                    <div><label for="sect-create-banner-url">Banner URL (optional):</label><input type="text" id="sect-create-banner-url" class="form-input" placeholder="https://example.com/banner.png"></div>
                    <div><label for="sect-create-motto">Sect Motto:</label><input type="text" id="sect-create-motto" class="form-input"></div>
                    <div>
                        <label for="sect-create-location">Sect Location:</label>
                        <select id="sect-create-location" class="form-select">
                            <option value="Hidden Mountain Valley">Hidden Mountain Valley</option>
                            <option value="Floating Cloud Peak">Floating Cloud Peak</option>
                            <option value="Ancient Forest Grove">Ancient Forest Grove</option>
                            <option value="Volcanic Caldera Stronghold">Volcanic Caldera Stronghold</option>
                            <option value="Sunken City Ruins">Sunken City Ruins</option>
                            <option value="Whispering Bamboo Thicket">Whispering Bamboo Thicket</option>
                            <option value="Celestial Pagoda Heights">Celestial Pagoda Heights</option>
                            <option value="Desolate Badlands Outpost">Desolate Badlands Outpost</option>
                        </select>
                    </div>
                    <p class="text-sm text-gray-400 mt-2">Cost: 1000 Spirit Stones</p>
                    <div id="sect-creation-panel-actions">
                        <button class="action-button bg-green-600 hover:bg-green-700" onclick="Game.handlePlayerChoice('confirm_sect_creation')">Create Sect</button>
                        <button class="action-button bg-red-600 hover:bg-red-700" onclick="Game.handlePlayerChoice('cancel_sect_creation')">Cancel</button>
                    </div>
                `;
            },
            cancelSectCreation() {
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                this.manageSects();
            },
            async confirmSectCreation() {
                const player = this.players[this.currentPlayerId]; if (!player) {this.showMainGate(); return;}
                try {
                    // Re-check requirements on confirm, though showSectCreationPanel should prevent access if not met
                    if (player.sectId) { displayMessage("You are already in a sect.", 'error'); this.cancelSectCreation(); return; }
                    if (player.cultivationLevel < 10) { displayMessage("Must be Foundation Establishment (Level 10).", 'error'); this.cancelSectCreation(); return; }
                    if ((player.resources.spiritStones || 0) < 1000) { displayMessage("Not enough Spirit Stones (need 1000).", 'error'); this.cancelSectCreation(); return; }

                    const name = document.getElementById('sect-create-name').value.trim();
                    const bannerUrl = document.getElementById('sect-create-banner-url').value.trim() || null;
                    const motto = document.getElementById('sect-create-motto').value.trim() || "To cultivate immortality and tread the path of the strong!";
                    const location = document.getElementById('sect-create-location').value;

                    if (!name) { displayMessage("Sect Name cannot be empty.", 'error'); return; }
                    
                    const sectNameQuery = await db.collection("sects").where("name", "==", name).get();
                    if (!sectNameQuery.empty) {
                        displayMessage("A sect with this name already exists.", 'error'); this.manageSects(); return;
                    }

                    player.resources.spiritStones -= 1000;

                    const description = `The illustrious ${name} Sect, founded by ${player.name}.`; // Default description
                    const newSect = new Sect(name, player.playerId, player.name, description, motto, location, bannerUrl);
                    await db.collection("sects").doc(newSect.sectId).set(newSect.toFirestoreObject());
                    this.sects[newSect.sectId] = newSect; // Add to local cache
                    player.joinSect(newSect.sectId); // Player automatically joins
                    displayMessage(`Sect '${name}' established! You are the Founder.`, 'success');
                    if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                    this.manageSects(); // Go back to sect management view
                } catch (e) { console.error("Confirm Sect Creation Error:", e); displayMessage("Sect creation error.", "error"); }
            },
            viewAllSects() { 
                if (Object.keys(this.sects).length===0) { displayMessage("No sects yet.",'narration'); }
                else { displayMessage("\n--- Available Sects ---", 'system');
                    Object.values(this.sects).forEach(s => {
                        const fN = (this.players[s.founderId] && this.players[s.founderId].name) ? this.players[s.founderId].name : 'Unknown Founder'; 
                        const memberCount = s.members ? Object.keys(s.members).length : 0;
                        displayMessage(`ID: ${s.sectId} | Name: ${s.name} (Founder: ${s.founderName || fN}) | Members: ${memberCount} | Motto: ${s.motto}`); });
                } this.manageSects(); 
            },
            async joinSectPrompt() { 
                const player = this.players[this.currentPlayerId]; if (!player) { this.showMainGate(); return; }
                try {
                    if (player.sectId) { displayMessage("Already in a sect.", 'error'); this.manageSects(); return; }
                    if (Object.keys(this.sects).length === 0) { displayMessage("No sects to join.", 'narration'); this.manageSects(); return; }
                    const id = await getModalInput("Sect ID to join:"); if (!id) { displayMessage("Cancelled.", "narration"); this.manageSects(); return; }
                    
                    // Check if sect exists locally first, then try to load from DB if not found
                    if (this.sects[id]) {
                        const sectToJoin = this.sects[id];
                        // Basic check: can player join? (e.g. not full, meets requirements - for future)
                        // For now, just allow join if sect exists.
                        player.joinSect(id); // This updates player.sectId and saves player
                        // The sect's addMember method should be called by player.joinSect or here
                        // For now, let's assume player.joinSect handles adding to sect.members if needed,
                        // or we call it explicitly.
                        // sectToJoin.addMember(player.playerId, player.name); // This might be redundant if player.joinSect does it.
                    } else {
                        // TODO: Implement loading sect from DB if not in local cache, then join.
                        displayMessage("Sect ID not found locally. (Loading from DB not yet implemented for join).", 'error');
                    }
                } catch (e) { console.error("Join Sect Error:", e); displayMessage("Join sect error.", "error"); }
                this.manageSects();
            },
            viewMySectInfo() { 
                const player = this.players[this.currentPlayerId]; if (!player) { this.showMainGate(); return; }
                if (player.sectId && this.sects[player.sectId]) {
                    this.showSectDashboard(player.sectId); // Directly show the dashboard
                } else { displayMessage("Not in a sect.", 'error'); this.manageSects(); }
            },
            leaveMySect() { const player = this.players[this.currentPlayerId]; if (!player) {this.showMainGate(); return;} player.leaveSect(); this.manageSects(); }, 
            async pvpChallenge() { 
                const player = this.players[this.currentPlayerId]; if (!player) {this.showMainGate(); return;}
                if (!player.isAlive()) { displayMessage("Too weak for duel.", 'error'); this.showLoggedInMenu(); return; }
                Game.setMainView('gameplay'); // Ensure correct base layout
                const rL = Math.max(1, player.cultivationLevel + (Math.floor(Math.random()*5)-2)); 
                const rNs = ["Shadow Lin", "Azure Fang", "Silent Gao", "Crimson Hua", "Iron Fist Zhao"];
                const rN = rNs[Math.floor(Math.random()*rNs.length)];
                // Create rival as a Player object for consistent combat, but with stats set like a monster for simplicity
                const rival = new Player("rival_" + Game.generateId(), "p", rN); // username, password, name
                rival.cultivationLevel = rL;
                rival.strength = 5 + Math.floor(rL / 2);
                rival.constitution = 3 + Math.floor(rL / 3);
                rival.spirit = 4 + Math.floor(rL / 2.5);
                // Other attributes can be base or slightly randomized
                rival.maxHealth = rival.calculateMaxHealth() + rL * 5; // Give them a bit more health
                rival.health = rival.maxHealth;
                rival.maxQi = rival.calculateMaxQi(); rival.currentQi = rival.maxQi;
                rival.resources.spiritStones = Math.floor(Math.random() * (rL * 5)); 

                displayMessage(`\nRival ${rival.name} (${rival.getCultivationRealmName()}) challenges you to a duel!`, 'important'); 
                await this.startCombat(player, rival); 
            },

            showAttributeAllocationMenu() {
                const player = this.players[this.currentPlayerId];
                if (!player || player.freeAttributePoints <= 0) {
                    displayMessage("No free attribute points to allocate.", "narration");
                    this.showLoggedInMenu();
                    return; // Should not happen if button is hidden, but good check
                }

                // Initialize temporary allocation state if opening for the first time in this game session or if reset
                if (this.currentGameState !== 'ATTRIBUTE_ALLOCATION' || Object.keys(this.tempAttributeAllocations).length === 0) {
                    this.initialFreeAttributePointsForSession = player.freeAttributePoints;
                    this.tempAttributeAllocations = { strength: 0, agility: 0, constitution: 0, spirit: 0, intellect: 0, willpower: 0 };
                }

                this.currentGameState = 'ATTRIBUTE_ALLOCATION';
                Game.setMainView('gameplay'); // Ensure correct base layout
                combatInterface.style.display = 'none';
                classSelectionInfoDiv.style.display = 'none';
                inventoryMenuDiv.style.display = 'none';
                marketMenuDiv.style.display = 'none';
                marketListingsViewDiv.style.display = 'none';
                concoctionMenuDiv.style.display = 'none'; // Hide concoction menu
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if(gridInventoryModal) gridInventoryModal.style.display = 'none';

                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                const allocationDiv = document.getElementById('attribute-allocation-menu');
                allocationDiv.style.display = 'block';
                allocationDiv.classList.add('rpg-ui-panel'); // Apply panel styling

                let totalSpentFromTemp = Object.values(this.tempAttributeAllocations).reduce((sum, val) => sum + val, 0);
                let currentDisplayableFreePoints = this.initialFreeAttributePointsForSession - totalSpentFromTemp;

                allocationDiv.innerHTML = `<h3>Allocate Attribute Points</h3>
                                           <p id="available-points-display">Available Points: <strong class="text-yellow-400">${currentDisplayableFreePoints}</strong></p>`;
                
                const attributes = [
                    { key: 'strength', name: 'Strength' }, { key: 'agility', name: 'Agility' },
                    { key: 'constitution', name: 'Constitution' }, { key: 'spirit', name: 'Spirit' },
                    { key: 'intellect', name: 'Intellect' }, { key: 'willpower', name: 'Willpower' }
                ];

                attributes.forEach(attr => {
                    const baseValue = player[attr.key];
                    const increment = this.tempAttributeAllocations[attr.key] || 0;
                    const displayValue = baseValue + increment;

                    allocationDiv.innerHTML += `
                        <div class="attribute-allocation-row">
                            <span class="attr-name">${attr.name}</span>
                            <div class="attr-controls">
                                <button onclick="Game.handlePlayerChoice('temp_unallocate_point', '${attr.key}')" ${increment === 0 ? 'disabled' : ''}>-</button>
                                <span class="attr-value">${displayValue}</span>
                                <button onclick="Game.handlePlayerChoice('temp_allocate_point', '${attr.key}')" ${currentDisplayableFreePoints === 0 ? 'disabled' : ''}>+</button>
                            </div>
                        </div>
                    `;
                });

                // Add Confirm and Cancel buttons at the bottom of the allocationDiv
                const actionButtonsDiv = document.createElement('div');
                actionButtonsDiv.id = 'attribute-allocation-actions';
                actionButtonsDiv.innerHTML = `
                    <button class="action-button bg-green-600 hover:bg-green-700" onclick="Game.handlePlayerChoice('confirm_attribute_allocations')">Confirm</button>
                    <button class="action-button bg-red-600 hover:bg-red-700" onclick="Game.handlePlayerChoice('cancel_attribute_allocations')">Cancel</button>
                `;
                allocationDiv.appendChild(actionButtonsDiv);
                
                // Clear the main actionButtonsContainer as buttons are now inside allocationDiv
                actionButtonsContainer.innerHTML = '';
            },

            handleTempAllocatePoint(attributeKey) {
                let totalSpentFromTemp = Object.values(this.tempAttributeAllocations).reduce((sum, val) => sum + val, 0);
                if (this.initialFreeAttributePointsForSession - totalSpentFromTemp > 0) {
                    this.tempAttributeAllocations[attributeKey] = (this.tempAttributeAllocations[attributeKey] || 0) + 1;
                    this.showAttributeAllocationMenu(); // Refresh UI
                } else {
                    displayMessage("No more points available to allocate.", "error");
                }
            },

            handleTempUnallocatePoint(attributeKey) {
                if (this.tempAttributeAllocations[attributeKey] > 0) {
                    this.tempAttributeAllocations[attributeKey]--;
                    this.showAttributeAllocationMenu(); // Refresh UI
                }
            },

            async confirmAttributeAllocations() {
                const player = this.players[this.currentPlayerId];
                if (!player) return;

                for (const attrKey in this.tempAttributeAllocations) {
                    player[attrKey] += this.tempAttributeAllocations[attrKey];
                }
                let totalSpent = Object.values(this.tempAttributeAllocations).reduce((sum, val) => sum + val, 0);
                player.freeAttributePoints = this.initialFreeAttributePointsForSession - totalSpent;

                player.maxHealth = player.calculateMaxHealth();
                player.maxQi = player.calculateMaxQi();
                // Optionally, heal to new max: player.health = player.maxHealth; player.currentQi = player.maxQi;

                this.tempAttributeAllocations = {}; // Reset temp
                this.initialFreeAttributePointsForSession = 0;
                await this.saveCurrentPlayerState();
                updateStatsDisplay(player);
                displayMessage("Attributes updated!", "success");
                this.showLoggedInMenu();
            },

            cancelAttributeAllocations() {
                this.tempAttributeAllocations = {}; // Reset temp
                this.initialFreeAttributePointsForSession = 0;
                displayMessage("Attribute allocation cancelled.", "narration");
                this.showLoggedInMenu();
            },
            // --- START: Sect Action Handlers with Permission Checks ---
            async promptRenameSect(sectId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.RENAME_SECT)) { // Assumes "all" for Founder
                    displayMessage("You do not have permission to rename the sect.", "error"); return;
                }
                const newName = await getModalInput("Enter new sect name:");
                if (newName && newName.trim() !== "") {
                    const sect = this.sects[sectId];
                    sect.name = newName.trim();
                    document.getElementById('sect-dashboard-name').textContent = sect.name; // Update dashboard header
                    // Potentially update player's stat display if sect name is shown there with role
                    if (this.players[this.currentPlayerId].sectId === sectId) updateStatsDisplay(this.players[this.currentPlayerId]);
                    await this.saveSectData(sectId);
                    displayMessage(`Sect renamed to ${sect.name}.`, "success");
                } else { displayMessage("Rename cancelled or invalid name.", "narration"); }
            },
            async promptEditSectDescription(sectId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.EDIT_DESCRIPTION)) {
                    displayMessage("You do not have permission to edit the description.", "error"); return;
                }
                const currentDesc = this.sects[sectId].description;
                const newDesc = await getModalInput(`Enter new sect description (current: ${currentDesc}):`);
                if (newDesc !== null) { // Allow empty string to clear description
                    this.sects[sectId].description = newDesc.trim();
                    document.getElementById('sect-hall-description').textContent = this.sects[sectId].description;
                    await this.saveSectData(sectId);
                    displayMessage(`Sect description updated.`, "success");
                } else { displayMessage("Edit cancelled.", "narration"); }
            },
            async promptEditSectMotto(sectId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.SET_MOTTO)) {
                    displayMessage("You do not have permission to set the motto.", "error"); return;
                }
                const currentMotto = this.sects[sectId].motto;
                const newMotto = await getModalInput(`Enter new sect motto (current: "${currentMotto}"):`);
                if (newMotto && newMotto.trim() !== "") {
                    this.sects[sectId].motto = newMotto.trim();
                    document.getElementById('sect-hall-motto').textContent = this.sects[sectId].motto;
                    document.getElementById('sect-dashboard-motto').textContent = this.sects[sectId].motto;
                    await this.saveSectData(sectId);
                    displayMessage(`Sect motto updated.`, "success");
                } else { displayMessage("Edit cancelled or invalid motto.", "narration"); }
            },
            async promptInviteMemberToSect(sectId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.ACCEPT_NEW_MEMBER)) {
                    displayMessage("You do not have permission to invite members.", "error"); return;
                }
                const playerName = await getModalInput("Enter name of the player to invite:");
                if (playerName && playerName.trim() !== "") {
                    // In a real multi-user system, you'd search for this player, send an invite.
                    // For this client-side setup, this is more of a placeholder.
                    // If we had a list of all players, we could try to find them.
                    displayMessage(`Invite functionality for '${playerName.trim()}' is a placeholder. In a full system, an invitation would be sent.`, "system");
                    // For now, let's assume this would eventually lead to an "accept application" flow or direct add.
                } else { displayMessage("Invite cancelled.", "narration"); }
            },
            async promptPromoteMember(sectId, targetMemberId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.PROMOTE_MEMBER, targetMemberId)) {
                    displayMessage("You do not have permission or the target is not of lower rank.", "error"); return;
                }
                // TODO: Implement logic to select next higher rank and confirm.
                displayMessage(`Promote member ${this.sects[sectId].members[targetMemberId].playerName}? (Full UI for rank selection TBD)`, "system");
                // Placeholder: sect.promoteMember(this.currentPlayerId, targetMemberId); then re-render tab.
            },
            async promptDemoteMember(sectId, targetMemberId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.DEMOTE_MEMBER, targetMemberId)) {
                    displayMessage("You do not have permission or the target is not of lower rank.", "error"); return;
                }
                // TODO: Implement logic to select next lower rank and confirm.
                displayMessage(`Demote member ${this.sects[sectId].members[targetMemberId].playerName}? (Full UI for rank selection TBD)`, "system");
            },
            async confirmKickMember(sectId, targetMemberId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.KICK_MEMBER, targetMemberId)) {
                    displayMessage("You do not have permission or the target is not of lower rank.", "error"); return;
                }
                const targetName = this.sects[sectId].members[targetMemberId].playerName;
                const confirm = await getModalInput(`Are you sure you want to kick ${targetName} from the sect? (yes/no)`);
                if (confirm && confirm.toLowerCase() === 'yes') {
                    // TODO: Implement sect.kickMember(actingPlayerId, targetMemberId);
                    // Then, update player's sectId and sectRole if they are the one kicked.
                    // And re-render the members tab.
                    displayMessage(`${targetName} has been kicked (Placeholder).`, "success");
                } else { displayMessage("Kick cancelled.", "narration"); }
            },
            async donateToSectTreasury(sectId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.DONATE_TO_TREASURY)) {
                    displayMessage("You do not have permission to donate.", "error"); return;
                }
                const player = this.players[this.currentPlayerId];
                const amountStr = document.getElementById('sect-donate-amount').value;
                const amount = parseInt(amountStr);
                if (isNaN(amount) || amount <= 0) { displayMessage("Invalid amount.", "error"); return; }
                if ((player.resources.spiritStones || 0) < amount) { displayMessage("Not enough Spirit Stones.", "error"); return; }
                
                const sect = this.sects[sectId];
                player.resources.spiritStones -= amount;
                sect.treasury.spiritStones = (sect.treasury.spiritStones || 0) + amount;

                // Award contribution points (1:1 for spirit stones for now)
                const contributionGained = amount;
                if (sect.members[player.playerId]) {
                    sect.members[player.playerId].contributionPoints = (sect.members[player.playerId].contributionPoints || 0) + contributionGained;
                }
                sect.totalContributionPoints = (sect.totalContributionPoints || 0) + contributionGained;
                sect.logContribution(player.playerId, player.name, "donated_spirit_stones", `Donated ${amount} Spirit Stones.`, contributionGained);

                document.getElementById('sect-treasury-stones').textContent = sect.treasury.spiritStones;
                updateStatsDisplay(player);
                await this.saveCurrentPlayerState();
                await this.saveSectData(sectId);
                displayMessage(`Donated ${amount} Spirit Stones to the sect treasury. Gained ${contributionGained} contribution points.`, "success");
                // Re-render members tab if it's active to show updated contribution
                if (this.currentSectDashboardTab === 'members') this.renderSectMembersTab(sect, document.getElementById('sect-dashboard-main-content'));
                document.getElementById('sect-donate-amount').value = ''; // Clear input
            },
            async startSectEvent(sectId) {
                if (!this.hasSectPermission(this.currentPlayerId, sectId, this.SECT_PERMISSIONS.START_SECT_EVENT)) {
                    displayMessage("You do not have permission to start sect events.", "error"); return;
                }
                displayMessage("Starting a new sect event... (Placeholder - event system TBD)", "system");
            },
            // --- Placeholder functions for other contribution sources ---
            async awardContributionForQuest(playerId, sectId, points, questName = "Unnamed Quest") {
                const player = this.players[playerId];
                const sect = this.sects[sectId];
                if (!player || !sect || !sect.members[playerId]) {
                    console.error("Cannot award contribution: Player or Sect not found, or player not in sect."); return;
                }
                sect.members[playerId].contributionPoints = (sect.members[playerId].contributionPoints || 0) + points;
                sect.totalContributionPoints = (sect.totalContributionPoints || 0) + points;
                sect.logContribution(playerId, player.name, "completed_sect_quest", `Completed '${questName}' quest.`, points);
                await this.saveSectData(sectId);
                displayMessage(`${player.name} gained ${points} contribution points for completing the sect quest: ${questName}.`, "success");
            },
            async awardContributionForPvpWin(playerId, sectId, points, eventName = "PvP Event") {
                const player = this.players[playerId];
                const sect = this.sects[sectId];
                if (!player || !sect || !sect.members[playerId]) {
                    console.error("Cannot award contribution: Player or Sect not found, or player not in sect."); return;
                }
                sect.members[playerId].contributionPoints = (sect.members[playerId].contributionPoints || 0) + points;
                sect.totalContributionPoints = (sect.totalContributionPoints || 0) + points;
                sect.logContribution(playerId, player.name, "won_pvp_event", `Won '${eventName}'.`, points);
                await this.saveSectData(sectId);
                displayMessage(`${player.name} gained ${points} contribution points for winning the PvP event: ${eventName}.`, "success");
            },
            setMainView(viewType) {
                // Hide all specific view divs first
                if (combatInterface) combatInterface.style.display = 'none';
                if (classSelectionInfoDiv) classSelectionInfoDiv.style.display = 'none';
                if (inventoryMenuDiv) inventoryMenuDiv.style.display = 'none'; // Old text inventory
                if (marketMenuDiv) marketMenuDiv.style.display = 'none';
                if (marketListingsViewDiv) marketListingsViewDiv.style.display = 'none';
                if (concoctionMenuDiv) concoctionMenuDiv.style.display = 'none';
                if (sectCreationPanelDiv) sectCreationPanelDiv.style.display = 'none';
                if (sectDashboardPanelDiv) sectDashboardPanelDiv.style.display = 'none';
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';
                const attrAllocMenu = document.getElementById('attribute-allocation-menu');
                if (attrAllocMenu) attrAllocMenu.style.display = 'none';
                
                // Hide/Show game-output (log) and action-buttons-container based on view
                if (gameContainer) gameContainer.style.backgroundImage = "url('main.png')"; // Default background
                if (gameOutput) gameOutput.style.display = 'block'; // Default to show log
                if (actionButtonsContainer) actionButtonsContainer.style.display = 'grid'; // Default to show main actions

                document.body.classList.remove('view-mode-gameplay', 'view-mode-profile');
                // Chat visibility is handled independently by toggling 'chat-visible'

                if (viewType === 'gameplay') {
                    document.body.classList.add('view-mode-gameplay');
                    // If chat was meant to be hidden in gameplay, uncomment next line
                    // statsPanelAside.style.display = 'none'; // Handled by CSS
                    // gameOutputContainer.style.display = 'flex'; // Handled by CSS
                    // document.body.classList.remove('chat-visible');
                } else if (viewType === 'profile') {
                    document.body.classList.add('view-mode-profile');
                    // statsPanelAside.style.display = 'block'; // Handled by CSS
                    // gameOutputContainer.style.display = 'none'; // Handled by CSS
                     // If chat was meant to be hidden in profile, uncomment next line
                    // document.body.classList.remove('chat-visible');
                } else if (viewType === 'player_search') {
                    // No specific body class needed if playerSearchViewDiv is managed directly
                    // but ensure stats panel is hidden and game output container is visible for the search UI
                    document.body.classList.add('view-mode-gameplay'); // Re-use gameplay for layout
                } else if (viewType === 'dedicated_exploration') { // New view type for dedicated exploration
                    document.body.classList.add('view-mode-gameplay'); // Use gameplay layout
                    // Background image for the area will be set by showDedicatedExplorationView
                }
                // Ensure stats panel is updated if visible
                if (document.body.classList.contains('view-mode-profile') && this.players[this.currentPlayerId]) {
                    updateStatsDisplay(this.players[this.currentPlayerId]);
                }
                // The actual display toggling is handled by CSS based on body classes.
            },
            showPlayerSearch() {
                this.currentGameState = 'PLAYER_SEARCH';
                this.setMainView('player_search'); // This will set body class and hide stats panel

                // Explicitly hide game log and main action buttons
                if (gameOutput) gameOutput.style.display = 'none';
                if (actionButtonsContainer) actionButtonsContainer.style.display = 'none';
                gameContainer.style.backgroundImage = "url('main.png')"; // Reset background
                
                // Show player search view
                if (playerSearchViewDiv) {
                    playerSearchViewDiv.style.display = 'block';
                    playerSearchViewDiv.innerHTML = `
                        <h3>Search Players</h3>
                        <div class="mb-4 flex gap-2">
                            <input type="text" id="player-search-input" class="modal-input flex-grow" placeholder="Enter player name...">
                            <button id="player-search-button" class="action-button bg-blue-600 hover:bg-blue-700">Search</button>
                        </div>
                        <div id="player-search-results" class="space-y-2 max-h-96 overflow-y-auto pr-2">
                            <!-- Search results will appear here -->
                        </div>
                        <button id="player-search-back-button" class="action-button bg-gray-600 hover:bg-gray-700 mt-4">Back to Menu</button>
                    `;

                    document.getElementById('player-search-button')?.addEventListener('click', () => Game.executePlayerSearch());
                    document.getElementById('player-search-input')?.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') Game.executePlayerSearch();
                    });
                    document.getElementById('player-search-back-button')?.addEventListener('click', () => {
                        if (gameOutput) gameOutput.style.display = 'block'; // Restore log
                        if (actionButtonsContainer) actionButtonsContainer.style.display = 'grid'; // Restore main actions
                        Game.showLoggedInMenu();
                    });
                }
            },
            async executePlayerSearch() {
                const searchInput = document.getElementById('player-search-input');
                const resultsDiv = document.getElementById('player-search-results');
                if (!searchInput || !resultsDiv) return;

                const searchTerm = searchInput.value.trim();
                if (searchTerm.length < 1) {
                    resultsDiv.innerHTML = '<p class="text-gray-400">Please enter a name to search.</p>';
                    return;
                }
                resultsDiv.innerHTML = '<p class="text-gray-400">Searching...</p>';

                try {
                    // Firestore is case-sensitive. This query finds names starting with searchTerm.
                    const querySnapshot = await db.collection("players")
                        .where("name", ">=", searchTerm)
                        .where("name", "<=", searchTerm + '\uf8ff') // \uf8ff is a very high Unicode character
                        .limit(10)
                        .get();

                    if (querySnapshot.empty) {
                        resultsDiv.innerHTML = '<p class="text-gray-400">No players found matching that name.</p>';
                    } else {
                        this.displayPlayerSearchResults(querySnapshot.docs);
                    }
                } catch (error) {
                    console.error("Error searching players:", error);
                    resultsDiv.innerHTML = '<p class="text-red-500">Error performing search. Please try again.</p>';
                }
            },
            displayPlayerSearchResults(playerDocs) {
                const resultsDiv = document.getElementById('player-search-results');
                if (!resultsDiv) return;
                resultsDiv.innerHTML = ''; // Clear previous results or "Searching..."

                playerDocs.forEach(doc => {
                    const playerData = doc.data();
                    // Create a temporary Player instance to use getCultivationRealmName, or access level directly
                    const tempPlayer = Player.fromFirestoreObject(playerData); 

                    const playerDiv = document.createElement('div');
                    playerDiv.classList.add('player-search-result-item', 'p-2', 'bg-gray-700', 'rounded');
                    // Escape single quotes in player name for the onclick handler
                    const escapedPlayerName = playerData.name.replace(/'/g, "\\'");
                    playerDiv.innerHTML = `
                        <p class="font-semibold text-lg"><a href="#" onclick="Game.handlePlayerChoice('prompt_view_player_profile', { playerId: '${doc.id}', playerName: '${escapedPlayerName}'})" class="text-blue-400 hover:text-blue-300">${playerData.name}</a></p>
                        <p class="text-sm">Level: ${tempPlayer.cultivationLevel} (${tempPlayer.getCultivationRealmName()})</p>
                        ${playerData.chosenClassName && playerData.chosenClassName !== "Undetermined" ? `<p class="text-xs text-gray-400">Class: ${playerData.chosenClassName}</p>` : ''}
                        ${playerData.sectId && Game.sects[playerData.sectId] ? `<p class="text-xs text-gray-400">Sect: ${Game.sects[playerData.sectId].name}</p>` : ''}
                        <!-- Add more details or actions here in the future, e.g., a "View Profile" button -->
                    `;
                    resultsDiv.appendChild(playerDiv);
                });
            },

            async promptViewPlayerProfile(playerId, playerName) {
                const confirm = await getModalInput(`View profile of ${playerName}? (yes/no)`);
                if (confirm && confirm.toLowerCase() === 'yes') {
                    this.viewPlayerProfile(playerId, playerName);
                } else {
                    // Optional: display a message or simply do nothing, keeping the search results visible.
                    // displayMessage("Profile view cancelled.", "narration");
                }
            },

            async viewPlayerProfile(playerId, playerName) {
                // Hide player search view
                if (playerSearchViewDiv) playerSearchViewDiv.style.display = 'none';

                // Ensure game output and action buttons container are visible (like in gameplay view)
                // We'll use the gameplay view layout for displaying the profile in the main log area
                this.setMainView('gameplay'); // This will handle general layout
                
                // Clear existing game output and action buttons
                if (gameOutput) gameOutput.innerHTML = '';
                if (actionButtonsContainer) actionButtonsContainer.innerHTML = '';

                displayMessage(`Viewing profile of ${playerName} (ID: ${playerId})...`, 'system');

                try {
                    const playerDoc = await db.collection("players").doc(playerId).get();

                    if (playerDoc.exists) {
                        const playerData = playerDoc.data();
                        // Use the Player class to format the data and get derived stats/names
                        const viewedPlayer = Player.fromFirestoreObject(playerData);

                        displayMessage(`\n--- Profile: ${viewedPlayer.name} ---`, 'important');
                        displayMessage(`Level: ${viewedPlayer.cultivationLevel} (${viewedPlayer.getCultivationRealmName()})`, 'narration');
                        displayMessage(`Class: ${viewedPlayer.chosenClassName || "Undetermined"}`, 'narration');
                        displayMessage(`Spiritual Root: ${viewedPlayer.spiritualRootName || "Undetermined"}`, 'narration');
                        displayMessage(`Sect: ${viewedPlayer.sectId && Game.sects[viewedPlayer.sectId] ? Game.sects[viewedPlayer.sectId].name : "None"}`, 'narration');
                        displayMessage(`\nBasic Attributes:`, 'system');
                        displayMessage(`STR: ${viewedPlayer.strength} | AGI: ${viewedPlayer.agility} | CON: ${viewedPlayer.constitution}`, 'narration');
                        displayMessage(`SPR: ${viewedPlayer.spirit} | INT: ${viewedPlayer.intellect} | WIL: ${viewedPlayer.willpower}`, 'narration');
                        displayMessage(`\n(This is a basic profile view. More details coming soon!)`, 'narration');

                    } else {
                        displayMessage(`Player with ID ${playerId} not found.`, 'error');
                    }
                } catch (error) {
                    console.error("Error fetching player profile:", error);
                    displayMessage("Error loading player profile. Please try again.", "error");
                }

                // Always show navigation buttons after attempting to load
                populateActionButtons([
                    { text: "Back to Player Search", action: "show_player_search", style: "neutral" },
                    { text: "Back to Main Menu", action: "show_logged_in_menu", style: "neutral" }
                ], actionButtonsContainer);
            },

            async sendChatMessage(messageText) {
                if (!this.currentPlayerId || !this.players[this.currentPlayerId]) {
                    console.error("No current player to send chat message.");
                    displayMessage("You must be logged in to chat.", "error");
                    return;
                }
                if (!messageText || messageText.length > 200) { 
                    displayMessage("Message is empty or too long (max 200 chars).", "error");
                    return;
                }

                const player = this.players[this.currentPlayerId];
                const messageData = {
                    senderId: player.playerId,
                    senderName: player.name,
                    text: messageText,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };

                try {
                    await db.collection("chatMessages").add(messageData);
                } catch (error) {
                    console.error("Error sending chat message:", error);
                    displayMessage("Failed to send message. Check connection.", "error");
                }
            },

            listenForChatMessages() {
                if (this.chatMessagesListener) { 
                    this.chatMessagesListener(); 
                }

                this.chatMessagesListener = db.collection("chatMessages")
                    .orderBy("timestamp", "asc") 
                    .limitToLast(MAX_CHAT_MESSAGES_DISPLAYED) 
                    .onSnapshot(querySnapshot => {
                        if (chatLogContainer) chatLogContainer.innerHTML = ''; 
                        querySnapshot.forEach(doc => {
                            const msgData = doc.data();
                            if (msgData.timestamp) { 
                                 displayChatMessage(msgData); 
                            }
                        });
                    }, error => {
                        console.error("Error listening to chat messages:", error);
                        displayMessage("Chat connection error.", "error");
                    });
            },

            stopListeningForChatMessages() {
                if (this.chatMessagesListener) {
                    this.chatMessagesListener(); 
                    this.chatMessagesListener = null;
                    console.log("Stopped listening for chat messages.");
                }
            },
            loadPillDataFromCSV(csvData) {
                const lines = csvData.trim().split('\n');
                const headers = lines[0].split(',');

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim());
                    const elixirName = values[0];
                    const ingredientsStr = values[1];
                    const useDescription = values[2];

                    const recipeKey = toCamelCase(elixirName);
                    const pillItemKey = recipeKey + "Item"; 
                    const recipeItemKey = recipeKey + "Recipe"; 

                    const ingredients = {};
                    ingredientsStr.split(' + ').forEach(ingFull => {
                        const ingName = ingFull.trim();
                        const ingKey = toCamelCase(ingName);
                        if (Game.ITEM_DATA[ingKey]) { 
                            ingredients[ingKey] = (ingredients[ingKey] || 0) + 1;
                        } else {
                            console.warn(`Unknown ingredient '${ingName}' (key: '${ingKey}') for pill '${elixirName}'. Define in ITEM_DATA or ensure image ${ingKey}.png exists.`);
                             if (!Game.ITEM_DATA[ingKey]) {
                                Game.ITEM_DATA[ingKey] = { name: ingName, description: `Herb for alchemy: ${ingName}.`, type: "material", tier: 1, gameAsset: ingKey + '.png' };
                                console.log(`Fallback: Created basic material for ${ingName} as ${ingKey}`);
                            }
                            ingredients[ingKey] = (ingredients[ingKey] || 0) + 1;
                        }
                    });
                    
                    let qiCost = 5 + Object.keys(ingredients).length * 3 + (elixirName.length / 2); 
                    let requiredLevel = 1; 
                    
                    if (elixirName === "Foundation Establishment Pill") requiredLevel = 9; 
                    else if (elixirName === "Golden Core Nine Revolutions Pill") requiredLevel = 18;
                    else if (elixirName === "Nascent Soul Unification Pill") requiredLevel = 27;
                    else if (elixirName === "Soul Formation Heaven Pill") requiredLevel = 36;
                    else if (elixirName === "Transcendence Void Elixir") requiredLevel = 45;
                    else if (elixirName.includes("Advanced") || elixirName.includes("Core")) requiredLevel = 19; 
                    else if (elixirName.includes("Nascent Soul")) requiredLevel = 28; 
                    else if (useDescription.toLowerCase().includes("core cultivators")) requiredLevel = 19;
                    else if (useDescription.toLowerCase().includes("nascent soul")) requiredLevel = 28;


                    Game.PILL_RECIPES[recipeKey] = {
                        name: elixirName,
                        recipeKey: recipeKey,
                        ingredients: ingredients,
                        producesItemKey: pillItemKey,
                        productName: elixirName,
                        useDescription: useDescription,
                        qiCost: Math.floor(qiCost),
                        requiredCultivationLevel: requiredLevel, 
                        isBasic: elixirName === "Basic Qi Recovery Pill"
                    };

                    if (!Game.ITEM_DATA[pillItemKey]) {
                        let isBreakthroughPill = (
                            elixirName === "Foundation Establishment Pill" ||
                            elixirName === "Golden Core Nine Revolutions Pill" ||
                            elixirName === "Nascent Soul Unification Pill" ||
                            elixirName === "Soul Formation Heaven Pill" ||
                            elixirName === "Transcendence Void Elixir"
                        );
                        let isPermanentStatPill = (
                            elixirName === "Starforge Strength Pill" ||
                            elixirName === "Agility Surge Pill"
                        );

                        Game.ITEM_DATA[pillItemKey] = {
                            name: elixirName,
                            description: useDescription,
                            type: "consumable",
                            gameAsset: pillItemKey + '.png', 
                            effect: function(player) { 
                                displayMessage(`Using ${this.name}...`, "item-use");
                                let healed = 0, qiRestored = 0, tempAttack = 0, tempDefense = 0;
                                let itemUsedSuccessfully = false; 
                                
                                if (elixirName === "Foundation Establishment Pill") {
                                    if (player.cultivationLevel === 9 && player.cultivationProgress >= player.getXPForNextLevel()) {
                                        player._performMajorBreakthrough(10, "Foundation Establishment");
                                        itemUsedSuccessfully = true;
                                    } else {
                                        displayMessage("You are not ready for this breakthrough. Reach Level 9 with full cultivation progress.", "error");
                                    }
                                } else if (elixirName === "Golden Core Nine Revolutions Pill") {
                                    if (player.cultivationLevel === 18 && player.cultivationProgress >= player.getXPForNextLevel()) {
                                        player._performMajorBreakthrough(19, "Core Formation");
                                        itemUsedSuccessfully = true;
                                    } else {
                                        displayMessage("You are not ready for this breakthrough. Reach Level 18 with full cultivation progress.", "error");
                                    }
                                } else if (elixirName === "Nascent Soul Unification Pill") {
                                     if (player.cultivationLevel === 27 && player.cultivationProgress >= player.getXPForNextLevel()) {
                                        player._performMajorBreakthrough(28, "Nascent Soul");
                                        itemUsedSuccessfully = true;
                                    } else {
                                        displayMessage("You are not ready for this breakthrough. Reach Level 27 with full cultivation progress.", "error");
                                    }
                                } else if (elixirName === "Soul Formation Heaven Pill") {
                                     if (player.cultivationLevel === 36 && player.cultivationProgress >= player.getXPForNextLevel()) {
                                        player._performMajorBreakthrough(37, "Soul Formation");
                                        itemUsedSuccessfully = true;
                                    } else {
                                        displayMessage("You are not ready for this breakthrough. Reach Level 36 with full cultivation progress.", "error");
                                    }
                                } else if (elixirName === "Transcendence Void Elixir") {
                                     if (player.cultivationLevel === 45 && player.cultivationProgress >= player.getXPForNextLevel()) {
                                        player._performMajorBreakthrough(46, "Transcendent");
                                        itemUsedSuccessfully = true;
                                    } else {
                                        displayMessage("You are not ready for this breakthrough. Reach Level 45 with full cultivation progress.", "error");
                                    }
                                } 
                                else if (this.name === "Basic Qi Recovery Pill") { qiRestored = 20 + Math.floor(player.cultivationLevel / 2); itemUsedSuccessfully = true; }
                                else if (this.name === "Vitality Rejuvenation Pill") { healed = 40 + player.cultivationLevel; player.currentQi = Math.min(player.maxQi, player.currentQi + 10); itemUsedSuccessfully = true;} 
                                else if (this.name === "Mind-Calming Elixir") { player.currentQi = Math.min(player.maxQi, player.currentQi + 15); itemUsedSuccessfully = true;}
                                else if (this.name === "Advanced Spirit Pill") { qiRestored = 100 + player.cultivationLevel * 2; healed = 20; itemUsedSuccessfully = true;}
                                else if (this.name === "Nascent Soul Vital Pill") { qiRestored = 200 + player.cultivationLevel * 3; healed = 150 + player.cultivationLevel * 2; itemUsedSuccessfully = true;}
                                else if (this.name === "Starforge Strength Pill") { player.attack += 1; displayMessage("Your physical strength permanently increases by 1!", "success"); itemUsedSuccessfully = true;} 
                                else if (this.name === "Agility Surge Pill") { player.defense += 1; displayMessage("Your agility (defense) permanently increases by 1!", "success"); itemUsedSuccessfully = true;} 
                                else if (this.name === "Spirit-Eye Elixir") { qiRestored = 25; itemUsedSuccessfully = true;}
                                else if (this.name === "Flame Infusion Pill") { tempAttack = 5; displayMessage("You feel a fiery surge!", "item-use"); itemUsedSuccessfully = true;} 
                                else if (this.name === "Balance Harmonization Pill") { qiRestored = 30; healed = 10; displayMessage("Your Qi feels more harmonious.", "item-use"); itemUsedSuccessfully = true;}


                                if (healed > 0) { player.health = Math.min(player.maxHealth, player.health + healed); displayMessage(`Restored ${healed} HP.`, "success"); }
                                if (qiRestored > 0) { player.currentQi = Math.min(player.maxQi, player.currentQi + qiRestored); displayMessage(`Restored ${qiRestored} QI.`, "qi-recovery"); }
                                
                                if (itemUsedSuccessfully) {
                                    player.resources[pillItemKey]--; 
                                }
                            },
                            usableInCombat: !(isBreakthroughPill || isPermanentStatPill)
                        };
                    }

                    if (elixirName !== "Basic Qi Recovery Pill" && !Game.ITEM_DATA[recipeItemKey]) {
                        Game.ITEM_DATA[recipeItemKey] = {
                            name: `Recipe: ${elixirName}`,
                            description: `Teaches the method to concoct ${elixirName}. Ingredients: ${ingredientsStr.replace(/\s\+\s/g, ', ')}.`,
                            type: "recipe",
                            gameAsset: 'recipe.png', // Use common recipe image for all recipes
                            learnsRecipeKey: recipeKey, 
                            effect: function(player) { 
                                if (!player.knownRecipes) player.knownRecipes = [];
                                const recipeKeyToLearn = this.learnsRecipeKey; 
                                if (!player.knownRecipes.includes(recipeKeyToLearn)) {
                                    player.knownRecipes.push(recipeKeyToLearn);
                                    displayMessage(`You learned the recipe for ${Game.PILL_RECIPES[recipeKeyToLearn].name}!`, "success");
                                } else {
                                    displayMessage(`You already know the recipe for ${Game.PILL_RECIPES[recipeKeyToLearn].name}.`, "narration");
                                }
                                player.resources[recipeItemKey]--; 
                            }
                        };
                    }
                }
                
            }
        }; 

        const pillCsvData = `Elixir Name,Ingredients,Use
Basic Qi Recovery Pill,Jadeleaf Grass + Crimson Spirit Berry,Restores a small amount of Qi for Qi Refining cultivators.
Vitality Rejuvenation Pill,Moondew Flower + Earthroot Ginseng,Heals minor injuries and restores stamina quickly.
Mind-Calming Elixir,Soothing Rain Petal + Whispering Leaf,Clears mental fatigue and stabilizes Qi flow.
Advanced Spirit Pill,Sky Lotus Bud + Spiritglow Mushroom,Restores large amounts of Qi and spiritual health for Core cultivators.
Nascent Soul Vital Pill,Cloudmoss Vine + Radiant Sunfruit,High-grade healing and Qi replenishment for Nascent Soul stage cultivators.
Foundation Establishment Pill,Breakthrough Vine + Soothing Rain Petal,Assists Qi Refining cultivators in establishing a stable foundation.
Golden Core Nine Revolutions Pill,Dragonbone Fern + Spiritglow Mushroom + Earthroot Ginseng,Supports the formation of a perfect golden core with enhanced spiritual potential.
Nascent Soul Unification Pill,Phoenixblood Herb + Ascension Orchid,Facilitates smooth transition from Core Formation to Nascent Soul realm.
Soul Formation Heaven Pill,Heavenpierce Root + Lunar Bloom,Required to survive the soul tribulation and form the divine soul.
Transcendence Void Elixir,Voidberry Thorn + ImmortalDustleaf,Enables Soul Formation experts to ascend to the Transcendent realm.
Starforge Strength Pill,Starforge Petal + Stoneheart Root,Permanently increases physical strength and endurance.
Spirit-Eye Elixir,Spirit-Eye Flower + Heartblossom Bud,"Improves spiritual perception, range of sight, and soul awareness."
Agility Surge Pill,Silverstorm Leaf + GoldenDantian Fruit,Boosts movement speed and cultivator evasion skills.
Flame Infusion Pill,Blackflame Ginseng + Frostmarrow Moss,Enhances fire affinity and provides resistance to ice and soul damage.
Balance Harmonization Pill,Harmonizing Bellvine + Eye of the Ancients,Balances chaotic elemental Qi and enhances technique comprehension.`;


        window.onload = () => {
            try { Game.initializeGame(); }  // This will now call the version that handles URL params
            catch (e) { 
                console.error("Initialization Error:", e); 
                if(document.body)document.body.innerHTML = '<div style="color:red;padding:20px;font-size:18px;text-align:center;">A fatal error occurred during game initialization. Please check the console (F12) for details and try reloading.</div>';
            }
        };
        // --- END: JAVASCRIPT GAME ENGINE ---
    </script>
</body>
</html>